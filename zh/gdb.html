

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>10. gdb &mdash; akabook 3.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="akabook 3.0 documentation" href="../index.html" />
    <link rel="up" title="中文版：Linux C/C++編程一站式學習" href="index.html" />
    <link rel="next" title="11. 排序與查找" href="sortsearch.html" />
    <link rel="prev" title="9. 編碼風格" href="codingstyle.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="sortsearch.html" title="11. 排序與查找"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="codingstyle.html" title="9. 編碼風格"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">akabook 3.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">中文版：Linux C/C++編程一站式學習</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="gdb">
<h1>10. gdb<a class="headerlink" href="#gdb" title="Permalink to this headline">¶</a></h1>
<p>程序中除了一目瞭然的Bug之外都需要一定的調試手段來分析到底錯在哪。到目前為止我們的調試手段只有一種：根據程序執行時的出錯現象假設錯誤原因，然後在代碼中適當的位置插入 <tt class="docutils literal"><span class="pre">printf</span></tt> ，執行程序並分析打印結果，如果結果和預期的一樣，就基本上證明了自己假設的錯誤原因，就可以動手修Bug了，如果結果和預期的不一樣，就根據結果做進一步的假設和分析。</p>
<p>本章我們介紹一種很強大的調試工具 <strong class="command">gdb</strong> ，可以完全操控程序的運行，使得程序就像你手裡的玩具一樣，叫它走就走，叫它停就停，並且隨時可以查看程序中所有的內部狀態，比如各變數的值、傳給函數的參數、當前執行的代碼行等。掌握了 <strong class="command">gdb</strong> 的用法之後，調試手段就更加豐富了。但要注意，即使調試手段豐富了，調試的基本思想仍然是“分析現象→假設錯誤原因→產生新的現象去驗證假設”這樣一個循環，根據現象如何假設錯誤原因，以及如何設計新的現象去驗證假設，這都需要非常嚴密的分析和思考，如果因為手裡有了強大的工具就濫用而忽略了分析過程，往往會治標不治本地修正Bug，導致一個錯誤現象消失了但Bug仍然存在，甚至是把程序越改越錯。本章通過初學者易犯的幾個錯誤實例來講解如何使用 <strong class="command">gdb</strong> 調試程序，在每個實例後面總結一部分常用的 <strong class="command">gdb</strong> 命令。</p>
<div class="section" id="id1">
<h2>10.1. 單步執行和跟蹤函數調用<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h2>
<p>看下面的程序：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">add_range</span><span class="p">(</span><span class="kt">int</span> <span class="n">low</span><span class="p">,</span> <span class="kt">int</span> <span class="n">high</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">sum</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">high</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">result</span><span class="p">[</span><span class="mi">1000</span><span class="p">];</span>
        <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">);</span>
        <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">add_range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">100</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;result[0]=%d</span><span class="se">\n</span><span class="s">result[1]=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><tt class="docutils literal"><span class="pre">add_range</span></tt> 函數從 <tt class="docutils literal"><span class="pre">low</span></tt> 加到 <tt class="docutils literal"><span class="pre">high</span></tt> ，在 <tt class="docutils literal"><span class="pre">main</span></tt> 函數中首先從1加到10，把結果保存下來，然後從1加到100，再把結果保存下來，最後打印的兩個結果是:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="mi">55</span>
<span class="n">result</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="mi">5105</span>
</pre></div>
</div>
<p>第一個結果正確，第二個結果顯然不正確 <a class="footnote-reference" href="#id3" id="id2">[1]</a> ，在小學我們就聽說過高斯小時候的故事，從1加到100應該是5050。一段代碼，第一次運行結果是對的，第二次運行卻不對，這是很常見的一類錯誤現象，這種情況一方面要懷疑代碼，另一方面更要懷疑數據：第一次和第二次運行的都是同一段代碼，如果代碼是錯的，那第一次的結果為什麼能對呢？所以很可能是第二次運行時相關的狀態和數據錯了，錯誤的數據導致了錯誤的結果。在動手調試之前，讀者先試試只看代碼能不能看出錯誤原因，只要前面幾章學得紮實就應該能看出來。</p>
<table class="docutils footnote" frame="void" id="id3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[1]</a></td><td>如果你編譯運行這個程序的環境和我的環境（Ubuntu 12.04 LTS 32位x86）不同，也許在你的機器上跑不出這個結果，那也沒關係，重要的是學會本章介紹的思想方法。另外你也可以嘗試修改程序，總有辦法得到類似的結果，上例中故意定義了一個很大的數組 <tt class="docutils literal"><span class="pre">result[1000]</span></tt> ，修改數組的大小就會改變各局部變數的存儲空間的位置，運行結果就可能會不同。</td></tr>
</tbody>
</table>
<p>在編譯時要加上 <em class="xref std std-option">-g</em> 選項，生成的執行檔才能用 <strong class="command">gdb</strong> 進行源碼級調試:</p>
<div class="highlight-python"><pre>$ gcc -g main.c -o main
$ gdb main
GNU gdb (Ubuntu/Linaro 7.4-2012.02-0ubuntu2) 7.4-2012.02
Copyright (C) 2012 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i686-linux-gnu".
For bug reporting instructions, please see:
&lt;http://bugs.launchpad.net/gdb-linaro/&gt;...
Reading symbols from /home/akaedu/main...done.
(gdb)</pre>
</div>
<p><em class="xref std std-option">-g</em> 選項的作用是在執行檔中加入源檔案的信息，即執行檔 <tt class="file docutils literal"><span class="pre">main</span></tt> 中的第幾條機器指令對應源檔案 <tt class="file docutils literal"><span class="pre">main.c</span></tt> 的第幾行，但並不是把整個源檔案嵌入到執行檔中，所以在調試時必須保證 <strong class="command">gdb</strong> 能找到源檔案 <tt class="file docutils literal"><span class="pre">main.c</span></tt> 。 <strong class="command">gdb</strong> 提供一個類似Shell的命令行環境，上面的 <tt class="docutils literal"><span class="pre">(gdb)</span></tt> 就是提示符，在這個提示符下輸入 <tt class="docutils literal"><span class="pre">help</span></tt> 可以查看命令的類別:</p>
<div class="highlight-python"><pre>(gdb) help
List of classes of commands:

aliases -- Aliases of other commands
breakpoints -- Making program stop at certain points
data -- Examining data
files -- Specifying and examining files
internals -- Maintenance commands
obscure -- Obscure features
running -- Running the program
stack -- Examining the stack
status -- Status inquiries
support -- Support facilities
tracepoints -- Tracing of program execution without stopping the program
user-defined -- User-defined commands

Type "help" followed by a class name for a list of commands in that class.
Type "help all" for the list of all commands.
Type "help" followed by command name for full documentation.
Type "apropos word" to search for commands related to "word".
Command name abbreviations are allowed if unambiguous.</pre>
</div>
<p>也可以進一步查看某一類別中有哪些命令，例如查看 <tt class="docutils literal"><span class="pre">files</span></tt> 類別下有哪些命令可用:</p>
<div class="highlight-python"><pre>(gdb) help files
Specifying and examining files.

List of commands:

add-symbol-file -- Load symbols from FILE
add-symbol-file-from-memory -- Load the symbols out of memory from a dynamically loaded object file
cd -- Set working directory to DIR for debugger and program being debugged
core-file -- Use FILE as core dump for examining memory and registers
directory -- Add directory DIR to beginning of search path for source files
edit -- Edit specified file or function
exec-file -- Use FILE as program for getting contents of pure memory
file -- Use FILE as program to be debugged
forward-search -- Search for regular expression (see regex(3)) from last line listed
generate-core-file -- Save a core file with the current state of the debugged process
list -- List specified function or line
...</pre>
</div>
<p>現在試試用 <tt class="docutils literal"><span class="pre">list</span></tt> 命令從第一行開始列出原始碼:</p>
<div class="highlight-python"><pre>(gdb) list 1
1    #include &lt;stdio.h&gt;
2
3    int add_range(int low, int high)
4    {
5            int i, sum;
6            for (i = low; i &lt;= high; i++)
7                    sum = sum + i;
8            return sum;
9    }
10</pre>
</div>
<p>一次只列10行，如果要從第11行開始繼續列原始碼可以再輸入一次:</p>
<div class="highlight-python"><pre>(gdb) list</pre>
</div>
<p>也可以什麼都不輸直接敲回車， <strong class="command">gdb</strong> 提供了一個很方便的功能，在提示符下直接敲回車表示重複上一條命令:</p>
<div class="highlight-python"><pre>(gdb) （直接回車）
11   int main(void)
12   {
13           int result[1000];
14           result[0] = add_range(1, 10);
15           result[1] = add_range(1, 100);
16           printf("result[0]=%d\nresult[1]=%d\n", result[0], result[1]);
17           return 0;
18   }</pre>
</div>
<p><strong class="command">gdb</strong> 的很多常用命令有簡寫形式，例如 <tt class="docutils literal"><span class="pre">list</span></tt> 命令可以寫成 <tt class="docutils literal"><span class="pre">l</span></tt> ，要列一個函數的原始碼也可以用函數名做參數:</p>
<div class="highlight-python"><pre>(gdb) l add_range
1    #include &lt;stdio.h&gt;
2
3    int add_range(int low, int high)
4    {
5            int i, sum;
6            for (i = low; i &lt;= high; i++)
7                    sum = sum + i;
8            return sum;
9    }
10</pre>
</div>
<p>現在退出 <strong class="command">gdb</strong> 的環境:</p>
<div class="highlight-python"><pre>(gdb) quit</pre>
</div>
<p>我們做一個實驗，把原始碼改名或移到別處再用 <strong class="command">gdb</strong> 調試，這樣就列不出原始碼了:</p>
<div class="highlight-python"><pre>$ mv main.c mian.c
$ gdb main
...
(gdb) l
5    main.c: No such file or directory.</pre>
</div>
<p>可見 <strong class="command">gcc</strong> 的 <em class="xref std std-option">-g</em> 選項並不是把原始碼嵌入到執行檔中，在調試時也需要源檔案。現在把原始碼恢復原樣，我們繼續調試。首先用 <tt class="docutils literal"><span class="pre">start</span></tt> 命令開始執行程序:</p>
<div class="highlight-python"><pre>$ gdb main
...
(gdb) start
Temporary breakpoint 1 at 0x8048415: file main.c, line 14.
Starting program: /home/akaedu/main

Temporary breakpoint 1, main () at main.c:14
14           result[0] = add_range(1, 10);
(gdb)</pre>
</div>
<p><strong class="command">gdb</strong> 停在 <tt class="docutils literal"><span class="pre">main</span></tt> 函數中變數定義之後的第一條語句處等待我們發命令（ <strong class="command">gdb</strong> 在提示符之前最後列出的語句總是“即將執行的下一條語句”）。我們可以用 <tt class="docutils literal"><span class="pre">next</span></tt> 命令（簡寫為 <tt class="docutils literal"><span class="pre">n</span></tt> ）控制這些語句一條一條地執行:</p>
<div class="highlight-python"><pre>(gdb) n
15           result[1] = add_range(1, 100);
(gdb) （直接回車）
16           printf("result[0]=%d\nresult[1]=%d\n", result[0], result[1]);
(gdb) （直接回車）
result[0]=55
result[1]=5105
17           return 0;</pre>
</div>
<p>用 <tt class="docutils literal"><span class="pre">n</span></tt> 命令依次執行兩行賦值語句和一行打印語句，在執行打印語句時結果立刻打出來了，然後停在 <tt class="docutils literal"><span class="pre">return</span></tt> 語句之前等待我們發命令。雖然我們完全控制了程序的執行，但仍然看不出哪裡錯了，因為錯誤不在 <tt class="docutils literal"><span class="pre">main</span></tt> 函數中而在 <tt class="docutils literal"><span class="pre">add_range</span></tt> 函數中，現在用 <tt class="docutils literal"><span class="pre">start</span></tt> 命令重新來過，這次用 <tt class="docutils literal"><span class="pre">step</span></tt> 命令（簡寫為 <tt class="docutils literal"><span class="pre">s</span></tt> ）鑽進 <tt class="docutils literal"><span class="pre">add_range</span></tt> 函數中去跟蹤執行:</p>
<div class="highlight-python"><pre>(gdb) start
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Temporary breakpoint 2 at 0x8048415: file main.c, line 14.
Starting program: /home/akaedu/main

Temporary breakpoint 2, main () at main.c:14
14           result[0] = add_range(1, 10);
(gdb) s
add_range (low=1, high=10) at main.c:6
6            for (i = low; i &lt;= high; i++)</pre>
</div>
<p>這次停在了 <tt class="docutils literal"><span class="pre">add_range</span></tt> 函數中變數定義之後的第一條語句處。在函數中有幾種查看狀態的辦法， <tt class="docutils literal"><span class="pre">backtrace</span></tt> 命令（簡寫為 <tt class="docutils literal"><span class="pre">bt</span></tt> ）可以查看函數調用的棧幀：</p>
<p>(gdb) bt
#0  add_range (low=1, high=10) at main.c:6
#1  0x08048429 in main () at main.c:14</p>
<p>可見當前的 <tt class="docutils literal"><span class="pre">add_range</span></tt> 函數是被 <tt class="docutils literal"><span class="pre">main</span></tt> 函數調用的， <tt class="docutils literal"><span class="pre">main</span></tt> 傳進來的參數是 <tt class="docutils literal"><span class="pre">low=1,</span> <span class="pre">high=10</span></tt> 。 <tt class="docutils literal"><span class="pre">main</span></tt> 函數的棧幀編號為1， <tt class="docutils literal"><span class="pre">add_range</span></tt> 的棧幀編號為0。現在可以用 <tt class="docutils literal"><span class="pre">info</span></tt> 命令（簡寫為 <tt class="docutils literal"><span class="pre">i</span></tt> ）查看 <tt class="docutils literal"><span class="pre">add_range</span></tt> 函數局部變數的值:</p>
<div class="highlight-python"><pre>(gdb) i locals
i = 0
sum = 0</pre>
</div>
<p>如果想查看 <tt class="docutils literal"><span class="pre">main</span></tt> 函數當前局部變數的值也可以做到，先用 <tt class="docutils literal"><span class="pre">frame</span></tt> 命令（簡寫為 <tt class="docutils literal"><span class="pre">f</span></tt> ）選擇1號棧幀然後再查看局部變數:</p>
<div class="highlight-python"><pre>(gdb) f 1
#1  0x08048429 in main () at main.c:14
14           result[0] = add_range(1, 10);
(gdb) i locals
result = {0 &lt;repeats 471 times&gt;, 1184572, 0 &lt;repeats 11 times&gt;, -1207961512, -1073746088, 1249268, -1073745624, 1142336,
...</pre>
</div>
<p>注意到 <tt class="docutils literal"><span class="pre">result</span></tt> 數組中很多元素的值是雜亂無章的，我們知道未經初始化的局部變數具有不確定的值，到目前為止一切正常。用 <tt class="docutils literal"><span class="pre">s</span></tt> 或 <tt class="docutils literal"><span class="pre">n</span></tt> 往下走幾步，然後用 <tt class="docutils literal"><span class="pre">print</span></tt> 命令（簡寫為 <tt class="docutils literal"><span class="pre">p</span></tt> ）打印出變數 <tt class="docutils literal"><span class="pre">sum</span></tt> 的值:</p>
<div class="highlight-python"><pre>(gdb) s
7                    sum = sum + i;
(gdb) （直接回車）
6            for (i = low; i &lt;= high; i++)
(gdb) （直接回車）
7                    sum = sum + i;
(gdb) （直接回車）
6            for (i = low; i &lt;= high; i++)
(gdb) p sum
$1 = 3</pre>
</div>
<p>第一次循環 <tt class="docutils literal"><span class="pre">i</span></tt> 是1，第二次循環 <tt class="docutils literal"><span class="pre">i</span></tt> 是2，加起來是3，沒錯。這裡的 <tt class="docutils literal"><span class="pre">$1</span></tt> 表示 <strong class="command">gdb</strong> 保存着這些中間結果，$後面的編號會自動增長，在命令中可以用 <tt class="docutils literal"><span class="pre">$1</span></tt> 、 <tt class="docutils literal"><span class="pre">$2</span></tt> 、 <tt class="docutils literal"><span class="pre">$3</span></tt> 等編號代替相應的值。由於我們本來就知道第一次調用的結果是正確的，再往下跟也沒意義了，可以用 <tt class="docutils literal"><span class="pre">finish</span></tt> 命令讓程序一直運行到從當前函數返回為止:</p>
<div class="highlight-python"><pre>(gdb) finish
Run till exit from #0  add_range (low=1, high=10) at main.c:6
0x08048429 in main () at main.c:14
14           result[0] = add_range(1, 10);
Value returned is $2 = 55</pre>
</div>
<p>返回值是55，當前正準備執行賦值操作，用 <tt class="docutils literal"><span class="pre">n</span></tt> 命令執行賦值操作後查看 <tt class="docutils literal"><span class="pre">result</span></tt> 數組:</p>
<div class="highlight-python"><pre>(gdb) n
15           result[1] = add_range(1, 100);
(gdb) p result
$3 = {55, 0 &lt;repeats 470 times&gt;, 1184572, 0 &lt;repeats 11 times&gt;, -1207961512, -1073746088, 1249268, -1073745624, 1142336,
...</pre>
</div>
<p>第一個值55確實賦給了 <tt class="docutils literal"><span class="pre">result</span></tt> 數組的第0個元素。下面用 <tt class="docutils literal"><span class="pre">s</span></tt> 命令進入第二次 <tt class="docutils literal"><span class="pre">add_range</span></tt> 調用，進入之後首先查看參數和局部變數:</p>
<div class="highlight-python"><pre>(gdb) s
add_range (low=1, high=100) at main.c:6
6            for (i = low; i &lt;= high; i++)
(gdb) bt
#0  add_range (low=1, high=100) at main.c:6
#1  0x08048441 in main () at main.c:15
(gdb) i locals
i = 11
sum = 55</pre>
</div>
<p>由於局部變數 <tt class="docutils literal"><span class="pre">i</span></tt> 和 <tt class="docutils literal"><span class="pre">sum</span></tt> 沒初始化，所以具有不確定的值，又由於兩次調用是挨着的， <tt class="docutils literal"><span class="pre">i</span></tt> 和 <tt class="docutils literal"><span class="pre">sum</span></tt> 正好取了上次調用時的值，回顧一下我們講過的 <a class="reference internal" href="func.html#func-verifylocals"><em>驗證局部變數存儲空間的分配和釋放</em></a> 那個例子，其實和現在這個例子是一樣的道理，只不過我這次舉的例子設法讓局部變數 <tt class="docutils literal"><span class="pre">sum</span></tt> 在第一次調用時初值為0而第二次調用時初值不為0。 <tt class="docutils literal"><span class="pre">i</span></tt> 的初值不確定倒沒關係，在 <tt class="docutils literal"><span class="pre">for</span></tt> 循環中首先會把 <tt class="docutils literal"><span class="pre">i</span></tt> 賦值為 <tt class="docutils literal"><span class="pre">low</span></tt> ，但 <tt class="docutils literal"><span class="pre">sum</span></tt> 如果初值不是0，累加得到的結果就錯了。好了，我們已經找到錯誤原因，可以退出 <strong class="command">gdb</strong> 修改原始碼了。如果我們不想浪費這次調試機會，可以在 <strong class="command">gdb</strong> 中馬上把 <tt class="docutils literal"><span class="pre">sum</span></tt> 的初值改為0繼續運行，看看這一處改了之後還有沒有別的Bug:</p>
<div class="highlight-python"><pre>(gdb) set var sum=0
(gdb) finish
Run till exit from #0  add_range (low=1, high=100) at main.c:6
0x08048441 in main () at main.c:15
15           result[1] = add_range(1, 100);
Value returned is $4 = 5050
(gdb) n
16           printf("result[0]=%d\nresult[1]=%d\n", result[0], result[1]);
(gdb) （直接回車）
result[0]=55
result[1]=5050
17           return 0;</pre>
</div>
<p>這樣結果就對了。修改變數的值除了用 <tt class="docutils literal"><span class="pre">set</span></tt> 命令之外也可以用 <tt class="docutils literal"><span class="pre">print</span></tt> 命令，因為 <tt class="docutils literal"><span class="pre">print</span></tt> 命令後面跟的是表達式，而我們知道賦值和函數調用也都是表達式，所以也可以用 <tt class="docutils literal"><span class="pre">print</span></tt> 命令修改變數的值或者調用函數:</p>
<div class="highlight-python"><pre>(gdb) p result[2]=33
$5 = 33
(gdb) p printf("result[2]=%d\n", result[2])
result[2]=33
$6 = 13</pre>
</div>
<p>我們講過， <tt class="docutils literal"><span class="pre">printf</span></tt> 的返回值表示實際打印的字元數，所以 <tt class="docutils literal"><span class="pre">$6</span></tt> 的結果是13。最後總結一下本節用到的 <strong class="command">gdb</strong> 命令：</p>
<table border="1" class="docutils">
<caption>gdb基本命令1</caption>
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">命令</th>
<th class="head">描述</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>backtrace（或bt）</td>
<td>查看各級函數調用及參數</td>
</tr>
<tr class="row-odd"><td>finish</td>
<td>連續運行到當前函數返回為止，然後停下來等待命令</td>
</tr>
<tr class="row-even"><td>frame（或f） 幀編號</td>
<td>選擇棧幀</td>
</tr>
<tr class="row-odd"><td>info（或i） locals</td>
<td>查看當前棧幀局部變數的值</td>
</tr>
<tr class="row-even"><td>list（或l）</td>
<td>列出原始碼，接着上次的位置往下列，每次列10行</td>
</tr>
<tr class="row-odd"><td>list 行號</td>
<td>列出從第幾行開始的原始碼</td>
</tr>
<tr class="row-even"><td>list 函數名</td>
<td>列出某個函數的原始碼</td>
</tr>
<tr class="row-odd"><td>next（或n）</td>
<td>執行下一行語句</td>
</tr>
<tr class="row-even"><td>print（或p）</td>
<td>打印表達式的值，通過表達式可以修改變數的值或者調用函數</td>
</tr>
<tr class="row-odd"><td>quit（或q）</td>
<td>退出 <strong class="command">gdb</strong> 調試環境</td>
</tr>
<tr class="row-even"><td>set var</td>
<td>修改變數的值</td>
</tr>
<tr class="row-odd"><td>start</td>
<td>開始執行程序，停在 <tt class="docutils literal"><span class="pre">main</span></tt> 函數第一行語句前面等待命令</td>
</tr>
<tr class="row-even"><td>step（或s）</td>
<td>執行下一行語句，如果有函數調用則進入到函數中</td>
</tr>
</tbody>
</table>
<p class="rubric">習題</p>
<ol class="arabic simple">
<li>用 <strong class="command">gdb</strong> 一步一步跟蹤 <a class="reference internal" href="func2.html#func2-recurse"><em>遞歸</em></a> 講的 <tt class="docutils literal"><span class="pre">factorial</span></tt> 函數，對照着 <a class="reference internal" href="func2.html#func2-factorial"><em>factorial(3)的調用過程</em></a> 查看各層棧幀的變化情況，練習本節所學的各種 <strong class="command">gdb</strong> 命令。</li>
</ol>
</div>
<div class="section" id="gdb-breakpoint">
<span id="id4"></span><h2>10.2. 斷點<a class="headerlink" href="#gdb-breakpoint" title="Permalink to this headline">¶</a></h2>
<p>看以下程序：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">input</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

        <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                        <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;input=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>這個程序的作用是：首先從鍵盤讀入一串數字存到字元數組 <tt class="docutils literal"><span class="pre">input</span></tt> 中，然後轉換成整型存到 <tt class="docutils literal"><span class="pre">sum</span></tt> 中，然後打印出來，一直這樣循環下去。 <tt class="docutils literal"><span class="pre">scanf(&quot;%s&quot;,</span> <span class="pre">input);</span></tt> 這個調用的功能是等待用戶輸入一個字元串並回車， <tt class="docutils literal"><span class="pre">scanf</span></tt> 把其中第一段非空白（非空格、Tab、換行）的字元串保存到 <tt class="docutils literal"><span class="pre">input</span></tt> 數組中，並自動在末尾添加 <tt class="docutils literal"><span class="pre">'\0'</span></tt> 。接下來的循環從左到右掃瞄字元串並把每個數字累加到結果中，例如輸入是 <tt class="docutils literal"><span class="pre">&quot;2345&quot;</span></tt> ，則循環累加的過程是(((0×10+2)×10+3)×10+4)×10+5=2345。注意字元型的 <tt class="docutils literal"><span class="pre">'2'</span></tt> 要減去 <tt class="docutils literal"><span class="pre">'0'</span></tt> 的ASCII碼才能轉換成整數值2。下面編譯運行程序看看有什麼問題:</p>
<div class="highlight-python"><pre>$ gcc main.c -g -o main
$ ./main
123
input=123
234
input=123234
^C（按Ctrl-C退出程序）
$</pre>
</div>
<p>又是這種現象，第一次是對的，第二次就不對。可是這個程序我們並沒有忘了賦初值，不僅 <tt class="docutils literal"><span class="pre">sum</span></tt> 賦了初值，連不必賦初值的 <tt class="docutils literal"><span class="pre">i</span></tt> 都賦了初值。讀者先試試只看代碼能不能看出錯誤原因。下面來調試:</p>
<div class="highlight-python"><pre>$ gdb main
...
(gdb) start
Temporary breakpoint 1 at 0x804843d: file main.c, line 4.
Starting program: /home/akaedu/main

Temporary breakpoint 1, main () at main.c:4
4    {
(gdb) n
5            int sum = 0, i = 0;</pre>
</div>
<p>有了上一次的經驗， <tt class="docutils literal"><span class="pre">sum</span></tt> 被列為重點懷疑對象，我們可以用 <tt class="docutils literal"><span class="pre">display</span></tt> 命令使得每次停下來的時候都顯示當前 <tt class="docutils literal"><span class="pre">sum</span></tt> 的值，然後繼續往下走:</p>
<div class="highlight-python"><pre>(gdb) display sum
1: sum = 1466933
(gdb) n
9                    scanf("%s", input);
1: sum = 0
(gdb)
123
10                   for (i = 0; input[i] != '\0'; i++)
1: sum = 0</pre>
</div>
<p id="index-0"><tt class="docutils literal"><span class="pre">undisplay</span></tt> 命令可以取消跟蹤顯示，變數 <tt class="docutils literal"><span class="pre">sum</span></tt> 的編號是1，可以用 <tt class="docutils literal"><span class="pre">undisplay</span> <span class="pre">1</span></tt> 命令取消它的跟蹤顯示。這個循環應該沒有問題，因為上面第一次輸入時打印的結果是正確的。如果不想一步一步走這個循環，可以用 <tt class="docutils literal"><span class="pre">break</span></tt> 命令（簡寫為 <tt class="docutils literal"><span class="pre">b</span></tt> ）在第9行設一個斷點（Breakpoint）:</p>
<div class="highlight-python"><pre>(gdb) l
5            int sum = 0, i = 0;
6            char input[5];
7
8            while (1) {
9                    scanf("%s", input);
10                   for (i = 0; input[i] != '\0'; i++)
11                           sum = sum*10 + input[i] - '0';
12                   printf("input=%d\n", sum);
13           }
14           return 0;
(gdb) b 9
Breakpoint 2 at 0x8048459: file main.c, line 9.</pre>
</div>
<p><tt class="docutils literal"><span class="pre">break</span></tt> 命令的參數也可以是函數名，表示在某個函數開頭設斷點。現在用 <tt class="docutils literal"><span class="pre">continue</span></tt> 命令（簡寫為 <tt class="docutils literal"><span class="pre">c</span></tt> ）連續運行而非單步運行，程序到達斷點會自動停下來，這樣就可以停在下一次循環的開頭:</p>
<div class="highlight-python"><pre>(gdb) c
Continuing.
input=123

Breakpoint 2, main () at main.c:9
9                    scanf("%s", input);
1: sum = 123</pre>
</div>
<p>然後輸入新的字元串準備轉換:</p>
<div class="highlight-python"><pre>(gdb) n
234
10                   for (i = 0; input[i] != '\0'; i++)
1: sum = 123</pre>
</div>
<p>問題暴露出來了，新的轉換應該再次從0開始累加，而 <tt class="docutils literal"><span class="pre">sum</span></tt> 現在已經是123了，原因在於新的循環沒有把 <tt class="docutils literal"><span class="pre">sum</span></tt> 歸零。可見斷點有助于快速跳過沒有問題的代碼，然後在有問題的代碼上慢慢走慢慢分析，“斷點加單步”是使用調試器的基本方法。至于應該在哪裡設置斷點，怎麼知道哪些代碼可以跳過而哪些代碼要慢慢走，也要通過對錯誤現象的分析和假設來確定，以前我們用 <tt class="docutils literal"><span class="pre">printf</span></tt> 打印中間結果時也要分析應該在哪裡插入 <tt class="docutils literal"><span class="pre">printf</span></tt> ，打印哪些中間結果，調試的基本思路是一樣的。一次調試可以設置多個斷點，用 <tt class="docutils literal"><span class="pre">info</span></tt> 命令可以查看已經設置的斷點:</p>
<div class="highlight-python"><pre>(gdb) b 12
Breakpoint 3 at 0x80484b2: file main.c, line 12.
(gdb) i breakpoints
Num     Type           Disp Enb Address    What
2       breakpoint     keep y   0x08048459 in main at main.c:9
        breakpoint already hit 1 time
3       breakpoint     keep y   0x080484b2 in main at main.c:12</pre>
</div>
<p>每個斷點都有一個編號，可以用編號指定刪除某個斷點:</p>
<div class="highlight-python"><pre>(gdb) delete breakpoints 2
(gdb) i breakpoints
Num     Type           Disp Enb Address    What
3       breakpoint     keep y   0x080484b2 in main at main.c:12</pre>
</div>
<p>有時候一個斷點暫時不用可以禁用掉而不必刪除，這樣以後想用的時候可以直接啟用，而不必重新從代碼裡找應該在哪一行設斷點:</p>
<div class="highlight-python"><pre>(gdb) disable breakpoints 3
(gdb) i breakpoints
Num     Type           Disp Enb Address    What
3       breakpoint     keep n   0x080484b2 in main at main.c:12
(gdb) enable 3
(gdb) i breakpoints
Num     Type           Disp Enb Address    What
3       breakpoint     keep y   0x080484b2 in main at main.c:12
(gdb) delete  breakpoints
Delete all breakpoints? (y or n) y
(gdb) i breakpoints
No breakpoints or watchpoints.</pre>
</div>
<p><strong class="command">gdb</strong> 的斷點功能非常靈活，還可以設置斷點在滿足某個條件時才激活，例如我們仍然在循環開頭設置斷點，但是僅當 <tt class="docutils literal"><span class="pre">sum</span></tt> 不等於0時才中斷，然後用 <tt class="docutils literal"><span class="pre">run</span></tt> 命令（簡寫為 <tt class="docutils literal"><span class="pre">r</span></tt> ）重新從程序開頭連續運行:</p>
<div class="highlight-python"><pre>(gdb) break 9 if sum != 0
Breakpoint 4 at 0x8048459: file main.c, line 9.
(gdb) i breakpoints
Num     Type           Disp Enb Address    What
4       breakpoint     keep y   0x08048459 in main at main.c:9
        stop only if sum != 0
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/akaedu/main
123
input=123

Breakpoint 4, main () at main.c:9
9                    scanf("%s", input);
1: sum = 123</pre>
</div>
<p>結果是第一次執行 <tt class="docutils literal"><span class="pre">scanf</span></tt> 之前沒有中斷，第二次卻中斷了。總結一下本節用到的 <strong class="command">gdb</strong> 命令：</p>
<table border="1" class="docutils">
<caption>gdb基本命令2</caption>
<colgroup>
<col width="41%" />
<col width="59%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">命令</th>
<th class="head">描述</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>break（或b） 行號</td>
<td>在某一行設置斷點</td>
</tr>
<tr class="row-odd"><td>break 函數名</td>
<td>在某個函數開頭設置斷點</td>
</tr>
<tr class="row-even"><td>break ... if ...</td>
<td>設置條件斷點</td>
</tr>
<tr class="row-odd"><td>continue（或c）</td>
<td>從當前位置開始連續運行程序</td>
</tr>
<tr class="row-even"><td>delete breakpoints 斷點號</td>
<td>刪除斷點</td>
</tr>
<tr class="row-odd"><td>display 變數名</td>
<td>跟蹤查看某個變數，每次停下來都顯示它的值</td>
</tr>
<tr class="row-even"><td>disable breakpoints 斷點號</td>
<td>禁用斷點</td>
</tr>
<tr class="row-odd"><td>enable 斷點號</td>
<td>啟用斷點</td>
</tr>
<tr class="row-even"><td>info（或i） breakpoints</td>
<td>查看當前設置了哪些斷點</td>
</tr>
<tr class="row-odd"><td>run（或r）</td>
<td>從頭開始連續運行程序</td>
</tr>
<tr class="row-even"><td>undisplay 跟蹤顯示號</td>
<td>取消跟蹤顯示</td>
</tr>
</tbody>
</table>
<p class="rubric">習題</p>
<ol class="arabic">
<li><p class="first">看下面的程序：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;hello&quot;</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">reverse_str</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>

        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                <span class="n">reverse_str</span><span class="p">[</span><span class="mi">5</span><span class="o">-</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">str</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">reverse_str</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>首先用字元串 <tt class="docutils literal"><span class="pre">&quot;hello&quot;</span></tt> 初始化一個字元數組 <tt class="docutils literal"><span class="pre">str</span></tt> （算上 <tt class="docutils literal"><span class="pre">'\0'</span></tt> 共6個字元）。然後用空字元串 <tt class="docutils literal"><span class="pre">&quot;&quot;</span></tt> 初始化一個同樣長的字元數組 <tt class="docutils literal"><span class="pre">reverse_str</span></tt> ，相當於所有元素用 <tt class="docutils literal"><span class="pre">'\0'</span></tt> 初始化。然後打印 <tt class="docutils literal"><span class="pre">str</span></tt> ，把 <tt class="docutils literal"><span class="pre">str</span></tt> 倒序存入 <tt class="docutils literal"><span class="pre">reverse_str</span></tt> ，再打印 <tt class="docutils literal"><span class="pre">reverse_str</span></tt> 。然而結果並不正確:</p>
<div class="highlight-python"><pre>$ ./main
hello</pre>
</div>
<p>我們本來希望 <tt class="docutils literal"><span class="pre">reverse_str</span></tt> 打印出來是 <tt class="docutils literal"><span class="pre">olleh</span></tt> ，結果打出來一個空行。重點懷疑對象肯定是循環，那麼簡單驗算一下， <tt class="docutils literal"><span class="pre">i=0</span></tt> 時， <tt class="docutils literal"><span class="pre">reverse_str[5]=str[0]</span></tt> ，也就是 <tt class="docutils literal"><span class="pre">'h'</span></tt> ， <tt class="docutils literal"><span class="pre">i=1</span></tt> 時， <tt class="docutils literal"><span class="pre">reverse_str[4]=str[1]</span></tt> ，也就是 <tt class="docutils literal"><span class="pre">'e'</span></tt> ，依此類推，i=0,1,2,3,4，共5次循環，正好把h,e,l,l,o五個字母給倒過來了，哪裡不對了？請用 <strong class="command">gdb</strong> 跟蹤循環，找出錯誤原因並改正。</p>
</li>
</ol>
</div>
<div class="section" id="id5">
<h2>10.3. 觀察點<a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>繼續修改上一節的程序。經過調試我們得出結論，對於這個程序來說， <tt class="docutils literal"><span class="pre">sum</span></tt> 賦不賦初值不重要，重要的是在 <tt class="docutils literal"><span class="pre">while</span> <span class="pre">(1)</span></tt> 循環體的開頭加上 <tt class="docutils literal"><span class="pre">sum</span> <span class="pre">=</span> <span class="pre">0;</span></tt> ，這才能保證每次循環從0開始累加。我們把程序改成這樣：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span><span class="p">;</span>
<span class="kt">char</span> <span class="n">input</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
                <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
                <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
                        <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;input=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>在這裡我故意把 <tt class="docutils literal"><span class="pre">sum</span></tt> 、 <tt class="docutils literal"><span class="pre">i</span></tt> 、 <tt class="docutils literal"><span class="pre">input</span></tt> 定義成全局變數， <tt class="docutils literal"><span class="pre">sum</span></tt> 賦初值而 <tt class="docutils literal"><span class="pre">i</span></tt> 和 <tt class="docutils literal"><span class="pre">input</span></tt> 不賦初值，這是為了比較容易產生本節要講的錯誤現象。還是那句話，如果你的運行環境和我不同，在你機器上可能跑不出書上說的結果。你可以先看書，在理解了基本原理之後自己改改程序看能不能跑出類似的結果：變數定義在全局還是局部作用域，在定義時是否初賦了初值，這些都會影響變數所占的存儲空間的位置，從而影響本程序的運行結果。</p>
<p>使用 <tt class="docutils literal"><span class="pre">scanf</span></tt> 函數是非常凶險的，即使修正了上一節的Bug也還存在很多問題。如果輸入的字元串超長了會怎麼樣？我們知道數組訪問越界是不會被檢查的，所以 <tt class="docutils literal"><span class="pre">scanf</span></tt> 會把 <tt class="docutils literal"><span class="pre">input</span></tt> 數組寫越界。現象是這樣的:</p>
<div class="highlight-python"><pre>$ ./main
1234
input=1234
1234567
input=1234567
12345678
input=123456740</pre>
</div>
<p>輸入1234567其實已經訪問越界了，但程序還能給出正確結果。而輸入12345678時程序給出一個非常詭異的結果，下面我們用調試器看看這個詭異的結果是怎麼出來的:</p>
<div class="highlight-python"><pre>$ gdb main
...
(gdb) start
Temporary breakpoint 1 at 0x804843d: file main.c, line 9.
Starting program: /home/akaedu/main

Temporary breakpoint 1, main () at main.c:9
9                    sum = 0;
(gdb) n
10                   scanf("%s", input);
(gdb) （直接回車）
12345678
11                   for (i = 0; input[i] != '\0'; i++)
(gdb) p input
$1 = "12345"</pre>
</div>
<p>在這裡 <strong class="command">gdb</strong> 知道 <tt class="docutils literal"><span class="pre">input</span></tt> 數組的長度是5，所以用 <tt class="docutils literal"><span class="pre">p</span></tt> 命令查看時只顯示5個字元。我們換一種辦法查看就可以看到其實已經寫越界了:</p>
<div class="highlight-python"><pre>(gdb) p printf("%x %x %x %x %x %x %x %x %x\n", input[0], input[1], input[2], input[3], input[4], input[5], input[6], input[7], input[8])
31 32 33 34 35 36 37 38 0
$2 = 26</pre>
</div>
<p>這條命令從 <tt class="docutils literal"><span class="pre">input</span></tt> 數組的第一個位元組開始連續打印9個位元組，打印的正是 <tt class="docutils literal"><span class="pre">'1'</span></tt> 到 <tt class="docutils literal"><span class="pre">'8'</span></tt> 的十六進制ASCII碼，還有一個 <tt class="docutils literal"><span class="pre">'\0'</span></tt> ，所以 <tt class="docutils literal"><span class="pre">scanf</span></tt> 實際上寫越界了四個字元：``&#8216;6&#8217;`` 、 <tt class="docutils literal"><span class="pre">'7'</span></tt> 、 <tt class="docutils literal"><span class="pre">'8'</span></tt> 、 <tt class="docutils literal"><span class="pre">'\0'</span></tt> 。 <tt class="docutils literal"><span class="pre">printf</span></tt> 的轉換說明 <tt class="docutils literal"><span class="pre">%x</span></tt> 表示按16進制打印。</p>
<p>根據運行結果“123456740”，用戶輸入的前7個字元轉成數字都沒錯，第8個錯了，也就是 <tt class="docutils literal"><span class="pre">i</span></tt> 從0到6的循環都沒錯，我們設一個條件斷點從 <tt class="docutils literal"><span class="pre">i</span></tt> 等於7開始單步調試:</p>
<div class="highlight-python"><pre>(gdb) l
6    int main(void)
7    {
8            while (1) {
9                    sum = 0;
10                   scanf("%s", input);
11                   for (i = 0; input[i] != '\0'; i++)
12                           sum = sum*10 + input[i] - '0';
13                   printf("input=%d\n", sum);
14           }
15           return 0;
(gdb) b 12 if i == 7
Breakpoint 2 at 0x8048468: file main.c, line 12.
(gdb) c
Continuing.

Breakpoint 2, main () at main.c:12
12                           sum = sum*10 + input[i] - '0';
(gdb) p sum
$3 = 1234567</pre>
</div>
<p>現在 <tt class="docutils literal"><span class="pre">sum</span></tt> 是1234567沒錯，我們推測即將進行的下一步計算肯定要出錯，調試的結果出乎意料，下一步計算並沒有出錯:</p>
<div class="highlight-python"><pre>(gdb) p input[i]
$4 = 56 '8'
(gdb) n
11                   for (i = 0; input[i] != '\0'; i++)
(gdb) p sum
$5 = 12345678</pre>
</div>
<p><tt class="docutils literal"><span class="pre">input[i]</span></tt> 是 <tt class="docutils literal"><span class="pre">'8'</span></tt> ，減去 <tt class="docutils literal"><span class="pre">'0'</span></tt> 等於8，把 <tt class="docutils literal"><span class="pre">sum</span></tt> 的當前值1234567乘以10再加上8，確實得到了12345678。那為什麼打印的結果卻不是這一步算出的12345678呢？只有一個解釋：這一步計算之後並沒有跳出循環去執行 <tt class="docutils literal"><span class="pre">printf</span></tt> ，而是繼續下一輪循環:</p>
<div class="highlight-python"><pre>(gdb) n
12                           sum = sum*10 + input[i] - '0';
(gdb) p i
$6 = 8
(gdb) p input[i]
$7 = 8 '\b'
(gdb) n
11                   for (i = 0; input[i] != '\0'; i++)
(gdb) p sum
$8 = 123456740
(gdb) n
13                   printf("input=%d\n", sum);
(gdb) p i
$9 = 9
(gdb) p input[9]
$10 = 0 '\000'</pre>
</div>
<p>先前我們明明打印出 <tt class="docutils literal"><span class="pre">input[8]</span></tt> 是 <tt class="docutils literal"><span class="pre">'\0'</span></tt> ，什麼時候變成 <tt class="docutils literal"><span class="pre">'\b'</span></tt> 的呢？這一變，循環的控制條件 <tt class="docutils literal"><span class="pre">input[8]</span> <span class="pre">!=</span> <span class="pre">'\0'</span></tt> 又得到滿足了，原本應該跳出循環的，現在又進循環了，把sum累加成了12345678*10 + &#8216;b&#8217; - &#8216;0&#8217; = 123456740 （ <tt class="docutils literal"><span class="pre">'\b'</span></tt> 的ASCII碼是8， <tt class="docutils literal"><span class="pre">'0'</span></tt> 的ASCII碼是48）。然後 <tt class="docutils literal"><span class="pre">input[9]</span></tt> 確實是0，跳出循環，打印，終於得出了那個詭異的結果！</p>
<p>現在我們要弄清楚 <tt class="docutils literal"><span class="pre">input[8]</span></tt> 到底是什麼時候變的，可以用觀察點（Watchpoint）來跟蹤。我們知道斷點是當程序執行到某一代碼行時中斷，而觀察點是當程序訪問某個存儲單元時中斷。如果我們不知道某個存儲單元是被哪一行代碼改動的，觀察點就非常有用了。下面刪除原來設的斷點，從頭執行程序，重複上次的輸入，用 <tt class="docutils literal"><span class="pre">watch</span></tt> 命令設置觀察點，跟蹤 <tt class="docutils literal"><span class="pre">input[8]</span></tt> 的存儲單元:</p>
<div class="highlight-python"><pre>(gdb) delete breakpoints
Delete all breakpoints? (y or n) y
(gdb) start
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Temporary breakpoint 3 at 0x804843d: file main.c, line 9.
Starting program: /home/akaedu/main

Temporary breakpoint 3, main () at main.c:9
9                    sum = 0;
(gdb) n
10                   scanf("%s", input);
(gdb) （直接回車）
12345678
11                   for (i = 0; input[i] != '\0'; i++)
(gdb) watch input[8]
Hardware watchpoint 4: input[8]
(gdb) i watchpoints
Num     Type           Disp Enb Address    What
4       hw watchpoint  keep y              input[8]
(gdb) c
Continuing.
Hardware watchpoint 4: input[8]

Old value = 0 '\000'
New value = 1 '\001'
0x0804849f in main () at main.c:11
11                   for (i = 0; input[i] != '\0'; i++)
(gdb) c
Continuing.
Hardware watchpoint 4: input[8]

Old value = 1 '\001'
New value = 2 '\002'
0x0804849f in main () at main.c:11
11                   for (i = 0; input[i] != '\0'; i++)</pre>
</div>
<p>已經很明顯了，每次都是回到 <tt class="docutils literal"><span class="pre">for</span></tt> 循環開頭的時候改變了 <tt class="docutils literal"><span class="pre">input[8]</span></tt> 的值，而且是每次加1－－這不就是循環變數 <tt class="docutils literal"><span class="pre">i</span></tt> 麼？原來循環變數 <tt class="docutils literal"><span class="pre">i</span></tt> 就位於 <tt class="docutils literal"><span class="pre">input[8]</span></tt> 的位置。 <tt class="docutils literal"><span class="pre">input[5]</span></tt> 、 <tt class="docutils literal"><span class="pre">input[6]</span></tt> 、 <tt class="docutils literal"><span class="pre">input[7]</span></tt> 雖然也是訪問越界，但還不算嚴重，反正也沒有別的變數占用這塊存儲空間，而 <tt class="docutils literal"><span class="pre">input[8]</span></tt> 這個訪問越界就嚴重了，直接訪問到變數 <tt class="docutils literal"><span class="pre">i</span></tt> 的頭上了。其實用 <tt class="docutils literal"><span class="pre">x</span></tt> 命令可以清楚地看到這一點，只不過為了防止“劇透”我一開始沒有這麼做:</p>
<div class="highlight-python"><pre>(gdb) x/12bx input
0x804a024 &lt;input&gt;:   0x31    0x32    0x33    0x34    0x35    0x36    0x37    0x38
0x804a02c &lt;i&gt;:       0x02    0x00    0x00    0x00</pre>
</div>
<p><tt class="docutils literal"><span class="pre">x</span></tt> 命令打印指定的存儲單元裡保存的內容，尾碼 <tt class="docutils literal"><span class="pre">8bx</span></tt> 是打印格式，12表示打印12組，b表示每個位元組一組，x表示按十六進制格式打印 <a class="footnote-reference" href="#id7" id="id6">[2]</a> ，我們可以看到在 <tt class="docutils literal"><span class="pre">input</span></tt> 的存儲單元的起始位置加8個位元組處正是變數 <tt class="docutils literal"><span class="pre">i</span></tt> 的存儲單元。</p>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[2]</a></td><td>打印結果最左邊的一長串數字是內存地址，在 <a class="reference internal" href="arch.html#arch-memaddr"><em>內存與地址</em></a> 詳細解釋，目前可以無視。</td></tr>
</tbody>
</table>
<p>修正這個Bug對初學者來說有一定難度。如果你發現了這個Bug卻沒想到數組訪問越界這一點，也許一時想不出原因，就會先去處理另外一個更容易修正的Bug：如果輸入的不是數字而是字母或別的符號也能算出結果來，這顯然是不對的，可以在循環中加上判斷條件檢查非法字元。</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="sc">&#39;0&#39;</span> <span class="o">||</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Invalid input!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                        <span class="n">sum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;input=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>然後你會驚喜地發現，不僅輸入字母會報錯，輸入超長也會報錯:</p>
<div class="highlight-python"><pre>$ ./main
123a
Invalid input!
input=-1
dead
Invalid input!
input=-1
1234578
Invalid input!
input=-1
1234567890abcdef
Invalid input!
input=-1
23
input=23</pre>
</div>
<p>似乎是兩個Bug一起解決掉了，但這是治標不治本的解決方法。看起來輸入超長的錯誤是不出現了，但只要沒有找到根本原因就不可能真的解決掉，等到條件一變，它可能又冒出來了，在下一節你會看到它又以一種新的形式冒出來了。現在請思考一下為什麼加上檢查非法字元的代碼之後輸入超長也會報錯。</p>
<p>最後總結一下本節用到的 <strong class="command">gdb</strong> 命令：</p>
<table border="1" class="docutils">
<caption>gdb基本命令3</caption>
<colgroup>
<col width="25%" />
<col width="75%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">命令</th>
<th class="head">描述</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>watch</td>
<td>設置觀察點</td>
</tr>
<tr class="row-odd"><td>info（或i） watchpoints</td>
<td>查看當前設置了哪些觀察點</td>
</tr>
<tr class="row-even"><td>x</td>
<td>從某個位置開始打印存儲單元的內容，全部當成位元組來看，而不區分哪個位元組屬於哪個變數</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="gdb-segfault">
<span id="id8"></span><h2>10.4. 程序崩潰<a class="headerlink" href="#gdb-segfault" title="Permalink to this headline">¶</a></h2>
<p>如果程序運行時出現段錯誤，用 <strong class="command">gdb</strong> 可以很容易定位到究竟是哪一行引發的段錯誤，例如這個小程序：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7
8</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">man</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="n">man</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>調試過程如下:</p>
<div class="highlight-python"><pre>$ gdb main
...

(gdb) r
Starting program: /home/akaedu/main
123

Program received signal SIGSEGV, Segmentation fault.
0x00180a93 in _IO_vfscanf () from /lib/i386-linux-gnu/libc.so.6
(gdb) bt
#0  0x00180a93 in _IO_vfscanf () from /lib/i386-linux-gnu/libc.so.6
#1  0x0018747b in __isoc99_scanf () from /lib/i386-linux-gnu/libc.so.6
#2  0x0804842a in main () at main.c:6</pre>
</div>
<p>在 <strong class="command">gdb</strong> 中運行，遇到段錯誤會自動停下來，這時可以用命令查看當前執行到哪一行代碼了。 <strong class="command">gdb</strong> 顯示段錯誤出現在 <tt class="docutils literal"><span class="pre">_IO_vfscanf</span></tt> 函數中，用 <tt class="docutils literal"><span class="pre">bt</span></tt> 命令可以看到這個函數是被 <tt class="docutils literal"><span class="pre">main.c</span></tt> 的第6行間接調用的，也就是 <tt class="docutils literal"><span class="pre">scanf</span></tt> 這行代碼引發的段錯誤。仔細觀察程序發現是 <tt class="docutils literal"><span class="pre">man</span></tt> 前面少了個&amp;。</p>
<p>繼續調試上一節的程序，上一節最後提出修正Bug的方法是在循環中加上判斷條件，如果不是數字就報錯退出，結果是不僅輸入非法字元可以報錯退出，輸入超長的字元串也會報錯退出。表面上看這個程序無論怎麼運行都不出錯了，但假如我們把 <tt class="docutils literal"><span class="pre">while</span> <span class="pre">(1)</span></tt> 循環去掉，每次執行程序只轉換一個數：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">input</span><span class="p">[</span><span class="mi">5</span><span class="p">];</span>

        <span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">input</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="sc">&#39;0&#39;</span> <span class="o">||</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="sc">&#39;9&#39;</span><span class="p">)</span> <span class="p">{</span>
                        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Invalid input!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
                        <span class="n">sum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
                <span class="n">sum</span> <span class="o">=</span> <span class="n">sum</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="n">input</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;input=%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">sum</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>然後輸入一個超長的字元串，看看會發生什麼:</p>
<div class="highlight-python"><pre>$ ./main
12345678
input=12345678
*** stack smashing detected ***: ./main terminated
======= Backtrace: =========
/lib/i386-linux-gnu/libc.so.6(__fortify_fail+0x45)[0xf4cdd5]
/lib/i386-linux-gnu/libc.so.6(+0xffd8a)[0xf4cd8a]
./main[0x8048592]
/lib/i386-linux-gnu/libc.so.6(__libc_start_main+0xf3)[0xe664d3]
./main[0x8048421]
======= Memory map: ========
00138000-00158000 r-xp 00000000 08:01 394133     /lib/i386-linux-gnu/ld-2.15.so
00158000-00159000 r--p 0001f000 08:01 394133     /lib/i386-linux-gnu/ld-2.15.so
00159000-0015a000 rw-p 00020000 08:01 394133     /lib/i386-linux-gnu/ld-2.15.so
00c97000-00c98000 r-xp 00000000 00:00 0          [vdso]
00e0f000-00e2b000 r-xp 00000000 08:01 394174     /lib/i386-linux-gnu/libgcc_s.so.1
00e2b000-00e2c000 r--p 0001b000 08:01 394174     /lib/i386-linux-gnu/libgcc_s.so.1
00e2c000-00e2d000 rw-p 0001c000 08:01 394174     /lib/i386-linux-gnu/libgcc_s.so.1
00e4d000-00fec000 r-xp 00000000 08:01 394153     /lib/i386-linux-gnu/libc-2.15.so
00fec000-00fee000 r--p 0019f000 08:01 394153     /lib/i386-linux-gnu/libc-2.15.so
00fee000-00fef000 rw-p 001a1000 08:01 394153     /lib/i386-linux-gnu/libc-2.15.so
00fef000-00ff2000 rw-p 00000000 00:00 0
08048000-08049000 r-xp 00000000 08:01 439349     /home/akaedu/main
08049000-0804a000 r--p 00000000 08:01 439349     /home/akaedu/main
0804a000-0804b000 rw-p 00001000 08:01 439349     /home/akaedu/main
09c65000-09c86000 rw-p 00000000 00:00 0          [heap]
b7780000-b7781000 rw-p 00000000 00:00 0
b778e000-b7793000 rw-p 00000000 00:00 0
bfb0c000-bfb2d000 rw-p 00000000 00:00 0          [stack]
Aborted (core dumped)</pre>
</div>
<p>我們輸入12345678，計算結果12345678都打印完了，卻在最後爆出整整一屏錯誤信息。準確地說這是另外一種形式的程序崩潰而不是段錯誤，不過我們可以按同樣的方法用 <strong class="command">gdb</strong> 調試看看:</p>
<div class="highlight-python"><pre>$ gdb main
...
(gdb) r
Starting program: /home/akaedu/main
12345678
input=12345678
*** stack smashing detected ***: /home/akaedu/main terminated
======= Backtrace: =========
/lib/i386-linux-gnu/libc.so.6(__fortify_fail+0x45)[0x232dd5]
/lib/i386-linux-gnu/libc.so.6(+0xffd8a)[0x232d8a]
/home/akaedu/main[0x8048592]
/lib/i386-linux-gnu/libc.so.6(__libc_start_main+0xf3)[0x14c4d3]
/home/akaedu/main[0x8048421]
======= Memory map: ========
00110000-00130000 r-xp 00000000 08:01 394133     /lib/i386-linux-gnu/ld-2.15.so
00130000-00131000 r--p 0001f000 08:01 394133     /lib/i386-linux-gnu/ld-2.15.so
00131000-00132000 rw-p 00020000 08:01 394133     /lib/i386-linux-gnu/ld-2.15.so
00132000-00133000 r-xp 00000000 00:00 0          [vdso]
00133000-002d2000 r-xp 00000000 08:01 394153     /lib/i386-linux-gnu/libc-2.15.so
002d2000-002d4000 r--p 0019f000 08:01 394153     /lib/i386-linux-gnu/libc-2.15.so
002d4000-002d5000 rw-p 001a1000 08:01 394153     /lib/i386-linux-gnu/libc-2.15.so
002d5000-002d8000 rw-p 00000000 00:00 0
002d8000-002f4000 r-xp 00000000 08:01 394174     /lib/i386-linux-gnu/libgcc_s.so.1
002f4000-002f5000 r--p 0001b000 08:01 394174     /lib/i386-linux-gnu/libgcc_s.so.1
002f5000-002f6000 rw-p 0001c000 08:01 394174     /lib/i386-linux-gnu/libgcc_s.so.1
08048000-08049000 r-xp 00000000 08:01 439349     /home/akaedu/main
08049000-0804a000 r--p 00000000 08:01 439349     /home/akaedu/main
0804a000-0804b000 rw-p 00001000 08:01 439349     /home/akaedu/main
0804b000-0806c000 rw-p 00000000 00:00 0          [heap]
b7fed000-b7fee000 rw-p 00000000 00:00 0
b7ffb000-b8000000 rw-p 00000000 00:00 0
bffdf000-c0000000 rw-p 00000000 00:00 0          [stack]

Program received signal SIGABRT, Aborted.
0x00132416 in __kernel_vsyscall ()
(gdb) bt
#0  0x00132416 in __kernel_vsyscall ()
#1  0x001611ef in raise () from /lib/i386-linux-gnu/libc.so.6
#2  0x00164835 in abort () from /lib/i386-linux-gnu/libc.so.6
#3  0x0019c2fa in ?? () from /lib/i386-linux-gnu/libc.so.6
#4  0x00232dd5 in __fortify_fail () from /lib/i386-linux-gnu/libc.so.6
#5  0x00232d8a in __stack_chk_fail () from /lib/i386-linux-gnu/libc.so.6
#6  0x08048592 in main () at main.c:20</pre>
</div>
<p><strong class="command">gdb</strong> 指出，錯誤發生在第20行。可是這一行什麼都沒有啊，只有表示 <tt class="docutils literal"><span class="pre">main</span></tt> 函數結束的}括號。這可以算是一條規律， <strong>如果某個函數的局部變數發生訪問越界，有可能並不立即產生段錯誤，而是在函數返回時產生段錯誤</strong> 。</p>
<p>想要寫出Bug-free的程序是非常不容易的，即使 <tt class="docutils literal"><span class="pre">scanf</span></tt> 讀入字元串這麼一個簡單的函數調用都會隱藏着各種各樣的錯誤。有些錯誤現象是我們暫時沒法解釋的，在後續章節中都會解釋清楚。其實現在講 <tt class="docutils literal"><span class="pre">scanf</span></tt> 這個函數為時過早，讀者還不具備充足的基礎知識，而且這個函數的用法也確實是相當複雜，要用得準確無誤是挺難的，本書將在 <a class="reference internal" href="stdlib.html#stdlib-formattedio"><em>格式化I/O函數</em></a> 詳細解釋這個函數。現在早早地引入這個函數是為了讓讀者可以早早地開始寫有用的程序，畢竟，一個只能輸出（ <tt class="docutils literal"><span class="pre">printf</span></tt> ）而不能輸入（ <tt class="docutils literal"><span class="pre">scanf</span></tt> ）的程序算不上什麼有用的程序。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">10. gdb</a><ul>
<li><a class="reference internal" href="#id1">10.1. 單步執行和跟蹤函數調用</a></li>
<li><a class="reference internal" href="#gdb-breakpoint">10.2. 斷點</a></li>
<li><a class="reference internal" href="#id5">10.3. 觀察點</a></li>
<li><a class="reference internal" href="#gdb-segfault">10.4. 程序崩潰</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="codingstyle.html"
                        title="previous chapter">9. 編碼風格</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="sortsearch.html"
                        title="next chapter">11. 排序與查找</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/zh/gdb.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><table border=0 cellspacing=0 style="color: white;">

<tr><td>
   請輸入您的email訂閲<a href="http://groups.google.com/group/learning-linux-c-cpp">本書的郵件列表</a><br/>
   (Please enter your email to subscribe to <a href="http://groups.google.com/group/learning-linux-c-cpp">this book's mailing list</a>)<br/>
   <form action="http://groups.google.com/group/learning-linux-c-cpp/boxsubscribe"><input type=text name=email><input type=submit name="sub" value="訂閲(Subscribe)"></form>
</td></tr>

<tr><td><br/>關注<a href="http://weibo.com/sansoong">我的微博</a></td></tr>

<tr><td><br/>Checkout the source from github: <a href="https://github.com/learning-linux-c-cpp/akabook">https://github.com/learning-linux-c-cpp/akabook</a></td></tr>

<tr><td>
   <br/>感謝您的慷慨捐贈！<br/>
   Thanks for your generous donation!<br/>
   <a href="http://me.alipay.com/songjinshan" target="_blank"><img src="_static/me.alipay.png" alt="捐贈"></a>
</td></tr>

</table>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="sortsearch.html" title="11. 排序與查找"
             >next</a> |</li>
        <li class="right" >
          <a href="codingstyle.html" title="9. 編碼風格"
             >previous</a> |</li>
        <li><a href="../index.html">akabook 3.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >中文版：Linux C/C++編程一站式學習</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Sean Soong.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>