

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>9. 編碼風格 &mdash; akabook 3.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="akabook 3.0 documentation" href="../index.html" />
    <link rel="up" title="中文版：Linux C/C++編程一站式學習" href="index.html" />
    <link rel="next" title="10. gdb" href="gdb.html" />
    <link rel="prev" title="8. 數組" href="array.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="gdb.html" title="10. gdb"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="array.html" title="8. 數組"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">akabook 3.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">中文版：Linux C/C++編程一站式學習</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>9. 編碼風格<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>代碼風格好不好就像字寫得好不好看一樣，如果一個公司招聘秘書，肯定不要字寫得難看的，同理，代碼風格糟糕的程序員肯定也是不稱職的。雖然編譯器不會挑剔難看的代碼，照樣能編譯通過，但是和你一個Team的其他程序員肯定受不了，你自己也受不了，寫完代碼幾天之後再來看，自己都不知道自己寫的是什麼。 <a class="reference internal" href="bibli.html#sicp">[SICP]</a> 的第一版前言裡有句話說得好：“Thus, programs must be written for people to read, and only incidentally for machines to execute.”代碼主要是為了寫給人看的，而不是寫給機器看的，只是順便也能用機器執行而已，如果是為了寫給機器看那直接寫機器指令就好了，沒必要用高級語言了。代碼和語言文字一樣是為了表達思想、記載信息，所以一定要寫得清楚整潔才能有效地表達。</p>
<p>在一個軟件項目中，代碼風格一般都用文檔規定死了，所有參與項目的人不管他自己原來是什麼風格，都要遵守統一的風格，例如Linux內核的 <a class="reference internal" href="bibli.html#codingstyle">[CodingStyle]</a> 就是這樣一個文檔。本章我們以內核的代碼風格為基礎來講解好的編碼風格都有哪些規定，這些規定的Rationale是什麼。我只是以Linux內核為例來講解編碼風格的概念，並沒有說內核編碼風格就一定是最好的編碼風格，但Linux內核項目如此成功，就足以說明它的編碼風格是最好的C語言編碼風格之一了。</p>
<div class="section" id="codingstyle-indent">
<span id="id4"></span><h2>9.1. 縮進和空白<a class="headerlink" href="#codingstyle-indent" title="Permalink to this headline">¶</a></h2>
<p>我們知道C語言的語法對縮進和空白沒有要求，空格、Tab、換行都可以隨意寫，實現同樣功能的代碼可以寫得很好看，也可以寫得很難看。例如 <a class="reference internal" href="array.html#array-multidim"><em>多維數組</em></a> 的“剪刀石頭布”代碼如果寫成這樣就很難看了：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;time.h&gt;</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="kt">char</span> <span class="n">gesture</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="mi">10</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="s">&quot;scissor&quot;</span><span class="p">,</span><span class="s">&quot;stone&quot;</span><span class="p">,</span><span class="s">&quot;cloth&quot;</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">man</span><span class="p">,</span><span class="n">computer</span><span class="p">,</span><span class="n">result</span><span class="p">,</span> <span class="n">ret</span><span class="p">;</span>
<span class="n">srand</span><span class="p">(</span><span class="n">time</span><span class="p">(</span><span class="nb">NULL</span><span class="p">));</span>
<span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">){</span>
<span class="n">computer</span><span class="o">=</span><span class="n">rand</span><span class="p">()</span><span class="o">%</span><span class="mi">3</span><span class="p">;</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">Input your gesture (0-scissor 1-stone 2-cloth):</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="n">ret</span><span class="o">=</span><span class="n">scanf</span><span class="p">(</span><span class="s">&quot;%d&quot;</span><span class="p">,</span><span class="o">&amp;</span><span class="n">man</span><span class="p">);</span>
<span class="k">if</span><span class="p">(</span><span class="n">ret</span><span class="o">!=</span><span class="mi">1</span><span class="o">||</span><span class="n">man</span><span class="o">&lt;</span><span class="mi">0</span><span class="o">||</span><span class="n">man</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">){</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;Invalid input!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
<span class="n">printf</span><span class="p">(</span><span class="s">&quot;You: %s</span><span class="se">\t</span><span class="s">Computer: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">gesture</span><span class="p">[</span><span class="n">man</span><span class="p">],</span><span class="n">gesture</span><span class="p">[</span><span class="n">computer</span><span class="p">]);</span>
<span class="n">result</span><span class="o">=</span><span class="p">(</span><span class="n">man</span><span class="o">-</span><span class="n">computer</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span><span class="o">%</span><span class="mi">3</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;You win!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="k">else</span> <span class="k">if</span><span class="p">(</span><span class="n">result</span><span class="o">==</span><span class="mi">0</span><span class="p">)</span><span class="n">printf</span><span class="p">(</span><span class="s">&quot;Draw!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="k">else</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;You lose!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="p">}</span>
<span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>一是缺少空白字元，代碼密度太大，看著很費勁。二是沒有縮進，看不出來哪個{和哪個}配對，像這麼短的代碼還能湊合著看，如果代碼超過一屏就完全沒法看了。 <a class="reference internal" href="bibli.html#codingstyle">[CodingStyle]</a> 中關於空白字元並沒有特別規定，因為基本上所有的C代碼風格對於空白字元的規定都差不多，主要有以下幾條。</p>
<ol class="arabic">
<li><p class="first">關鍵字 <tt class="docutils literal"><span class="pre">if</span></tt> 、 <tt class="docutils literal"><span class="pre">while</span></tt> 、 <tt class="docutils literal"><span class="pre">for</span></tt> 與其後的控製表達式的(括號之間插入一個空格分隔，但括號內的表達式應緊貼括號。例如：</p>
<div class="highlight-c"><pre>while␣(1);</pre>
</div>
</li>
<li><p class="first">雙目運算符的兩側各插入一個空格分隔，單目運算符和操作數之間不加空格，例如 <tt class="docutils literal"><span class="pre">i␣=␣i␣+␣1</span></tt> 、 <tt class="docutils literal"><span class="pre">++i</span></tt> 、 <tt class="docutils literal"><span class="pre">!(i␣&lt;␣1)</span></tt> 、 <tt class="docutils literal"><span class="pre">-x</span></tt> 、 <tt class="docutils literal"><span class="pre">&amp;a</span></tt> 等。</p>
</li>
<li><p class="first">尾碼運算符和操作數之間也不加空格，例如取結構體成員 <tt class="docutils literal"><span class="pre">s.a</span></tt> 、函數調用 <tt class="docutils literal"><span class="pre">foo(arg1)</span></tt> 、取數組成員 <tt class="docutils literal"><span class="pre">a[i]</span></tt> 。</p>
</li>
<li><p class="first">,號和;號之後要加空格，這是英文的書寫習慣，例如 <tt class="docutils literal"><span class="pre">for␣(i␣=␣1;␣i␣&lt;␣10;␣i++)</span></tt> 、 <tt class="docutils literal"><span class="pre">foo(arg1,␣arg2)</span></tt> 。</p>
</li>
<li><p class="first">以上關於加空格的規則並沒有嚴格要求，有時為了突出優先順序也可以寫得更緊湊一些，例如 <tt class="docutils literal"><span class="pre">for␣(i=1;␣i&lt;10;␣i++)</span></tt> 、 <tt class="docutils literal"><span class="pre">distance␣=␣sqrt(x*x␣+␣y*y)</span></tt> 等。但是省略的空格一定不要誤導了讀代碼的人，例如 <tt class="docutils literal"><span class="pre">a||b␣&amp;&amp;␣c</span></tt> 很容易讓人理解成錯誤的優先順序。</p>
</li>
<li><p class="first">由於UNIX系統標準的字元終端是24行80列的，接近或大於80個字元的較長語句或聲明要折行寫，折行後用空格和上面的表達式或參數對齊，例如：</p>
<div class="highlight-c"><pre>if␣(sqrt(x*x␣+␣y*y)␣&gt;␣5.0
    &amp;&amp;␣x␣&lt;␣0.0
    &amp;&amp;␣y␣&gt;␣0.0)</pre>
</div>
<p>再比如：</p>
<div class="highlight-c"><pre>foo(sqrt(x*x␣+␣y*y),
    a[i-1]␣+␣b[i-1]␣+␣c[i-1])</pre>
</div>
</li>
<li><p class="first">較長的字元串可以斷成多個字元串然後分行書寫，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">printf</span><span class="p">(</span><span class="s">&quot;This is such a long sentence that &quot;</span>
       <span class="s">&quot;it cannot be held within a line</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>C編譯器會自動把相鄰的多個字元串接在一起，以上兩個字元串相當於一個字元串 <tt class="docutils literal"><span class="pre">&quot;This</span> <span class="pre">is</span> <span class="pre">such</span> <span class="pre">a</span> <span class="pre">long</span> <span class="pre">sentence</span> <span class="pre">that</span> <span class="pre">it</span> <span class="pre">cannot</span> <span class="pre">be</span> <span class="pre">held</span> <span class="pre">within</span> <span class="pre">a</span> <span class="pre">line\n&quot;</span></tt> 。注意這個語法有時候會帶來一點麻煩，比如下面這段代碼在語法上沒有問題，但在語義上有問題，你能看出是什麼問題嗎？</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">char</span> <span class="n">days</span><span class="p">[</span><span class="mi">8</span><span class="p">][</span><span class="mi">20</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="s">&quot;Monday&quot;</span><span class="p">,</span> <span class="s">&quot;Tuesday&quot;</span>
                     <span class="s">&quot;Wednesday&quot;</span><span class="p">,</span> <span class="s">&quot;Thursday&quot;</span><span class="p">,</span> <span class="s">&quot;Friday&quot;</span>
                     <span class="s">&quot;Saturday&quot;</span><span class="p">,</span> <span class="s">&quot;Sunday&quot;</span> <span class="p">};</span>
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first">有的人喜歡在變數定義中使用Tab字元，使變數名對齊，這樣看起來很美觀。</p>
<div class="highlight-c"><pre>int    →a, b;
double →c;</pre>
</div>
</li>
</ol>
<p>內核代碼風格關於縮進和空白的規則有以下幾條。</p>
<ol class="arabic">
<li><p class="first">要用縮進體現出語句塊的層次關係，使用Tab字元縮進，不能用空格代替Tab。在標準的字元終端上一個Tab看起來是8個空格的寬度，如果你的文本編輯器可以設置一個Tab的顯示寬度是幾個空格，建議也設成8，這樣大的縮進使代碼看起來非常清晰。如果有的行用空格做縮進，有的行用Tab做縮進，甚至空格和Tab混用，那麼一旦改變了文本編輯器的Tab顯示寬度就會看起來非常混亂，所以內核代碼風格規定只能用Tab做縮進，不能用空格代替Tab。</p>
</li>
<li><p class="first">在 <tt class="docutils literal"><span class="pre">if/else</span></tt> 、 <tt class="docutils literal"><span class="pre">while</span></tt> 、 <tt class="docutils literal"><span class="pre">do/while</span></tt> 、 <tt class="docutils literal"><span class="pre">for</span></tt> 、 <tt class="docutils literal"><span class="pre">switch</span></tt> 這些可以帶語句塊的語句中，語句塊的{或}應該和關鍵字寫在同一行，用空格隔開，而不是單獨占一行。這個規定和 [K&amp;R]_ 的代碼風格一致，好處是不必占太多行，使得一屏能顯示更多代碼。例如應該這樣寫：</p>
<div class="highlight-c"><pre>if␣(...)␣{
       →語句列表
}␣else␣if␣(...)␣{
       →語句列表
}</pre>
</div>
<p>但很多人還是習慣這樣寫：</p>
<div class="highlight-c"><pre>if␣(...)
{
       →語句列表
}
else␣if␣(...)
{
       →語句列表
}</pre>
</div>
<p>這兩種寫法用得都很廣泛，只要在同一個項目中能保持統一就可以了。</p>
</li>
<li><p class="first">函數定義的{和}單獨占一行，這一點和語句塊的規定不同，例如：</p>
<div class="highlight-c"><pre>int␣foo(int␣a,␣int␣b)
{
       →語句列表
}</pre>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">switch</span></tt> 和語句塊裡的 <tt class="docutils literal"><span class="pre">case</span></tt> 、 <tt class="docutils literal"><span class="pre">default</span></tt> 對齊寫，也就是說語句塊裡的 <tt class="docutils literal"><span class="pre">case</span></tt> 、 <tt class="docutils literal"><span class="pre">default</span></tt> 標號相對於 <tt class="docutils literal"><span class="pre">switch</span></tt> 不往裡縮進，但標號下的語句要往裡縮進。例如：</p>
<div class="highlight-c"><pre>switch␣(c)␣{
case 'A':
       →語句列表
case 'B':
       →語句列表
default:
       →語句列表
}</pre>
</div>
<p>用於 <tt class="docutils literal"><span class="pre">goto</span></tt> 語句的自定義標號應該頂頭寫不縮進，而不管標號下的語句縮進到第幾層。</p>
</li>
<li><p class="first">代碼中每個邏輯段落之間應該用一個空行分隔開。例如每個函數定義之間應該插入一個空行，標頭檔、全局變數定義和函數定義之間也應該插入空行，例如：</p>
<div class="highlight-c"><pre>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int g;
double h;

int foo(void)
{
       →語句列表
}

int bar(int a)
{
       →語句列表
}

int main(void)
{
       →語句列表
}</pre>
</div>
</li>
<li><p class="first">如果一個函數的語句列表很長，可以根據相關性分成若干組，用空行分隔，通常把變數定義組成一組，後面加空行， <tt class="docutils literal"><span class="pre">return</span></tt> 語句之前加空行，例如：</p>
<div class="highlight-c"><pre>int main(void)
{
       →int    →a, b;
       →double →c;

       →語句組1

       →語句組2

       →return 0;
}</pre>
</div>
</li>
</ol>
</div>
<div class="section" id="id6">
<h2>9.2. 註釋<a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>單行註釋應採用 <tt class="docutils literal"><span class="pre">/*␣comment␣*/</span></tt> 的形式，用空格把界定符和文字分開。多行註釋最常見的是這種形式：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">␣*␣Multi-line</span>
<span class="cm">␣*␣comment</span>
<span class="cm">␣*/</span>
</pre></div>
</td></tr></table></div>
<p>也有更花哨的形式：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*************\</span>
<span class="cm">* Multi-line  *</span>
<span class="cm">* comment     *</span>
<span class="cm">\*************/</span>
</pre></div>
</td></tr></table></div>
<p>使用註釋的場合主要有以下幾種。</p>
<ol class="arabic">
<li><p class="first">整個源檔案的頂部註釋。說明此模組的相關信息，例如檔案名、作者和版本歷史等，頂頭寫不縮進。例如內核原始碼目錄下的 <tt class="file docutils literal"><span class="pre">kernel/sched.c</span></tt> 檔案的開頭：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19</pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> *  kernel/sched.c</span>
<span class="cm"> *</span>
<span class="cm"> *  Kernel scheduler and related syscalls</span>
<span class="cm"> *</span>
<span class="cm"> *  Copyright (C) 1991-2002  Linus Torvalds</span>
<span class="cm"> *</span>
<span class="cm"> *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and</span>
<span class="cm"> *              make semaphores SMP safe</span>
<span class="cm"> *  1998-11-19  Implemented schedule_timeout() and related stuff</span>
<span class="cm"> *              by Andrea Arcangeli</span>
<span class="cm"> *  2002-01-04  New ultra-scalable O(1) scheduler by Ingo Molnar:</span>
<span class="cm"> *              hybrid priority-list and round-robin design with</span>
<span class="cm"> *              an array-switch method of distributing timeslices</span>
<span class="cm"> *              and per-CPU runqueues.  Cleanups and useful suggestions</span>
<span class="cm"> *              by Davide Libenzi, preemptible kernel bits by Robert Love.</span>
<span class="cm"> *  2003-09-03  Interactivity tuning by Con Kolivas.</span>
<span class="cm"> *  2004-04-02  Scheduler domains code by Nick Piggin</span>
<span class="cm"> */</span>
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first">函數註釋。說明此函數的功能、參數、返回值、錯誤碼等，寫在函數定義上側，和此函數定義之間不留空行，頂頭寫不縮進。</p>
</li>
<li><p class="first">相對獨立的語句組註釋。對這一組語句做特別說明，寫在語句組上側，和此語句組之間不留空行，與當前語句組的縮進一致。</p>
</li>
<li><p class="first">代碼行右側的簡短註釋。對當前代碼行做特別說明，一般為單行註釋，和代碼之間至少用一個空格隔開，一個源檔案中所有的右側註釋最好能上下對齊。儘管 <a class="reference internal" href="expr.html#expr-helloworld"><em>繼續Hello World</em></a> 講過註釋可以穿插在一行代碼中間，但不建議這麼寫。內核原始碼目錄下的 <tt class="file docutils literal"><span class="pre">lib/radix-tree.c</span></tt> 檔案中的一個函數包含了上述三種註釋：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60</pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/**</span>
<span class="cm"> *      radix_tree_insert    -    insert into a radix tree</span>
<span class="cm"> *      @root:          radix tree root</span>
<span class="cm"> *      @index:         index key</span>
<span class="cm"> *      @item:          item to insert</span>
<span class="cm"> *</span>
<span class="cm"> *      Insert an item into the radix tree at position @index.</span>
<span class="cm"> */</span>
<span class="kt">int</span> <span class="nf">radix_tree_insert</span><span class="p">(</span><span class="k">struct</span> <span class="n">radix_tree_root</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span>
                        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">index</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">item</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">radix_tree_node</span> <span class="o">*</span><span class="n">node</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">*</span><span class="n">slot</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="n">shift</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">offset</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">error</span><span class="p">;</span>

        <span class="cm">/* Make sure the tree is high enough.  */</span>
        <span class="k">if</span> <span class="p">((</span><span class="o">!</span><span class="n">index</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">rnode</span><span class="p">)</span> <span class="o">||</span>
                        <span class="n">index</span> <span class="o">&gt;</span> <span class="n">radix_tree_maxindex</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">))</span> <span class="p">{</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">radix_tree_extend</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">index</span><span class="p">);</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span>
                        <span class="k">return</span> <span class="n">error</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">slot</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">rnode</span><span class="p">;</span>
        <span class="n">height</span> <span class="o">=</span> <span class="n">root</span><span class="o">-&gt;</span><span class="n">height</span><span class="p">;</span>
        <span class="n">shift</span> <span class="o">=</span> <span class="p">(</span><span class="n">height</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">RADIX_TREE_MAP_SHIFT</span><span class="p">;</span>

        <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>                     <span class="cm">/* uninitialised var warning */</span>
        <span class="k">do</span> <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
                        <span class="cm">/* Have to add a child node.  */</span>
                        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">slot</span> <span class="o">=</span> <span class="n">radix_tree_node_alloc</span><span class="p">(</span><span class="n">root</span><span class="p">)))</span>
                                <span class="k">return</span> <span class="o">-</span><span class="n">ENOMEM</span><span class="p">;</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
                                <span class="n">node</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
                                <span class="n">node</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
                        <span class="p">}</span> <span class="k">else</span>
                                <span class="n">root</span><span class="o">-&gt;</span><span class="n">rnode</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="cm">/* Go a level down */</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">index</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">RADIX_TREE_MAP_MASK</span><span class="p">;</span>
                <span class="n">node</span> <span class="o">=</span> <span class="n">slot</span><span class="p">;</span>
                <span class="n">slot</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">offset</span><span class="p">];</span>
                <span class="n">shift</span> <span class="o">-=</span> <span class="n">RADIX_TREE_MAP_SHIFT</span><span class="p">;</span>
                <span class="n">height</span><span class="o">--</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">height</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">slot</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
                <span class="k">return</span> <span class="o">-</span><span class="n">EEXIST</span><span class="p">;</span>

        <span class="n">BUG_ON</span><span class="p">(</span><span class="o">!</span><span class="n">node</span><span class="p">);</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">slots</span><span class="p">[</span><span class="n">offset</span><span class="p">]</span> <span class="o">=</span> <span class="n">item</span><span class="p">;</span>
        <span class="n">BUG_ON</span><span class="p">(</span><span class="n">tag_get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">offset</span><span class="p">));</span>
        <span class="n">BUG_ON</span><span class="p">(</span><span class="n">tag_get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">offset</span><span class="p">));</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><a class="reference internal" href="bibli.html#codingstyle">[CodingStyle]</a> 中特別指出，函數內的註釋要儘可能少用。寫註釋主要是為了說明你的代碼“能做什麼”（比如函數介面定義），而不是為了說明“怎樣做”，只要代碼寫得足夠清晰，“怎樣做”是一目瞭然的，如果你需要用註釋才能解釋清楚，那就表示你的代碼可讀性很差，除非是特別需要提醒注意的地方纔使用函數內註釋。</p>
</li>
<li><p class="first">複雜的結構體定義比函數更需要註釋。例如內核原始碼目錄下的 <tt class="file docutils literal"><span class="pre">kernel/sched.c</span></tt> 檔案中定義了這樣一個結構體：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68</pre></div></td><td class="code"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm"> * This is the main, per-CPU runqueue data structure.</span>
<span class="cm"> *</span>
<span class="cm"> * Locking rule: those places that want to lock multiple runqueues</span>
<span class="cm"> * (such as the load balancing or the thread migration code), lock</span>
<span class="cm"> * acquire operations must be ordered by ascending &amp;runqueue.</span>
<span class="cm"> */</span>
<span class="k">struct</span> <span class="n">runqueue</span> <span class="p">{</span>
        <span class="n">spinlock_t</span> <span class="n">lock</span><span class="p">;</span>

        <span class="cm">/*</span>
<span class="cm">         * nr_running and cpu_load should be in the same cacheline because</span>
<span class="cm">         * remote CPUs use both these fields when doing load calculation.</span>
<span class="cm">         */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_running</span><span class="p">;</span>
<span class="cp">#ifdef CONFIG_SMP</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">cpu_load</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="cp">#endif</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">nr_switches</span><span class="p">;</span>

        <span class="cm">/*</span>
<span class="cm">         * This is part of a global counter where only the total sum</span>
<span class="cm">         * over all CPUs matters. A task can increase this counter on</span>
<span class="cm">         * one CPU and if it got migrated afterwards it may decrease</span>
<span class="cm">         * it on another CPU. Always updated under the runqueue lock:</span>
<span class="cm">         */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">nr_uninterruptible</span><span class="p">;</span>

        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">expired_timestamp</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">timestamp_last_tick</span><span class="p">;</span>
        <span class="n">task_t</span> <span class="o">*</span><span class="n">curr</span><span class="p">,</span> <span class="o">*</span><span class="n">idle</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">mm_struct</span> <span class="o">*</span><span class="n">prev_mm</span><span class="p">;</span>
        <span class="n">prio_array_t</span> <span class="o">*</span><span class="n">active</span><span class="p">,</span> <span class="o">*</span><span class="n">expired</span><span class="p">,</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
        <span class="kt">int</span> <span class="n">best_expired_prio</span><span class="p">;</span>
        <span class="n">atomic_t</span> <span class="n">nr_iowait</span><span class="p">;</span>

<span class="cp">#ifdef CONFIG_SMP</span>
        <span class="k">struct</span> <span class="n">sched_domain</span> <span class="o">*</span><span class="n">sd</span><span class="p">;</span>

        <span class="cm">/* For active balancing */</span>
        <span class="kt">int</span> <span class="n">active_balance</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">push_cpu</span><span class="p">;</span>

        <span class="n">task_t</span> <span class="o">*</span><span class="n">migration_thread</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">list_head</span> <span class="n">migration_queue</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">cpu</span><span class="p">;</span>
<span class="cp">#endif</span>

<span class="cp">#ifdef CONFIG_SCHEDSTATS</span>
        <span class="cm">/* latency stats */</span>
        <span class="k">struct</span> <span class="n">sched_info</span> <span class="n">rq_sched_info</span><span class="p">;</span>

        <span class="cm">/* sys_sched_yield() stats */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">yld_exp_empty</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">yld_act_empty</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">yld_both_empty</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">yld_cnt</span><span class="p">;</span>

        <span class="cm">/* schedule() stats */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sched_switch</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sched_cnt</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">sched_goidle</span><span class="p">;</span>

        <span class="cm">/* try_to_wake_up() stats */</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ttwu_cnt</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">ttwu_local</span><span class="p">;</span>
<span class="cp">#endif</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
</li>
<li><p class="first">複雜的宏定義和變數聲明也需要註釋。例如內核原始碼目錄下的 <tt class="file docutils literal"><span class="pre">include/linux/jiffies.h</span></tt> 檔案中的聲明和註釋：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">/* TICK_USEC_TO_NSEC is the time between ticks in nsec assuming real ACTHZ and  */</span>
<span class="cp">/* a value TUSEC for TICK_USEC (can be set bij adjtimex)                */</span>
<span class="cp">#define TICK_USEC_TO_NSEC(TUSEC) (SH_DIV (TUSEC * USER_HZ * 1000, ACTHZ, 8))</span>

<span class="cm">/* some arch&#39;s have a small-data section that can be accessed register-relative</span>
<span class="cm"> * but that can only take up to, say, 4-byte variables. jiffies being part of</span>
<span class="cm"> * an 8-byte variable may not be correctly accessed unless we force the issue</span>
<span class="cm"> */</span>
<span class="cp">#define __jiffy_data  __attribute__((section(&quot;.data&quot;)))</span>

<span class="cm">/*</span>
<span class="cm"> * The 64-bit value is not volatile - you MUST NOT read it</span>
<span class="cm"> * without sampling the sequence number in xtime_lock.</span>
<span class="cm"> * get_jiffies_64() will do this for you as appropriate.</span>
<span class="cm"> */</span>
<span class="k">extern</span> <span class="n">u64</span> <span class="n">__jiffy_data</span> <span class="n">jiffies_64</span><span class="p">;</span>
<span class="k">extern</span> <span class="kt">unsigned</span> <span class="kt">long</span> <span class="k">volatile</span> <span class="n">__jiffy_data</span> <span class="n">jiffies</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</li>
</ol>
</div>
<div class="section" id="id8">
<h2>9.3. 標識符命名<a class="headerlink" href="#id8" title="Permalink to this headline">¶</a></h2>
<p>標識符命名應遵循以下原則：</p>
<ol class="arabic simple" id="index-0">
<li>標識符命名要清晰明了，可以使用完整的單詞和易於理解的縮寫。短的單詞可以通過去元音形成縮寫，較長的單詞可以取單詞的頭幾個字母形成縮寫。看別人的代碼看多了就可以總結出一些縮寫慣例，例如 <tt class="docutils literal"><span class="pre">count</span></tt> 寫成 <tt class="docutils literal"><span class="pre">cnt</span></tt> ， <tt class="docutils literal"><span class="pre">block</span></tt> 寫成 <tt class="docutils literal"><span class="pre">blk</span></tt> ， <tt class="docutils literal"><span class="pre">length</span></tt> 寫成 <tt class="docutils literal"><span class="pre">len</span></tt> ， <tt class="docutils literal"><span class="pre">window</span></tt> 寫成 <tt class="docutils literal"><span class="pre">win</span></tt> ， <tt class="docutils literal"><span class="pre">message</span></tt> 寫成 <tt class="docutils literal"><span class="pre">msg</span></tt> ， <tt class="docutils literal"><span class="pre">number</span></tt> 寫成 <tt class="docutils literal"><span class="pre">nr</span></tt> ， <tt class="docutils literal"><span class="pre">temporary</span></tt> 可以寫成 <tt class="docutils literal"><span class="pre">temp</span></tt> ，也可以進一步寫成 <tt class="docutils literal"><span class="pre">tmp</span></tt> ，最有意思的是 <tt class="docutils literal"><span class="pre">internationalization</span></tt> 寫成 <tt class="docutils literal"><span class="pre">i18n</span></tt> （因為i和n中間省略了18個字母），詞根 <tt class="docutils literal"><span class="pre">trans</span></tt> 經常縮寫成 <tt class="docutils literal"><span class="pre">x</span></tt> （例如 <tt class="docutils literal"><span class="pre">transmit</span></tt> 寫成 <tt class="docutils literal"><span class="pre">xmt</span></tt> ）。我就不多舉例了，請讀者在看代碼時自己注意總結和積累。</li>
<li>內核編碼風格規定變數、函數和類型採用全小寫加下劃線的方式命名，常量（比如宏定義和枚舉常量）採用全大寫加下劃線的方式命名，比如上一節舉例的函數名 <tt class="docutils literal"><span class="pre">radix_tree_insert</span></tt> 、類型名 <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">radix_tree_root</span></tt> 、常量名 <tt class="docutils literal"><span class="pre">RADIX_TREE_MAP_SHIFT</span></tt> 等。</li>
<li>微軟髮明了一種變數命名法叫匈牙利命名法（Hungarian Notation），在變數名中用首碼表示類型，例如 <tt class="docutils literal"><span class="pre">iCnt</span></tt> （i表示int）、 <tt class="docutils literal"><span class="pre">pMsg</span></tt> （p表示pointer）、 <tt class="docutils literal"><span class="pre">lpszText</span></tt> （lpsz表示long pointer to a null-terminated string）等。Linus在 <a class="reference internal" href="bibli.html#codingstyle">[CodingStyle]</a> 中毫不客氣地諷刺了這種寫法：“Encoding the type of a function into the name (so-called Hungarian notation) is brain damaged - the compiler knows the types anyway and can check those, and it only confuses the programmer. No wonder MicroSoft makes buggy programs.”代碼風格本來就是一個很有爭議的問題，如果你接受本章介紹的內核編碼風格，就不要使用大小寫混合的變數命名方式 <a class="footnote-reference" href="#id11" id="id10">[1]</a> ，更不要使用匈牙利命名法。</li>
<li>全局變數和全局函數的命名一定要詳細，不惜多用幾個單詞多寫幾個下劃線，例如函數名 <tt class="docutils literal"><span class="pre">radix_tree_insert</span></tt> ，因為它們在整個項目的許多源檔案中都會用到，必須讓使用者明確這個變數或函數是幹什麼用的。局部變數和只在一個源檔案中調用的內部函數的命名可以簡略一些，但不能太短。儘量不要使用單個字母做變數名，只有一個例外：用 <tt class="docutils literal"><span class="pre">i</span></tt> 、 <tt class="docutils literal"><span class="pre">j</span></tt> 、 <tt class="docutils literal"><span class="pre">k</span></tt> 做循環變數是可以的。</li>
<li>針對中國程序員的一條特別規定：禁止用漢語拼音做標識符，可讀性極差。</li>
</ol>
<span class="target" id="index-1"></span><table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[1]</a></td><td>大小寫混合的命名方式是Modern C++風格所提倡的，在C++代碼中很普遍，稱為CamelCase，大概是因為有高有低像駝峰一樣。</td></tr>
</tbody>
</table>
</div>
<div class="section" id="id12">
<h2>9.4. 函數<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>每個函數都應該設計得儘可能簡單，簡單的函數才容易維護。應遵循以下原則：</p>
<ol class="arabic simple" id="index-2">
<li>實現一個函數只是為了做好一件事情，不要把函數設計成用途廣泛、面面俱到的，這樣的函數肯定會超長，而且往往不可重用，維護困難。</li>
<li>函數內部的縮進層次不宜過多，一般以少於4層為宜。如果縮進層次太多就說明設計得太複雜了，應考慮分割成更小的函數（Helper Function）來調用。</li>
<li>函數不要寫得太長，建議在24行的標準終端上不超過兩屏，太長會造成閲讀困難，如果一個函數超過兩屏就應該考慮分割函數了。 <a class="reference internal" href="bibli.html#codingstyle">[CodingStyle]</a> 中特別說明，如果一個函數在概念上是簡單的，只是長度很長，這倒沒關係。例如函數由一個大的 <tt class="docutils literal"><span class="pre">switch</span></tt> 組成，其中有非常多的 <tt class="docutils literal"><span class="pre">case</span></tt> ，這是可以的，因為各 <tt class="docutils literal"><span class="pre">case</span></tt> 分支互不影響，整個函數的複雜度只等於其中一個 <tt class="docutils literal"><span class="pre">case</span></tt> 的複雜度，這種情況很常見，例如TCP協議的狀態機實現。</li>
<li>執行函數就是執行一個動作，函數名通常應包含動詞，例如 <tt class="docutils literal"><span class="pre">get_current</span></tt> 、 <tt class="docutils literal"><span class="pre">radix_tree_insert</span></tt> 。</li>
<li>比較重要的函數定義上側必須加註釋，說明此函數的功能、參數、返回值、錯誤碼等。</li>
<li>另一種度量函數複雜度的辦法是看有多少個局部變數，5到10個局部變數已經很多了，再多就很難維護了，應該考慮分割成多個函數。</li>
</ol>
</div>
<div class="section" id="indent">
<h2>9.5. indent工具<a class="headerlink" href="#indent" title="Permalink to this headline">¶</a></h2>
<p><strong class="command">indent</strong> 工具可以把代碼格式化成某種風格，例如把 <a class="reference internal" href="#codingstyle-indent"><em>縮進和空白</em></a> 中缺少縮進和空白“剪刀石頭布”代碼格式化成內核編碼風格:</p>
<div class="highlight-python"><pre>$ indent -kr -i8 main.c
$ cat main.c
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;time.h&gt;
int main(void)
{
        char gesture[3][10] = { "scissor", "stone", "cloth" };
        int man, computer, result, ret;
        srand(time(NULL));
        while (1) {
                computer = rand() % 3;
                printf
                    ("\nInput your gesture (0-scissor 1-stone 2-cloth):\n");
                ret = scanf("%d", &amp;man);
                if (ret != 1 || man &lt; 0 || man &gt; 2) {
                        printf("Invalid input!\n");
                        return 1;
                }
                printf("You: %s\tComputer: %s\n",
                       gesture[man], gesture[computer]);
                result = (man - computer + 4) % 3 - 1;
                if (result &gt; 0)
                        printf("You win!\n");
                else if (result == 0)
                        printf("Draw!\n");
                else
                        printf("You lose!\n");
        }
        return 0;
}</pre>
</div>
<p><em class="xref std std-option">-kr</em> 選項表示K&amp;R風格， <em class="xref std std-option">-i8</em> 表示縮進8個空格的長度。如果沒有指定 <em class="xref std std-option">-nut</em> 選項，則每8個縮進空格會自動用一個Tab代替。注意 <strong class="command">indent</strong> 命令會直接修改原檔案，而不是打印到屏幕上或者輸出到另一個檔案，這一點和很多UNIX命令不同。可以看出， <em class="xref std std-option">-kr -i8</em> 兩個選項格式化出來的代碼已經很符合本章介紹的代碼風格了，添加了必要的縮進和空白，較長的代碼行也會自動折行。美中不足的是沒有添加適當的空行，因為 <strong class="command">indent</strong> 工具也不知道哪幾行代碼在邏輯上是一組的，空行還是要自己動手添，當然原有的空行肯定不會被 <strong class="command">indent</strong> 刪去的。</p>
<p>如果你採納本章介紹的內核編碼風格，基本上 <em class="xref std std-option">-kr -i8</em> 這兩個參數就夠用了。 <strong class="command">indent</strong> 工具也有支持其他編碼風格的選項，具體請參閱 <em class="manpage">indent(1)</em> 。有時候 <strong class="command">indent</strong> 工具的確非常有用，比如某個項目中途決定改變編碼風格（這很少見），或者往某個項目中添加的幾個代碼檔案來自另一個編碼風格不同的項目，但絶不能因為有了 <strong class="command">indent</strong> 工具就肆無忌憚，一開始把代碼寫得亂七八糟，最後再依靠 <strong class="command">indent</strong> 去清理。</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">9. 編碼風格</a><ul>
<li><a class="reference internal" href="#codingstyle-indent">9.1. 縮進和空白</a></li>
<li><a class="reference internal" href="#id6">9.2. 註釋</a></li>
<li><a class="reference internal" href="#id8">9.3. 標識符命名</a></li>
<li><a class="reference internal" href="#id12">9.4. 函數</a></li>
<li><a class="reference internal" href="#indent">9.5. indent工具</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="array.html"
                        title="previous chapter">8. 數組</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="gdb.html"
                        title="next chapter">10. gdb</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/zh/codingstyle.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><table border=0 cellspacing=0 style="color: white;">

<tr><td>
   請輸入您的email訂閲<a href="http://groups.google.com/group/learning-linux-c-cpp">本書的郵件列表</a><br/>
   (Please enter your email to subscribe to <a href="http://groups.google.com/group/learning-linux-c-cpp">this book's mailing list</a>)<br/>
   <form action="http://groups.google.com/group/learning-linux-c-cpp/boxsubscribe"><input type=text name=email><input type=submit name="sub" value="訂閲(Subscribe)"></form>
</td></tr>

<tr><td><br/>關注<a href="http://weibo.com/sansoong">我的微博</a></td></tr>

<tr><td><br/>Checkout the source from github: <a href="https://github.com/learning-linux-c-cpp/akabook">https://github.com/learning-linux-c-cpp/akabook</a></td></tr>

<tr><td>
   <br/>感謝您的慷慨捐贈！<br/>
   Thanks for your generous donation!<br/>
   <a href="http://me.alipay.com/songjinshan" target="_blank"><img src="_static/me.alipay.png" alt="捐贈"></a>
</td></tr>

</table>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="gdb.html" title="10. gdb"
             >next</a> |</li>
        <li class="right" >
          <a href="array.html" title="8. 數組"
             >previous</a> |</li>
        <li><a href="../index.html">akabook 3.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >中文版：Linux C/C++編程一站式學習</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Sean Soong.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>