

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7. 結構體 &mdash; akabook 3.0 documentation</title>
    
    <link rel="stylesheet" href="../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <link rel="top" title="akabook 3.0 documentation" href="../index.html" />
    <link rel="up" title="中文版：Linux C/C++編程一站式學習" href="index.html" />
    <link rel="next" title="8. 數組" href="array.html" />
    <link rel="prev" title="6. 循環語句" href="iter.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="array.html" title="8. 數組"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="iter.html" title="6. 循環語句"
             accesskey="P">previous</a> |</li>
        <li><a href="../index.html">akabook 3.0 documentation</a> &raquo;</li>
          <li><a href="index.html" accesskey="U">中文版：Linux C/C++編程一站式學習</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="id1">
<h1>7. 結構體<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="section" id="struct-struct">
<span id="id2"></span><h2>7.1. 復合類型與結構體<a class="headerlink" href="#struct-struct" title="Permalink to this headline">¶</a></h2>
<p id="index-0">在編程語言中，最基本的、不可再分的數據類型稱為基本類型（Primitive Type），例如整型、浮點型；根據語法規則由基本類型組合而成的類型稱為復合類型（Compound Type），例如字元串是由很多字元組成的。有些場合下要把復合類型當作一個整體來用，而另外一些場合下需要分解組成這個復合類型的各種基本類型，復合類型的這種兩面性為數據抽象（Data Abstraction）奠定了基礎。 <a class="reference internal" href="bibli.html#sicp">[SICP]</a> 的1.1節指出，在學習一門編程語言時要特別注意以下三個方面：</p>
<ol class="arabic simple" id="index-1">
<li>這門語言提供了哪些Primitive，比如基本類型，比如基本運算符、表達式和語句。</li>
<li>這門語言提供了哪些組合規則，比如基本類型如何組成復合類型，比如簡單的表達式和語句如何組成複雜的表達式和語句。</li>
<li>這門語言提供了哪些抽象機制，包括數據抽象和過程抽象（Procedure Abstraction）。</li>
</ol>
<p>本章以結構體為例講解數據類型的組合和數據抽象。至于過程抽象，我們在 <a class="reference internal" href="cond.html#cond-ifelse"><em>if/else語句</em></a> 已經見過最簡單的形式，就是把一組語句用一個函數名封裝起來，當作一個整體使用，本章將介紹更複雜的過程抽象。</p>
<p>現在我們用C語言表示一個複數。從直角坐標系來看，複數由實部和虛部組成，從極坐標系來看，複數由模和輻角組成，兩種坐標系可以相互轉換，如下圖所示：</p>
<div class="figure">
<img alt="../_images/struct.complex.png" src="../_images/struct.complex.png" />
<p class="caption">複數</p>
</div>
<p>如果用實部和虛部表示一個複數，我們可以定義一種由兩個 <tt class="docutils literal"><span class="pre">double</span></tt> 型組成的結構體類型來表示覆數的類型：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">complex_struct</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>需要說明幾點：</p>
<ol class="arabic simple" id="index-2">
<li>這一句定義了標識符 <tt class="docutils literal"><span class="pre">complex_struct</span></tt> （同樣要遵循標識符的命名規則），這種標識符在C語言中稱為Tag。</li>
<li>這一句就像變數聲明一樣，以;號結尾卻不是個語句，事實上它是個類型聲明（或者叫類型定義）。由於語句塊和函數體的}後面不需要寫;號，初學者在寫結構體的類型定義時常犯的一個錯誤是忘了寫}後面的;號，這一點要注意。</li>
<li>在這句定義之後， <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">complex_struct</span></tt> 就像 <tt class="docutils literal"><span class="pre">int</span></tt> 或 <tt class="docutils literal"><span class="pre">double</span></tt> 一樣可以當類型名使用了 <a class="footnote-reference" href="#id5" id="id4">[1]</a> 。唯一的區別是， <tt class="docutils literal"><span class="pre">int</span></tt> 或 <tt class="docutils literal"><span class="pre">double</span></tt> 是基本類型，而 <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">complex_struct</span></tt> 是一種結構體類型，是由基本類型組合而成的復合類型。</li>
</ol>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[1]</a></td><td>其實C99已經定義了複數類型 <tt class="docutils literal"><span class="pre">_Complex</span></tt> 。如果包含C標準庫的標頭檔 <tt class="file docutils literal"><span class="pre">complex.h</span></tt> ，也可以用 <tt class="docutils literal"><span class="pre">complex</span></tt> 做類型名。當然，只要不包含標頭檔 <tt class="file docutils literal"><span class="pre">complex.h</span></tt> 就可以自己定義標識符 <tt class="docutils literal"><span class="pre">complex</span></tt> ，但為了儘量減少混淆，本章的示例代碼都用 <tt class="docutils literal"><span class="pre">complex_struct</span></tt> 做標識符而不用 <tt class="docutils literal"><span class="pre">complex</span></tt> 。</td></tr>
</tbody>
</table>
<p>我們也可以在一條聲明中既定義結構體類型又定義這種類型的變數：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">complex_struct</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span> <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>在這句定義之後， <tt class="docutils literal"><span class="pre">z1</span></tt> 和 <tt class="docutils literal"><span class="pre">z2</span></tt> 就可以當變數名來訪問了，而 <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">complex_struct</span></tt> 也可以當類型名來使用了，接下來可以用 <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">complex_struct</span></tt> 這個類型名再定義兩個複數變數：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z3</span><span class="p">,</span> <span class="n">z4</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>如果要在定義結構體類型的同時定義變數，也可以不寫Tag，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span> <span class="n">z1</span><span class="p">,</span> <span class="n">z2</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>在這句定義之後，就只能訪問變數 <tt class="docutils literal"><span class="pre">z1</span></tt> 和 <tt class="docutils literal"><span class="pre">z2</span></tt> ，而沒法用這個結構體類型再定義其他變數了，因為這個結構體類型沒有名字。</p>
<p id="index-3">我們定義的每個複數變數都有兩個成員（Member） <tt class="docutils literal"><span class="pre">x</span></tt> 和 <tt class="docutils literal"><span class="pre">y</span></tt> ，可以用.尾碼運算符來訪問，.號（Period）和成員名是變數名的尾碼，比如表達式 <tt class="docutils literal"><span class="pre">z1.x</span></tt> 的值是複數變數 <tt class="docutils literal"><span class="pre">z1</span></tt> 的x坐標。下面是一個完整的例子：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">complex_struct</span> <span class="p">{</span> <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span> <span class="n">z</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mf">4.0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;z=%f%fi</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">z</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
        <span class="k">else</span>
                <span class="n">printf</span><span class="p">(</span><span class="s">&quot;z=%f+%fi</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">z</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>注意上例中變數 <tt class="docutils literal"><span class="pre">x</span></tt> 和變數 <tt class="docutils literal"><span class="pre">z</span></tt> 的成員 <tt class="docutils literal"><span class="pre">x</span></tt> 的名字並不衝突，因為變數 <tt class="docutils literal"><span class="pre">z</span></tt> 的成員 <tt class="docutils literal"><span class="pre">x</span></tt> 只能通過表達式 <tt class="docutils literal"><span class="pre">z.x</span></tt> 來訪問，編譯器可以從語法上區分哪個 <tt class="docutils literal"><span class="pre">x</span></tt> 是變數 <tt class="docutils literal"><span class="pre">x</span></tt> ，哪個 <tt class="docutils literal"><span class="pre">x</span></tt> 是變數 <tt class="docutils literal"><span class="pre">z</span></tt> 的成員 <tt class="docutils literal"><span class="pre">x</span></tt> ，在 <a class="reference internal" href="asmc.html#asmc-storage"><em>變數的存儲佈局</em></a> 會講到這兩個標識符 <tt class="docutils literal"><span class="pre">x</span></tt> 屬於不同的命名空間。</p>
<p>結構體類型也可以定義在全局作用域中，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">complex_struct</span> <span class="p">{</span> <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z</span><span class="p">;</span>
        <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>結構體變數也可以在定義時初始化，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span> <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>Initializer中的數據依次賦給結構體的各成員。如果Initializer中的數據比結構體的成員多，編譯器會報錯，但如果只是末尾多個逗號則不算錯。如果Initializer中的數據比結構體的成員少，未指定的成員將用0來初始化（就像未初始化的全局變數一樣）。以下幾種形式的初始化都是合法的：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">double</span> <span class="n">x</span> <span class="o">=</span> <span class="mf">3.0</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z1</span> <span class="o">=</span> <span class="p">{</span> <span class="n">x</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="p">};</span> <span class="cm">/* z1.x=3.0, z1.y=4.0 */</span>
<span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z2</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">3.0</span><span class="p">,</span> <span class="p">};</span> <span class="cm">/* z2.x=3.0, z2.y=0.0 */</span>
<span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z3</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span> <span class="cm">/* z3.x=0.0, z3.y=0.0 */</span>
</pre></div>
</td></tr></table></div>
<p>注意， <tt class="docutils literal"><span class="pre">z1</span></tt> 必須是局部變數才能用另一個變數 <tt class="docutils literal"><span class="pre">x</span></tt> 的值來初始化它的成員，如果是全局變數就只能用常量表達式來初始化。這也是C99的新特性，C89隻允許在{}中使用常量表達式來初始化，無論是初始化全局變數還是局部變數。</p>
<p>注意結構體的Initializer不能用於結構體的賦值，例如這樣是錯誤的：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z1</span><span class="p">;</span>
<span class="n">z1</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span> <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>以前我們初始化基本類型的變數所使用的Initializer都是表達式，表達式當然也可以用來賦值，但現在這種由{}括起來的Initializer並不是表達式，所以不能用來賦值 <a class="footnote-reference" href="#id7" id="id6">[2]</a> 。Initializer的語法總結如下:</p>
<div class="highlight-python"><pre>Initializer → 表達式
Initializer → { 初始化列表 }
初始化列表 → Designated-Initializer, Designated-Initializer, ...
（最後一個Designated-Initializer末尾可以有一個多餘的,號）
Designated-Initializer → Initializer
Designated-Initializer → .標識符 = Initializer
Designated-Initializer → [常量表達式] = Initializer</pre>
</div>
<span class="target" id="index-4"></span><table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[2]</a></td><td>C99引入一種新的表達式語法Compound Literal可以用來賦值，例如 <tt class="docutils literal"><span class="pre">z1</span> <span class="pre">=</span> <span class="pre">(struct</span> <span class="pre">complex_struct){</span> <span class="pre">3.0,</span> <span class="pre">4.0</span> <span class="pre">};</span></tt> ，本書不使用這種新語法。</td></tr>
</tbody>
</table>
<p id="index-5">Designated Initializer是C99引入的新特性，用於初始化稀疏（Sparse）結構體和稀疏數組很方便。有些時候結構體或數組中只有某一個或某幾個成員需要初始化，其他成員都用0初始化即可，用Designated Initializer語法可以針對每個成員做初始化（Memberwise Initialization），很方便。例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z1</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="mf">4.0</span> <span class="p">};</span> <span class="cm">/* z1.x=0.0, z1.y=4.0 */</span>
</pre></div>
</td></tr></table></div>
<p>數組的Memberwise Initialization語法將在下一章介紹。</p>
<p id="index-6">結構體類型用在表達式中有很多限制，不像基本類型那麼自由，比如+ - * /等算術運算符和&amp;&amp; || !等邏輯運算符的操作數都不能是結構體類型， <tt class="docutils literal"><span class="pre">if</span></tt> 語句、 <tt class="docutils literal"><span class="pre">while</span></tt> 語句中的控製表達式的值也不能是結構體類型。嚴格來說，可以做算術運算的類型稱為算術類型（Arithmetic Type），算術類型包括整型和浮點型。可以表示零和非零、可以參與邏輯與、或、非運算或者做控製表達式的類型稱為標量類型（Scalar Type），標量類型包括算術類型和以後要講的指針類型，詳見 <a class="reference internal" href="pointer.html#pointer-type"><em>C語言類型總結</em></a> 。</p>
<p>結構體變數之間使用賦值運算符是允許的，用一個結構體變數初始化另一個結構體變數也是允許的，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z1</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z2</span> <span class="o">=</span> <span class="n">z1</span><span class="p">;</span>
<span class="n">z1</span> <span class="o">=</span> <span class="n">z2</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p>注意 <tt class="docutils literal"><span class="pre">z2</span></tt> 必須是局部變數才能用變數 <tt class="docutils literal"><span class="pre">z1</span></tt> 來初始化。既然結構體變數之間可以相互賦值和初始化，也就可以當作函數的參數和返回值來傳遞：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">complex_struct</span> <span class="nf">add_complex</span><span class="p">(</span><span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z2</span><span class="p">)</span>
<span class="p">{</span>
        <span class="n">z1</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">z1</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">z2</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
        <span class="n">z1</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">z1</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">z2</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">z1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>這個函數實現了兩個複數相加，如果在main函數中這樣調用：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">3.0</span><span class="p">,</span> <span class="mf">4.0</span> <span class="p">};</span>
<span class="n">z</span> <span class="o">=</span> <span class="n">add_complex</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">z</span><span class="p">);</span>
</pre></div>
</td></tr></table></div>
<p>那麼調用傳參的過程如下圖所示：</p>
<div class="figure">
<img alt="../_images/struct.parameter.png" src="../_images/struct.parameter.png" />
<p class="caption">結構體傳參</p>
</div>
<p>從上圖可以看出，一個結構體變數的各成員的存儲空間總是相鄰的 <a class="footnote-reference" href="#id9" id="id8">[3]</a> ，合在一起組成結構體變數的存儲空間。變數 <tt class="docutils literal"><span class="pre">z</span></tt> 在 <tt class="docutils literal"><span class="pre">main</span></tt> 函數的棧幀上，參數 <tt class="docutils literal"><span class="pre">z1</span></tt> 和 <tt class="docutils literal"><span class="pre">z2</span></tt> 在 <tt class="docutils literal"><span class="pre">add_complex</span></tt> 函數的棧幀上， <tt class="docutils literal"><span class="pre">z</span></tt> 的值分別賦給 <tt class="docutils literal"><span class="pre">z1</span></tt> 和 <tt class="docutils literal"><span class="pre">z2</span></tt> 。在 <tt class="docutils literal"><span class="pre">add_complex</span></tt> 函數里， <tt class="docutils literal"><span class="pre">z2</span></tt> 的實部和虛部被累加到 <tt class="docutils literal"><span class="pre">z1</span></tt> 中，然後 <tt class="docutils literal"><span class="pre">return</span> <span class="pre">z1;</span></tt> 可以看成是：</p>
<ol class="arabic simple">
<li>用 <tt class="docutils literal"><span class="pre">z1</span></tt> 初始化一個臨時變數。</li>
<li>函數返回並釋放棧幀。</li>
<li>把臨時變數的值賦給變數 <tt class="docutils literal"><span class="pre">z</span></tt> ，釋放臨時變數。</li>
</ol>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[3]</a></td><td>我們在 <a class="reference internal" href="asmc.html#asmc-structunion"><em>結構體和聯合體</em></a> 會看到，結構體成員之間也可能有若干個填充位元組。</td></tr>
</tbody>
</table>
<p>由.尾碼運算符組成的表達式能不能做左值取決於.尾碼運算符左邊的操作數能不能做左值。在上面的例子中， <tt class="docutils literal"><span class="pre">z</span></tt> 是一個變數，可以做左值，因此表達式 <tt class="docutils literal"><span class="pre">z.x</span></tt> 也可以做左值，但表達式 <tt class="docutils literal"><span class="pre">add_complex(z,</span> <span class="pre">z).x</span></tt> 只能做右值而不能做左值，因為 <tt class="docutils literal"><span class="pre">add_complex(z,</span> <span class="pre">z)</span></tt> 的返回值是個臨時變數，不能做左值。</p>
</div>
<div class="section" id="struct-dataabstraction">
<span id="id10"></span><h2>7.2. 數據抽象<a class="headerlink" href="#struct-dataabstraction" title="Permalink to this headline">¶</a></h2>
<p>現在我們來實現一個完整的複數運算程序。在上一節我們已經定義了複數的結構體類型，現在需要圍繞它定義一些函數。複數可以用直角坐標或極坐標表示，直角坐標做加減法比較方便，極坐標做乘除法比較方便。如果我們定義的複數結構體是直角坐標的，那麼應該提供極坐標的轉換函數，以便在需要的時候可以方便地取它的模和輻角：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;math.h&gt;</span>

<span class="k">struct</span> <span class="n">complex_struct</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">double</span> <span class="nf">real_part</span><span class="p">(</span><span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">img_part</span><span class="p">(</span><span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">magnitude</span><span class="p">(</span><span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="n">z</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">z</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="n">z</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">angle</span><span class="p">(</span><span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">atan2</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>此外，我們還提供兩個函數用來構造複數變數，參數既可以是直角坐標也可以是極坐標，在函數中自動做相應的轉換然後返回構造的複數變數：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">complex_struct</span> <span class="nf">make_from_real_img</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">complex_struct</span> <span class="nf">make_from_mag_ang</span><span class="p">(</span><span class="kt">double</span> <span class="n">r</span><span class="p">,</span> <span class="kt">double</span> <span class="n">A</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
        <span class="n">z</span><span class="p">.</span><span class="n">y</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">A</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>在此基礎上就可以實現複數的加減乘除運算了：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">complex_struct</span> <span class="nf">add_complex</span><span class="p">(</span><span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z2</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">make_from_real_img</span><span class="p">(</span><span class="n">real_part</span><span class="p">(</span><span class="n">z1</span><span class="p">)</span> <span class="o">+</span> <span class="n">real_part</span><span class="p">(</span><span class="n">z2</span><span class="p">),</span>
                                  <span class="n">img_part</span><span class="p">(</span><span class="n">z1</span><span class="p">)</span> <span class="o">+</span> <span class="n">img_part</span><span class="p">(</span><span class="n">z2</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">complex_struct</span> <span class="nf">sub_complex</span><span class="p">(</span><span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z2</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">make_from_real_img</span><span class="p">(</span><span class="n">real_part</span><span class="p">(</span><span class="n">z1</span><span class="p">)</span> <span class="o">-</span> <span class="n">real_part</span><span class="p">(</span><span class="n">z2</span><span class="p">),</span>
                                  <span class="n">img_part</span><span class="p">(</span><span class="n">z1</span><span class="p">)</span> <span class="o">-</span> <span class="n">img_part</span><span class="p">(</span><span class="n">z2</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">complex_struct</span> <span class="nf">mul_complex</span><span class="p">(</span><span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z2</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">make_from_mag_ang</span><span class="p">(</span><span class="n">magnitude</span><span class="p">(</span><span class="n">z1</span><span class="p">)</span> <span class="o">*</span> <span class="n">magnitude</span><span class="p">(</span><span class="n">z2</span><span class="p">),</span>
                                 <span class="n">angle</span><span class="p">(</span><span class="n">z1</span><span class="p">)</span> <span class="o">+</span> <span class="n">angle</span><span class="p">(</span><span class="n">z2</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">complex_struct</span> <span class="nf">div_complex</span><span class="p">(</span><span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z1</span><span class="p">,</span> <span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z2</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">make_from_mag_ang</span><span class="p">(</span><span class="n">magnitude</span><span class="p">(</span><span class="n">z1</span><span class="p">)</span> <span class="o">/</span> <span class="n">magnitude</span><span class="p">(</span><span class="n">z2</span><span class="p">),</span>
                                 <span class="n">angle</span><span class="p">(</span><span class="n">z1</span><span class="p">)</span> <span class="o">-</span> <span class="n">angle</span><span class="p">(</span><span class="n">z2</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>可以看出，複數加減乘除運算的實現並沒有直接訪問結構體 <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">complex_struct</span></tt> 的成員 <tt class="docutils literal"><span class="pre">x</span></tt> 和 <tt class="docutils literal"><span class="pre">y</span></tt> ，而是把它看成一個整體，通過調用相關函數來取它的直角坐標和極坐標。這樣就可以非常方便地替換掉結構體 <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">complex_struct</span></tt> 的存儲表示，例如改為用極坐標來存儲：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;math.h&gt;</span>

<span class="k">struct</span> <span class="n">complex_struct</span> <span class="p">{</span>
        <span class="kt">double</span> <span class="n">r</span><span class="p">,</span> <span class="n">A</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">double</span> <span class="nf">real_part</span><span class="p">(</span><span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">.</span><span class="n">r</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">A</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">img_part</span><span class="p">(</span><span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">.</span><span class="n">r</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">z</span><span class="p">.</span><span class="n">A</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">magnitude</span><span class="p">(</span><span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">.</span><span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">double</span> <span class="nf">angle</span><span class="p">(</span><span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">.</span><span class="n">A</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">complex_struct</span> <span class="nf">make_from_real_img</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">atan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="n">z</span><span class="p">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">complex_struct</span> <span class="nf">make_from_mag_ang</span><span class="p">(</span><span class="kt">double</span> <span class="n">r</span><span class="p">,</span> <span class="kt">double</span> <span class="n">A</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>雖然結構體 <tt class="docutils literal"><span class="pre">complex_struct</span></tt> 的存儲表示做了這樣的改動， <tt class="docutils literal"><span class="pre">add_complex</span></tt> 、 <tt class="docutils literal"><span class="pre">sub_complex</span></tt> 、 <tt class="docutils literal"><span class="pre">mul_complex</span></tt> 、 <tt class="docutils literal"><span class="pre">div_complex</span></tt> 這幾個複數運算的函數卻不需要做任何改動，仍然可以用，原因在於這幾個函數只把結構體 <tt class="docutils literal"><span class="pre">complex_struct</span></tt> 當作一個整體來使用，而沒有直接訪問它的成員，因此也不依賴于它有哪些成員。我們結合下圖具體分析一下。</p>
<div class="figure">
<img alt="../_images/struct.abstraction.png" src="../_images/struct.abstraction.png" />
<p class="caption">數據抽象</p>
</div>
<p>這是一種抽象的思想。其實“抽象”這個概念並沒有那麼抽象，簡單地說就是“提取公因式”：ab+ac=a(b+c)。如果a變了，ab和ac這兩項都需要改，但如果寫成a(b+c)的形式，只需要改一個地方就夠了。</p>
<p>在我們的複數運算程序中，複數有可能用直角坐標或極坐標來表示，我們把這個有可能變動的因素提取出來組成複數存儲表示層： <tt class="docutils literal"><span class="pre">real_part</span></tt> 、 <tt class="docutils literal"><span class="pre">img_part</span></tt> 、 <tt class="docutils literal"><span class="pre">magnitude</span></tt> 、 <tt class="docutils literal"><span class="pre">angle</span></tt> 、 <tt class="docutils literal"><span class="pre">make_from_real_img</span></tt> 、 <tt class="docutils literal"><span class="pre">make_from_mag_ang</span></tt> 。這一層看到的數據是結構體的兩個成員 <tt class="docutils literal"><span class="pre">x</span></tt> 和 <tt class="docutils literal"><span class="pre">y</span></tt> ，或者 <tt class="docutils literal"><span class="pre">r</span></tt> 和 <tt class="docutils literal"><span class="pre">A</span></tt> ，如果改變了結構體的實現就要改變這一層函數的實現，但函數介面不改變，因此調用這一層函數介面的複數運算層不需要改變。複數運算層看到的數據只是一個抽象的“複數”的概念，知道它有直角坐標和極坐標，可以調用複數存儲表示層的函數得到這些坐標。再往上看，其他使用複數運算的程序看到的數據是一個更為抽象的“複數”的概念，只知道它是一個數，像整數、小數一樣可以加減乘除，甚至連它有直角坐標和極坐標也不需要知道。</p>
<p id="index-7">這裡的複數存儲表示層和複數運算層稱為抽象層（Abstraction Layer），從底層往上層來看，複數越來越抽象了，把所有這些層組合在一起就是一個完整的系統。 <strong>組合使得系統可以任意複雜，而抽象使得系統的複雜性是可以控制的，任何改動都只侷限在某一層，而不會波及整個系統。</strong> 著名的計算機科學家Butler Lampson說過：“All problems in computer science can be solved by another level of indirection.”這裡的indirection其實就是abstraction的意思。</p>
<p class="rubric">習題</p>
<ol class="arabic">
<li><p class="first">在本節的基礎上實現一個打印複數的函數，打印的格式是x+yi，如果實部或虛部為0則省略，例如： <tt class="docutils literal"><span class="pre">1.0</span></tt> 、 <tt class="docutils literal"><span class="pre">-2.0i</span></tt> 、 <tt class="docutils literal"><span class="pre">-1.0+2.0i</span></tt> 、 <tt class="docutils literal"><span class="pre">1.0-2.0i</span></tt> 。最後編寫一個 <tt class="docutils literal"><span class="pre">main</span></tt> 函數測試本節的所有代碼。想一想這個打印函數應該屬於上圖中的哪一層？</p>
</li>
<li><p class="first">實現一個用分子分母的格式來表示有理數的結構體類型 <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">rational</span></tt> 以及相關的函數， <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">rational</span></tt> 結構體類型之間可以做加減乘除運算，運算的結果仍然是 <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">rational</span></tt> 類型。測試代碼如下：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">rational</span> <span class="n">a</span> <span class="o">=</span> <span class="n">make_rational</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span> <span class="cm">/* a=1/8 */</span>
        <span class="k">struct</span> <span class="n">rational</span> <span class="n">b</span> <span class="o">=</span> <span class="n">make_rational</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span> <span class="cm">/* b=-1/8 */</span>
        <span class="n">print_rational</span><span class="p">(</span><span class="n">add_rational</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
        <span class="n">print_rational</span><span class="p">(</span><span class="n">sub_rational</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
        <span class="n">print_rational</span><span class="p">(</span><span class="n">mul_rational</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>
        <span class="n">print_rational</span><span class="p">(</span><span class="n">div_rational</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span>

        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>注意要約分為最簡分數，例如1/8和-1/8相減的打印結果應該是1/4而不是2/8，可以利用 <a class="reference internal" href="func2.html#func2-recurse"><em>遞歸</em></a> 練習題中的Euclid算法來約分。在動手編程之前先思考一下這個問題實現了什麼樣的數據抽象，抽象層應該由哪些函數組成。</p>
</li>
</ol>
</div>
<div class="section" id="struct-typetag">
<span id="id11"></span><h2>7.3. 數據類型標誌<a class="headerlink" href="#struct-typetag" title="Permalink to this headline">¶</a></h2>
<p id="index-8">在上一節中，我們通過一個複數存儲表示抽象層把 <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">complex_struct</span></tt> 結構體的存儲格式和上層的複數運算函數隔離開， <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">complex_struct</span></tt> 結構體既可以採用直角坐標也可以採用極坐標存儲。但有時候需要同時支持兩種存儲格式，比如先前已經採集了一些數據存在計算機中，有些數據是以極坐標存儲的，有些數據是以直角坐標存儲的，如果要把這些數據都存到 <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">complex_struct</span></tt> 結構體中怎麼辦？一種辦法是規定 `` struct complex_struct`` 結構體採用直角坐標格式，直角坐標的數據可以直接存入 `` struct complex_struct`` 結構體，而極坐標的數據先轉成直角坐標再存，但由於浮點數的精度有限，轉換總是會損失精度的。這裡介紹另一種辦法， <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">complex_struct</span></tt> 結構體由一個數據類型標誌和兩個浮點數組成，如果數據類型標誌為0，那麼兩個浮點數就表示直角坐標，如果數據類型標誌為1，那麼兩個浮點數就表示極坐標。這樣，直角坐標和極坐標的數據都可以適配（Adapt）到 <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">complex_struct</span></tt> 結構體中，無需轉換和損失精度：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">enum</span> <span class="n">coordinate_type</span> <span class="p">{</span> <span class="n">RECTANGULAR</span><span class="p">,</span> <span class="n">POLAR</span> <span class="p">};</span>
<span class="k">struct</span> <span class="n">complex_struct</span> <span class="p">{</span>
        <span class="k">enum</span> <span class="n">coordinate_type</span> <span class="n">t</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p id="index-9"><tt class="docutils literal"><span class="pre">enum</span></tt> 關鍵字的作用和 <tt class="docutils literal"><span class="pre">struct</span></tt> 關鍵字類似，把 <tt class="docutils literal"><span class="pre">coordinate_type</span></tt> 這個標識符定義為一個Tag， <tt class="docutils literal"><span class="pre">struct</span> <span class="pre">complex_struct</span></tt> 表示一個結構體類型，而 <tt class="docutils literal"><span class="pre">enum</span> <span class="pre">coordinate_type</span></tt> 表示一個枚舉（Enumeration）類型。枚舉類型的成員是常量，它們的值由編譯器自動分配，例如定義了上面的枚舉類型之後， <tt class="docutils literal"><span class="pre">RECTANGULAR</span></tt> 就表示常量0， <tt class="docutils literal"><span class="pre">POLAR</span></tt> 表示常量1。如果不希望從0開始分配，可以這樣定義：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">enum</span> <span class="n">coordinate_type</span> <span class="p">{</span> <span class="n">RECTANGULAR</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">POLAR</span> <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>這樣， <tt class="docutils literal"><span class="pre">RECTANGULAR</span></tt> 就表示常量1，而 <tt class="docutils literal"><span class="pre">POLAR</span></tt> 表示常量2。枚舉常量也是一種整型，其值在編譯時確定，因此也可以出現在常量表達式中，可以用於初始化全局變數或者作為case分支的判斷條件。</p>
<p>有一點需要注意，雖然結構體的成員名和變數名不在同一命名空間中，但枚舉的成員名卻和變數名在同一命名空間中，所以會出現命名衝突。例如這樣是不合法的：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4
5
6
7</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">enum</span> <span class="n">coordinate_type</span> <span class="p">{</span> <span class="n">RECTANGULAR</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">POLAR</span> <span class="p">};</span>
        <span class="kt">int</span> <span class="n">RECTANGULAR</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">RECTANGULAR</span><span class="p">,</span> <span class="n">POLAR</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><tt class="docutils literal"><span class="pre">struct</span> <span class="pre">complex_struct</span></tt> 結構體的格式變了，就需要修改複數存儲表示層的函數，但只要保持函數介面不變就不會影響到上層函數。例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">complex_struct</span> <span class="nf">make_from_real_img</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">,</span> <span class="kt">double</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">RECTANGULAR</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">complex_struct</span> <span class="nf">make_from_mag_ang</span><span class="p">(</span><span class="kt">double</span> <span class="n">r</span><span class="p">,</span> <span class="kt">double</span> <span class="n">A</span><span class="p">)</span>
<span class="p">{</span>
        <span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">z</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">POLAR</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">r</span><span class="p">;</span>
        <span class="n">z</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="n">A</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>習題</p>
<ol class="arabic">
<li><p class="first">本節只給出了 <tt class="docutils literal"><span class="pre">make_from_real_img</span></tt> 和 <tt class="docutils literal"><span class="pre">make_from_mag_ang</span></tt> 函數的實現，請讀者自己實現 <tt class="docutils literal"><span class="pre">real_part</span></tt> 、 <tt class="docutils literal"><span class="pre">img_part</span></tt> 、 <tt class="docutils literal"><span class="pre">magnitude</span></tt> 、 <tt class="docutils literal"><span class="pre">angle</span></tt> 這些函數。</p>
</li>
<li><p class="first">編譯運行下面這段程序：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="k">enum</span> <span class="n">coordinate_type</span> <span class="p">{</span> <span class="n">RECTANGULAR</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">POLAR</span> <span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
        <span class="kt">int</span> <span class="n">RECTANGULAR</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">RECTANGULAR</span><span class="p">,</span> <span class="n">POLAR</span><span class="p">);</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</li>
</ol>
<p>結果是什麼？並解釋一下為什麼是這樣的結果。</p>
</div>
<div class="section" id="id12">
<h2>7.4. 嵌套結構體<a class="headerlink" href="#id12" title="Permalink to this headline">¶</a></h2>
<p>結構體也是一種遞歸定義：結構體的成員具有某種數據類型，而結構體本身也是一種數據類型。換句話說，結構體的成員可以是另一個結構體，即結構體可以嵌套定義。例如我們在複數的基礎上定義復平面上的線段：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3
4</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">segment</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">start</span><span class="p">;</span>
        <span class="k">struct</span> <span class="n">complex_struct</span> <span class="n">end</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>從 <a class="reference internal" href="#struct-struct"><em>復合類型與結構體</em></a> 講的Initializer的語法可以看出，Initializer也可以嵌套，因此嵌套結構體可以嵌套地初始化，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">segment</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span> <span class="p">},</span> <span class="p">{</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">6.0</span> <span class="p">}};</span>
</pre></div>
</td></tr></table></div>
<p id="index-10">也可以平坦（Flat）地初始化。例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">segment</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span><span class="p">,</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">6.0</span> <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>甚至可以把兩種方式混合使用（這樣可讀性很差，應該避免）：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">segment</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{{</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">2.0</span> <span class="p">},</span> <span class="mf">4.0</span><span class="p">,</span> <span class="mf">6.0</span> <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>利用C99的新特性也可以做Memberwise Initialization，例如 <a class="footnote-reference" href="#id14" id="id13">[4]</a> ：</p>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[4]</a></td><td>為了便於理解， <a class="reference internal" href="#struct-struct"><em>復合類型與結構體</em></a> 講的Initializer語法並沒有描述這種複雜的用法。</td></tr>
</tbody>
</table>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">segment</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span> <span class="p">.</span><span class="n">start</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="p">.</span><span class="n">end</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mf">2.0</span> <span class="p">};</span>
</pre></div>
</td></tr></table></div>
<p>訪問嵌套結構體的成員要用到多個.尾碼運算符，例如：</p>
<div class="highlight-c"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>1
2
3</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">s</span><span class="p">.</span><span class="n">start</span><span class="p">.</span><span class="n">t</span> <span class="o">=</span> <span class="n">RECTANGULAR</span><span class="p">;</span>
<span class="n">s</span><span class="p">.</span><span class="n">start</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
<span class="n">s</span><span class="p">.</span><span class="n">start</span><span class="p">.</span><span class="n">b</span> <span class="o">=</span> <span class="mf">2.0</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">7. 結構體</a><ul>
<li><a class="reference internal" href="#struct-struct">7.1. 復合類型與結構體</a></li>
<li><a class="reference internal" href="#struct-dataabstraction">7.2. 數據抽象</a></li>
<li><a class="reference internal" href="#struct-typetag">7.3. 數據類型標誌</a></li>
<li><a class="reference internal" href="#id12">7.4. 嵌套結構體</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="iter.html"
                        title="previous chapter">6. 循環語句</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="array.html"
                        title="next chapter">8. 數組</a></p>
  <h3>This Page</h3>
  <ul class="this-page-menu">
    <li><a href="../_sources/zh/struct.txt"
           rel="nofollow">Show Source</a></li>
  </ul>
<div id="searchbox" style="display: none">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    <p class="searchtip" style="font-size: 90%">
    Enter search terms or a module, class or function name.
    </p>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script><table border=0 cellspacing=0 style="color: white;">

<tr><td>
   請輸入您的email訂閲<a href="http://groups.google.com/group/learning-linux-c-cpp">本書的郵件列表</a><br/>
   (Please enter your email to subscribe to <a href="http://groups.google.com/group/learning-linux-c-cpp">this book's mailing list</a>)<br/>
   <form action="http://groups.google.com/group/learning-linux-c-cpp/boxsubscribe"><input type=text name=email><input type=submit name="sub" value="訂閲(Subscribe)"></form>
</td></tr>

<tr><td><br/>關注<a href="http://weibo.com/sansoong">我的微博</a></td></tr>

<tr><td><br/>Checkout the source from github: <a href="https://github.com/learning-linux-c-cpp/akabook">https://github.com/learning-linux-c-cpp/akabook</a></td></tr>

<tr><td>
   <br/>感謝您的慷慨捐贈！<br/>
   Thanks for your generous donation!<br/>
   <a href="http://me.alipay.com/songjinshan" target="_blank"><img src="_static/me.alipay.png" alt="捐贈"></a>
</td></tr>

</table>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="array.html" title="8. 數組"
             >next</a> |</li>
        <li class="right" >
          <a href="iter.html" title="6. 循環語句"
             >previous</a> |</li>
        <li><a href="../index.html">akabook 3.0 documentation</a> &raquo;</li>
          <li><a href="index.html" >中文版：Linux C/C++編程一站式學習</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012, Sean Soong.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>