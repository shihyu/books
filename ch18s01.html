<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>1. 最簡單的彙編程序</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch18.html" title="第 18 章 x86彙編程序基礎" /><link rel="prev" href="ch18.html" title="第 18 章 x86彙編程序基礎" /><link rel="next" href="ch18s02.html" title="2. x86的寄存器" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1. 最簡單的彙編程序</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch18.html">上一頁</a> </td><th width="60%" align="center">第 18 章 x86彙編程序基礎</th><td width="20%" align="right"> <a accesskey="n" href="ch18s02.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2769131"></a>1. 最簡單的彙編程序</h2></div></div></div><div class="example"><a id="id2769136"></a><p class="title"><b>例 18.1. 最簡單的彙編程序</b></p><div class="example-contents"><pre class="programlisting">#PURPOSE: Simple program that exits and returns a
#	  status code back to the Linux kernel
#
#INPUT:   none
#
#OUTPUT:  returns a status code. This can be viewed
#	  by typing
#
#	  echo $?
#
#	  after running the program
#
#VARIABLES:
#	  %eax holds the system call number
#	  %ebx holds the return status
#
 .section .data

 .section .text
 .globl _start
_start:
 movl $1, %eax	# this is the linux kernel command
		# number (system call) for exiting
		# a program

 movl $4, %ebx	# this is the status number we will
		# return to the operating system.
		# Change this around and it will
		# return different things to
		# echo $?

 int $0x80	# this wakes up the kernel to run
		# the exit command</pre></div></div><br class="example-break" /><p>把這個程序保存成檔案<code class="literal">hello.s</code>（彙編程序通常以<code class="literal">.s</code>作為檔案名尾碼），用彙編器（Assembler）<a id="id2769149" class="indexterm"></a><code class="literal">as</code>把彙編程序中的助記符翻譯成機器指令，生成目標檔案<code class="literal">hello.o</code>：</p><pre class="screen">$ as hello.s -o hello.o</pre><p>然後用連結器（Linker，或Link Editor）<a id="id2769187" class="indexterm"></a><code class="literal">ld</code>把目標檔案<code class="literal">hello.o</code>連結成執行檔<code class="literal">hello</code>：</p><pre class="screen">$ ld hello.o -o hello</pre><p>為什麼用彙編器翻譯成機器指令了還不行，還要有一個連結的步驟呢？連結主要有兩個作用，一是修改目標檔案中的信息，對地址做重定位，在<a class="xref" href="ch18s05.html#asm.executable">第 5.2 節 “執行檔”</a>詳細解釋，二是把多個目標檔案合併成一個執行檔，在<a class="xref" href="ch19s02.html#asmc.main">第 2 節 “<code class="literal">main</code>函數和啟動常式”</a>詳細解釋。我們這個例子雖然只有一個目標檔案，但也需要經過連結才能成為執行檔。</p><p>現在執行這個程序，它只做了一件事就是退出，退出狀態是4，<a class="xref" href="ch03s02.html#func.ourfirstfunc">第 2 節 “自定義函數”</a>講過在Shell中可以用特殊變數<code class="literal">$?</code>得到上一條命令的退出狀態：</p><pre class="screen">$ ./hello
$ echo $?
4</pre><p>所以這段彙編代碼相當於在C程序的<code class="literal">main</code>函數中<code class="literal">return 4;</code>。為什麼會相當呢？我們在<a class="xref" href="ch19s02.html#asmc.main">第 2 節 “<code class="literal">main</code>函數和啟動常式”</a>詳細解釋。</p><p>下面逐行分析這個彙編程序。首先，<code class="literal">#</code>號表示單行註釋，類似於C語言的<code class="literal">//</code>註釋。</p><pre class="programlisting"> .section .data</pre><p>彙編程序中以<code class="literal">.</code>開頭的名稱並不是指令的助記符，不會被翻譯成機器指令，而是給彙編器一些特殊指示，稱為彙編指示（Assembler Directive）<a id="id2769314" class="indexterm"></a>或偽操作（Pseudo-operation）<a id="id2769324" class="indexterm"></a>，由於它不是真正的指令所以加個“<span class="quote">偽</span>”字。<code class="literal">.section</code>指示把代碼劃分成若干個段（Section）<a id="id2769345" class="indexterm"></a>，程序被操作系統加載執行時，每個段被加載到不同的地址，操作系統對不同的頁面設置不同的讀、寫、執行權限。<code class="literal">.data</code>段保存程序的數據，是可讀可寫的，相當於C程序的全局變數。本程序中沒有定義數據，所以<code class="literal">.data</code>段是空的。</p><pre class="programlisting"> .section .text</pre><p><code class="literal">.text</code>段保存代碼，是隻讀和可執行的，後面那些指令都屬於<code class="literal">.text</code>段。</p><pre class="programlisting"> .globl _start</pre><p><code class="literal">_start</code>是一個符號（Symbol）<a id="id2769400" class="indexterm"></a>，符號在彙編程序中代表一個地址，可以用在指令中，彙編程序經過彙編器的處理之後，所有的符號都被替換成它所代表的地址值。在C語言中我們通過變數名訪問一個變數，其實就是讀寫某個地址的內存單元，我們通過函數名調用一個函數，其實就是跳轉到該函數第一條指令所在的地址，所以變數名和函數名都是符號，本質上是代表內存地址的。</p><p><code class="literal">.globl</code>指示告訴彙編器，<code class="literal">_start</code>這個符號要被連結器用到，所以要在目標檔案的符號表中標記它是一個全局符號（在<a class="xref" href="ch18s05.html#asm.relocatable">第 5.1 節 “目標檔案”</a>詳細解釋）。<code class="literal">_start</code>就像C程序的<code class="literal">main</code>函數一樣特殊，是整個程序的入口，連結器在連結時會查找目標檔案中的<code class="literal">_start</code>符號代表的地址，把它設置為整個程序的入口地址，所以每個彙編程序都要提供一個<code class="literal">_start</code>符號並且用<code class="literal">.globl</code>聲明。如果一個符號沒有用<code class="literal">.globl</code>聲明，就表示這個符號不會被連結器用到。</p><pre class="programlisting">_start:</pre><p>這裡定義了<code class="literal">_start</code>符號，彙編器在翻譯彙編程序時會計算每個數據對象和每條指令的地址，當看到這樣一個符號定義時，就把它後面一條指令的地址作為這個符號所代表的地址。而<code class="literal">_start</code>這個符號又比較特殊，它所代表的地址是整個程序的入口地址，所以下一條指令<code class="literal">movl $1, %eax</code>就成了程序中第一條被執行的指令。</p><pre class="programlisting"> movl $1, %eax</pre><p>這是一條數據傳送指令，這條指令要求CPU內部產生一個數字1並保存到<code class="literal">eax</code>寄存器中。<code class="literal">mov</code>的尾碼l表示long，說明是32位的傳送指令。這條指令不要求CPU讀內存，1這個數是在CPU內部產生的，稱為立即數（Immediate）<a id="id2769538" class="indexterm"></a>。在彙編程序中，立即數前面要加$，寄存器名前面要加%，以便跟符號名區分開。以後我們會看到<code class="literal">mov</code>指令還有另外幾種形式，但數據傳送方向都是一樣的，第一個操作數總是源操作數，第二個操作數總是目標操作數。</p><pre class="programlisting"> movl $4, %ebx</pre><p>和上一條指令類似，生成一個立即數4並保存到<code class="literal">ebx</code>寄存器中。</p><pre class="programlisting"> int $0x80</pre><p>前兩條指令都是為這條指令做準備的，執行這條指令時發生以下動作：</p><div class="orderedlist"><ol type="1"><li><p><code class="literal">int</code>指令稱為軟中斷指令，可以用這條指令故意產生一個異常，上一章講過，異常的處理和中斷類似，CPU從用戶模式切換到特權模式，然後跳轉到內核代碼中執行異常處理程序。</p></li><li><p><code class="literal">int</code>指令中的立即數0x80是一個參數，在異常處理程序中要根據這個參數決定如何處理，在Linux內核中<code class="literal">int $0x80</code>這種異常稱為系統調用（System Call）<a id="id2769615" class="indexterm"></a>。內核提供了很多系統服務供用戶程序使用，但這些系統服務不能像庫函數（比如<code class="literal">printf</code>）那樣調用，因為在執行用戶程序時CPU處于用戶模式，不能直接調用內核函數，所以需要通過系統調用切換CPU模式，經由異常處理程序進入內核，用戶程序只能通過寄存器傳幾個參數，之後就要按內核設計好的代碼路線走，而不能由用戶程序隨心所欲，想調哪個內核函數就調哪個內核函數，這樣可以保證系統服務被安全地調用。在調用結束之後，CPU再切換回用戶模式，繼續執行<code class="literal">int $0x80</code>的下一條指令，在用戶程序看來就像函數調用和返回一樣。</p></li><li><p><code class="literal">eax</code>和<code class="literal">ebx</code>的值是傳遞給系統調用的兩個參數。<code class="literal">eax</code>的值是系統調用號，Linux的各種系統調用都是由<code class="literal">int $0x80</code>指令引發的，內核需要通過<code class="literal">eax</code>判斷用戶要調哪個系統調用，<code class="literal">_exit</code>的系統調用號是1。<code class="literal">ebx</code>的值是傳給<code class="literal">_exit</code>的參數，表示退出狀態。大多數系統調用完成之後會返回用戶空間繼續執行後面的指令，而<code class="literal">_exit</code>系統調用比較特殊，它會終止掉當前進程，而不是返回用戶空間繼續執行。</p></li></ol></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">x86彙編的兩種語法：intel語法和AT&amp;T語法</h3><p>x86彙編一直存在兩種不同的語法，在intel的官方文檔中使用intel語法，Windows也使用intel語法，而UNIX平台的彙編器一直使用AT&amp;T語法，所以本書使用AT&amp;T語法。<code class="literal">movl %edx,%eax</code>這條指令如果用intel語法來寫，就是<code class="literal">mov eax,edx</code>，寄存器名不加%號，源操作數和目標操作數的位置互換，字長也不是用指令的尾碼l表示而是用另外的方式表示。本書不詳細討論這兩種語法之間的區別，讀者可以參考<a class="xref" href="bi01.html#bibli.assemblyhowto" title="Linux Assembly HOWTO（http://tldp.org/HOWTO/Assembly-HOWTO/）很不幸，目前tldp.org被我們偉大的防火牆屏蔽了，請自己找代理訪問">[<abbr class="abbrev">AssemblyHOWTO</abbr>]</a>。</p><p>介紹x86彙編的書很多，UNIX平台的書都採用AT&amp;T語法，例如<a class="xref" href="bi01.html#bibli.groundup" title="Programming from the Ground Up: An Introduction to Programming using Linux Assembly Language">[<abbr class="abbrev">GroudUp</abbr>]</a>，其它書一般採用intel語法，例如<a class="xref" href="bi01.html#bibli.x86assembly" title="Introduction to 80x86 Assembly Language and Computer Architecture">[<abbr class="abbrev">x86Assembly</abbr>]</a>。</p></div><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2769776"></a>習題</h3></div></div></div><p>1、把本節例子中的<code class="literal">int $0x80</code>指令去掉，彙編、連結也能通過，但是執行的時候出現段錯誤，你能解釋其原因嗎？</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch18.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch18.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch18s02.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">第 18 章 x86彙編程序基礎 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 2. x86的寄存器</td></tr></table></div></body></html>
