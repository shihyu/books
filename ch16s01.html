<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>1. 位運算</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch16.html" title="第 16 章 運算符詳解" /><link rel="prev" href="ch16.html" title="第 16 章 運算符詳解" /><link rel="next" href="ch16s02.html" title="2. 其它運算符" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1. 位運算</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch16.html">上一頁</a> </td><th width="60%" align="center">第 16 章 運算符詳解</th><td width="20%" align="right"> <a accesskey="n" href="ch16s02.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2761666"></a>1. 位運算</h2></div></div></div><p>整數在計算機中用二進制的位來表示，C語言提供一些運算符可以直接操作整數中的位，稱為位運算，這些運算符的操作數都必須是整型的。在以後的學習中你會發現，有些信息利用整數中的某幾個位來存儲，要訪問這些位，僅僅有對整數的操作是不夠的，必須借助位運算，例如<a class="xref" href="apas02.html#app-encoding.utf8">第 2 節 “Unicode和UTF-8”</a>介紹的UTF-8編碼就是如此，學完本節之後你應該能自己寫出UTF-8的編碼和解碼程序。本節首先介紹各種位運算符，然後介紹與位運算有關的編程技巧。</p><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2761062"></a>1.1. 按位與、或、異或、取反運算</h3></div></div></div><p>在<a class="xref" href="ch04s03.html#cond.bool">第 3 節 “布爾代數”</a>講過邏輯與、或、非運算，並列出了真值表，對於整數中的位也可以做與、或、非運算，C語言提供了按位與（Bitwise AND）<a id="id2761684" class="indexterm"></a>運算符&amp;、按位或（Bitwise OR）<a id="id2761693" class="indexterm"></a>運算符|和按位取反（Bitwise NOT）<a id="id2761700" class="indexterm"></a>運算符~，此外還有按位異或（Bitwise XOR）<a id="id2761708" class="indexterm"></a>運算符^，我們在<a class="xref" href="ch14s01.html#number.binary">第 1 節 “為什麼計算機用二進制計數”</a>講過異或運算。下面用二進制的形式舉幾個例子。</p><div class="figure"><a id="id2761724"></a><p class="title"><b>圖 16.1. 位運算</b></p><div class="figure-contents"><div><img src="images/op.bitwise.png" alt="位運算" /></div></div></div><br class="figure-break" /><p>注意，&amp;、|、^運算符都是要做Usual Arithmetic Conversion的（其中有一步是Integer Promotion），~運算符也要做Integer Promotion，所以在C語言中其實並不存在8位整數的位運算，操作數在做位運算之前都至少被提升為<code class="literal">int</code>型了，上面用8位整數舉例只是為了書寫方便。比如：</p><pre class="programlisting">unsigned char c = 0xfc;
unsigned int i = ~c;</pre><p>計算過程是這樣的：常量0xfc是<code class="literal">int</code>型的，賦給<code class="literal">c</code>要轉成<code class="literal">unsigned char</code>，值不變；<code class="literal">c</code>的十六進製表示是fc，計算<code class="literal">~c</code>時先提升為整型（000000fc）然後取反，最後結果是ffffff03。注意，如果把<code class="literal">~c</code>看成是8位整數的取反，最後結果就得3了，這就錯了。為了避免出錯，一是儘量避免不同類型之間的賦值，二是每一步計算都要按上一章講的類型轉換規則仔細檢查。</p></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2761805"></a>1.2. 移位運算</h3></div></div></div><p>移位運算符（Bitwise Shift）<a id="id2761813" class="indexterm"></a>包括左移&lt;&lt;和右移&gt;&gt;。左移將一個整數的各二進制位全部左移若干位，例如0xcfffffff3&lt;&lt;2得到0x3fffffcc：</p><div class="figure"><a id="id2761824"></a><p class="title"><b>圖 16.2. 左移運算</b></p><div class="figure-contents"><div><img src="images/op.shiftleft.png" alt="左移運算" /></div></div></div><br class="figure-break" /><p>最高兩位的11被移出去了，最低兩位又補了兩個0，其它位依次左移兩位。但要注意，移動的位數必須小於左操作數的總位數，比如上面的例子，左邊是<code class="literal">unsigned int</code>型，如果左移的位數大於等於32位，則結果是Undefined。移位運算符不同於+ - * / ==等運算符，兩邊操作數的類型不要求一致，但兩邊操作數都要做Integer Promotion，整個表達式的類型和左操作數提升後的類型相同。</p><p>複習一下<a class="xref" href="ch14s02.html#number.convert">第 2 節 “不同進制之間的換算”</a>講過的知識可以得出結論，<span class="emphasis"><em>在一定的取值範圍內，將一個整數左移1位相當於乘以2</em></span>。比如二進制11（十進制3）左移一位變成110，就是6，再左移一位變成1100，就是12。讀者可以自己驗證這條規律對有符號數和無符號數都成立，對負數也成立。當然，如果左移改變了最高位（符號位），那麼結果肯定不是乘以2了，所以我加了個前提“<span class="quote">在一定的取值範圍內</span>”。由於計算機做移位比做乘法快得多，編譯器可以利用這一點做優化，比如看到原始碼中有<code class="literal">i * 8</code>，可以編譯成移位指令而不是乘法指令。</p><p>當操作數是無符號數時，右移運算的規則和左移類似，例如0xcfffffff3&gt;&gt;2得到0x33fffffc：</p><div class="figure"><a id="id2761899"></a><p class="title"><b>圖 16.3. 右移運算</b></p><div class="figure-contents"><div><img src="images/op.shiftright.png" alt="右移運算" /></div></div></div><br class="figure-break" /><p>最低兩位的11被移出去了，最高兩位又補了兩個0，其它位依次右移兩位。和左移類似，移動的位數也必須小於左操作數的總位數，否則結果是Undefined。在一定的取值範圍內，將一個整數右移1位相當於除以2，小數部分截掉。</p><p>當操作數是有符號數時，右移運算的規則比較複雜：</p><div class="itemizedlist"><ul type="disc"><li><p>如果是正數，那麼高位移入0</p></li><li><p>如果是負數，那麼高位移入1還是0不一定，這是Implementation-defined的。對於x86平台的<code class="literal">gcc</code>編譯器，最高位移入1，也就是仍保持負數的符號位，這種處理方式對負數仍然保持了“<span class="quote">右移1位相當於除以2</span>”的性質。</p></li></ul></div><p>綜上所述，由於類型轉換和移位等問題，用有符號數做位運算是很不方便的，所以，<span class="emphasis"><em>建議只對無符號數做位運算，以減少出錯的可能</em></span>。</p><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h4 class="title"><a id="id2761960"></a>習題</h4></div></div></div><p>1、下面兩行<code class="literal">printf</code>打印的結果有何不同？請讀者比較分析一下。<code class="literal">%x</code>轉換說明的含義詳見<a class="xref" href="ch25s02.html#stdlib.formatio">第 2.9 節 “格式化I/O函數”</a>。</p><pre class="programlisting">int i = 0xcffffff3;
printf("%x\n", 0xcffffff3&gt;&gt;2);
printf("%x\n", i&gt;&gt;2);</pre></div></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2761995"></a>1.3. 掩碼</h3></div></div></div><p>如果要對一個整數中的某些位進行操作，怎樣表示這些位在整數中的位置呢？可以用掩碼（Mask）<a id="id2762004" class="indexterm"></a>來表示。比如掩碼0x0000ff00表示對一個32位整數的8~15位進行操作，舉例如下。</p><p>1、取出8~15位。</p><pre class="programlisting">unsigned int a, b, mask = 0x0000ff00;
a = 0x12345678;
b = (a &amp; mask) &gt;&gt; 8; /* 0x00000056 */</pre><p>這樣也可以達到同樣的效果：</p><pre class="programlisting">b = (a &gt;&gt; 8) &amp; ~(~0U &lt;&lt; 8);</pre><p>2、將8~15位清0。</p><pre class="programlisting">unsigned int a, b, mask = 0x0000ff00;
a = 0x12345678;
b = a &amp; ~mask; /* 0x12340078 */</pre><p>3、將8~15位置1。</p><pre class="programlisting">unsigned int a, b, mask = 0x0000ff00;
a = 0x12345678;
b = a | mask; /* 0x1234ff78 */</pre><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h4 class="title"><a id="id2762050"></a>習題</h4></div></div></div><p>1、統計一個無符號整數的二進製表示中1的個數，函數原型是<code class="literal">int countbit(unsigned int x);</code>。</p><p>2、用位操作實現無符號整數的乘法運算，函數原型是<code class="literal">unsigned int multiply(unsigned int x, unsigned int y);</code>。例如：(11011)<sub>2</sub>×(10010)<sub>2</sub>=((11011)<sub>2</sub>&lt;&lt;1)+((11011)<sub>2</sub>&lt;&lt;4)。</p><p>3、對一個32位無符號整數做循環右移，函數原型是<code class="literal">unsigned int rotate_right(unsigned int x);</code>。所謂循環右移就是把低位移出去的部分再補到高位上去，例如<code class="literal">rotate_right(0xdeadbeef, 16)</code>的值應該是0xefdeadbe。</p></div></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2762114"></a>1.4. 異或運算的一些特性</h3></div></div></div><p>1、一個數和自己做異或的結果是0。如果需要一個常數0，x86平台的編譯器可能會生成這樣的指令：<code class="literal">xorl %eax, %eax</code>。不管<code class="literal">eax</code>寄存器裡的值原來是多少，做異或運算都能得到0，這條指令比同樣效果的<code class="literal">movl $0, %eax</code>指令快，因為前者只需要在CPU內部計算，而後者需要訪問內存，在下一章<a class="xref" href="ch17s05.html#arch.memh">第 5 節 “Memory Hierarchy”</a>詳細介紹。</p><p>2、從異或的真值表可以看出，不管是0還是1，和0做異或保持原值不變，和1做異或得到原值的相反值。可以利用這個特性配合掩碼實現某些位的翻轉，例如：</p><pre class="programlisting">unsigned int a, b, mask = 1U &lt;&lt; 6;
a = 0x12345678;
b = a ^ mask; /* flip the 6th bit */</pre><p>3、如果a<sub>1</sub> ^ a<sub>2</sub> ^ a<sub>3</sub> ^ ... ^ a<sub>n</sub>的結果是1，則表示a<sub>1</sub>、a<sub>2</sub>、a<sub>3</sub>...a<sub>n</sub>之中1的個數為奇數個，否則為偶數個。這條性質可用於奇偶校驗（Parity Check）<a id="id2762202" class="indexterm"></a>，比如在串口通信過程中，每個位元組的數據都計算一個校驗位，數據和校驗位一起發送出去，這樣接收方可以根據校驗位粗略地判斷接收到的數據是否有誤。</p><p>4、x ^ x ^ y == y，因為x ^ x == 0，0 ^ y == y。這個性質有什麼用呢？我們來看這樣一個問題：交換兩個變數的值，不得借助額外的存儲空間，所以就不能採用<code class="literal">temp = a; a = b; b = temp;</code>的辦法了。利用位運算可以這樣做交換：</p><pre class="programlisting">a = a ^ b;
b = b ^ a;
a = a ^ b;</pre><p>分析一下這個過程。為了避免混淆，把a和b的初值分別記為a<sub>0</sub>和b<sub>0</sub>。第一行，<code class="literal">a = a<sub>0</sub> ^ b<sub>0</sub></code>；第二行，把a的新值代入，得到<code class="literal">b = b<sub>0</sub> ^ a<sub>0</sub> ^ b<sub>0</sub></code>，等號右邊的b<sub>0</sub>相當於上面公式中的x，a<sub>0</sub>相當於y，所以結果為a<sub>0</sub>；第三行，把a和b的新值代入，得到<code class="literal">a = a<sub>0</sub> ^ b<sub>0</sub> ^ a<sub>0</sub></code>，結果為b<sub>0</sub>。注意這個過程不能把同一個變數自己跟自己交換，而利用中間變數<code class="literal">temp</code>則可以交換。</p><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h4 class="title"><a id="id2762311"></a>習題</h4></div></div></div><p>1、請在網上查找有關RAID（Redundant Array of Independent Disks，獨立磁碟冗餘陣列）<a id="id2762322" class="indexterm"></a>的資料，理解其實現原理，其實就是利用了本節的性質3和4。</p><p>2、交換兩個變數的值，不得借助額外的存儲空間，除了本節講的方法之外你還能想出什麼方法？本節講的方法不能把同一個變數自己跟自己交換，你的方法有沒有什麼侷限性？</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch16.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch16.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch16s02.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">第 16 章 運算符詳解 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 2. 其它運算符</td></tr></table></div></body></html>
