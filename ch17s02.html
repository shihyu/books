<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>2. CPU</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch17.html" title="第 17 章 計算機體繫結構基礎" /><link rel="prev" href="ch17s01.html" title="1. 內存與地址" /><link rel="next" href="ch17s03.html" title="3. 設備" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2. CPU</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch17s01.html">上一頁</a> </td><th width="60%" align="center">第 17 章 計算機體繫結構基礎</th><td width="20%" align="right"> <a accesskey="n" href="ch17s03.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2766148"></a>2. CPU</h2></div></div></div><p>CPU總是周而複始地做同一件事：從內存取指令，然後解釋執行它，然後再取下一條指令，再解釋執行。CPU最核心的功能單元包括：</p><div class="itemizedlist"><ul type="disc"><li><p>寄存器（Register）<a id="id2766167" class="indexterm"></a>，是CPU內部的高速存儲器，像內存一樣可以存取數據，但比訪問內存快得多。隨後的幾章我們會詳細介紹x86的寄存器<code class="literal">eax</code>、<code class="literal">esp</code>、<code class="literal">eip</code>等等，有些寄存器只能用於某種特定的用途，比如<code class="literal">eip</code>用作程序計數器，這稱為特殊寄存器（Special-purpose Register）<a id="id2766202" class="indexterm"></a>，而另外一些寄存器可以用在各種運算和讀寫內存的指令中，比如<code class="literal">eax</code>寄存器，這稱為通用寄存器（General-purpose Register）<a id="id2766217" class="indexterm"></a>。</p></li><li><p>程序計數器（PC，Program Counter）<a id="id2766230" class="indexterm"></a>，是一種特殊寄存器，保存着CPU取下一條指令的地址，CPU按程序計數器保存的地址去內存中取指令然後解釋執行，這時程序計數器保存的地址會自動加上該指令的長度，指向內存中的下一條指令。</p></li><li><p>指令譯碼器（Instruction Decoder）<a id="id2766246" class="indexterm"></a>。CPU取上來的指令由若干個位元組組成，這些位元組中有些位表示內存地址，有些位表示寄存器編號，有些位表示這種指令做什麼操作，是加減乘除還是讀寫內存，指令譯碼器負責解釋這條指令的含義，然後調動相應的執行單元去執行它。</p></li><li><p>算術邏輯單元（ALU，Arithmetic and Logic Unit）。如果譯碼器將一條指令解釋為運算指令，就調動算術邏輯單元去做運算，比如加減乘除、位運算、邏輯運算。指令中會指示運算結果保存到哪裡，可能保存到寄存器中，也可能保存到內存中。</p></li><li><p>地址和數據匯流排（Bus）<a id="id2766284" class="indexterm"></a>。CPU和內存之間用地址匯流排、數據匯流排和控制綫連接起來，每條線上有1和0兩種狀態。如果在執行指令過程中需要訪問內存，比如從內存讀一個數到寄存器，執行過程可以想像成這樣：</p><div class="figure"><a id="id2766295"></a><p class="title"><b>圖 17.2. 訪問內存讀數據的過程</b></p><div class="figure-contents"><div><img src="images/arch.readmem.png" alt="訪問內存讀數據的過程" /></div></div></div><br class="figure-break" /><div class="orderedlist"><ol type="1"><li><p>CPU內部將寄存器對接到數據匯流排上，使寄存器的每一位對接到一條數據綫，等待接收數據。</p></li><li><p>CPU通過控制綫發一個讀請求，並且將內存地址通過地址綫發給內存。</p></li><li><p>內存收到地址和讀請求之後，將相應的內存單元對接到數據匯流排的另一端，這樣，內存單元每一位的1或0狀態通過一條數據綫到達CPU寄存器中相應的位，就完成了數據傳送。</p></li></ol></div><p>往內存裡寫數據的過程與此類似，只是數據線上的傳輸方向相反。</p></li></ul></div><p>上圖中畫了32條地址綫和32條數據綫，CPU寄存器也是32位，可以說這種體繫結構是32位的，比如x86就是這樣的體繫結構，目前主流的處理器是32位或64位的。地址綫、數據綫和CPU寄存器的位數通常是一致的，從上圖可以看出數據綫和CPU寄存器的位數應該一致，另外有些寄存器（比如程序計數器）需要保存一個內存地址，因而地址綫和CPU寄存器的位數也應該一致。處理器的位數也稱為字長，字（Word）<a id="id2766367" class="indexterm"></a>這個概念用得比較混亂，在有些上下文中指16位，在有些上下文中指32位（這種情況下16位被稱為半字Half Word<a id="id2766376" class="indexterm"></a>），在有些上下文中指處理器的字長，如果處理器是32位那麼一個字就是32位，如果處理器是64位那麼一個字就是64位。32位計算機有32條地址綫，地址空間（Address Space）<a id="id2766387" class="indexterm"></a>從0x00000000到0xffffffff，共4GB，而64位計算機有更大的地址空間。</p><p>最後還要說明一點，本節所說的地址綫、數據綫是指CPU的內匯流排，是直接和CPU的執行單元相連的，內匯流排經過MMU和匯流排介面的轉換之後引出到晶片引腳才是外匯流排，外地址綫和外數據綫的位數都有可能和內匯流排不同，例如32位處理器的外地址匯流排可定址的空間可以大於4GB，到<a class="xref" href="ch17s04.html#arch.mmu">第 4 節 “MMU”</a>再詳細解釋。</p><p>我們結合<a class="xref" href="intro.program.html#intro.instruction">表 1.1 “一個語句的三種表示”</a>看一下CPU取指執行的過程。</p><div class="figure"><a id="id2766429"></a><p class="title"><b>圖 17.3. CPU的取指執行過程</b></p><div class="figure-contents"><div><img src="images/arch.von.png" alt="CPU的取指執行過程" /></div></div></div><br class="figure-break" /><div class="orderedlist"><ol type="1"><li><p><code class="literal"><code class="literal">eip</code>寄存器指向地址0x80483a2，CPU從這裡開始取一條5個位元組的指令，然後<code class="literal">eip</code>寄存器指向下一條指令的起始地址0x80483a7。</code></p></li><li><p>CPU對這5個位元組譯碼，得知這條指令要求從地址0x804a01c開始取4個位元組保存到<code class="literal">eax</code>寄存器。</p></li><li><p>執行指令，讀內存，取上來的數是3，保存到<code class="literal">eax</code>寄存器。注意，地址0x804a01c~0x804a01f裡存儲的四個位元組不能按地址從低到高的順序看成0x03000000，而要按地址從高到低的順序看成0x00000003。也就是說，對於多位元組的整數類型，低地址保存的是整數的低位，這稱為小端（Little Endian）<a id="id2766497" class="indexterm"></a>位元組序（Byte Order）<a id="id2766505" class="indexterm"></a>。x86平台是小端位元組序的，而另外一些平台規定低地址保存整數的高位，稱為大端（Big Endian）<a id="id2766514" class="indexterm"></a>位元組序。</p></li><li><p>CPU從<code class="literal">eip</code>寄存器指向的地址取一條3個位元組的指令，然後<code class="literal">eip</code>寄存器指向下一條指令的起始地址0x80483aa。</p></li><li><p>CPU對這3個位元組譯碼，得知這條指令要求把<code class="literal">eax</code>寄存器的值加1，結果仍保存到<code class="literal">eax</code>寄存器。</p></li><li><p>執行指令，現在<code class="literal">eax</code>寄存器中的數是4。</p></li><li><p>CPU從<code class="literal">eip</code>寄存器指向的地址取一條5個位元組的指令，然後<code class="literal">eip</code>寄存器指向下一條指令的起始地址0x80483af。</p></li><li><p>CPU對這5個位元組譯碼，得知這條指令要求把<code class="literal">eax</code>寄存器的值保存到從地址0x804a018開始的4個位元組。</p></li><li><p>執行指令，把4這個值保存到從地址0x804a018開始的4個位元組（按小端位元組序保存）。</p></li></ol></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch17s01.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch17.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch17s03.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">1. 內存與地址 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 3. 設備</td></tr></table></div></body></html>
