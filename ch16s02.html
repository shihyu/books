<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>2. 其它運算符</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch16.html" title="第 16 章 運算符詳解" /><link rel="prev" href="ch16s01.html" title="1. 位運算" /><link rel="next" href="ch16s03.html" title="3. Side Effect與Sequence Point" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2. 其它運算符</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch16s01.html">上一頁</a> </td><th width="60%" align="center">第 16 章 運算符詳解</th><td width="20%" align="right"> <a accesskey="n" href="ch16s03.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2762347"></a>2. 其它運算符</h2></div></div></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2762352"></a>2.1. 復合賦值運算符</h3></div></div></div><p>復合賦值運算符（Compound Assignment Operator）<a id="id2762363" class="indexterm"></a>包括<code class="literal">*=</code> <code class="literal">/=</code> <code class="literal">%=</code> <code class="literal">+=</code> <code class="literal">-=</code> <code class="literal">&lt;&lt;=</code> <code class="literal">&gt;&gt;=</code> <code class="literal">&amp;=</code> <code class="literal">^=</code> <code class="literal">|=</code>，一邊做運算一邊賦值。例如<code class="literal">a += 1</code>相當於<code class="literal">a = a + 1</code>。但有一點細微的差別，前者對錶達式<code class="literal">a</code>只求值一次，而後者求值兩次，如果<code class="literal">a</code>是一個複雜的表達式，求值一次和求值兩次的效率是不同的，例如<code class="literal">a[i+j] += 1</code>和<code class="literal">a[i+j] = a[i+j] + 1</code>。那麼僅僅是效率上的差別嗎？對於沒有Side Effect的表達式，求值一次和求值兩次的結果是一樣的，但對於有Side Effect的表達式則不一定，例如<code class="literal">a[foo()] += 1</code>和<code class="literal">a[foo()] = a[foo()] + 1</code>，如果<code class="literal">foo()</code>函數調用有Side Effect，比如會打印一條消息，那麼前者只打印一次，而後者打印兩次。</p><p>在<a class="xref" href="ch06s03.html#iter.for">第 3 節 “for語句”</a>講自增、自減運算符時說<code class="literal">++i</code>相當於<code class="literal">i = i + 1</code>，其實更準確地說應該是等價于<code class="literal">i += 1</code>，表達式<code class="literal">i</code>只求值一次，而<code class="literal">--i</code>等價于<code class="literal">i -= 1</code>。</p></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2762537"></a>2.2. 條件運算符</h3></div></div></div><p>條件運算符（Conditional Operator）<a id="id2762544" class="indexterm"></a>是C語言中唯一一個三目運算符（Ternary Operator）<a id="id2762552" class="indexterm"></a>，帶三個操作數，它的形式是<code class="literal">表達式1 ? 表達式2 : 表達式3</code>，這個運算符所組成的整個表達式的值等於表達式2或表達式3的值，取決於表達式1的值是否為真，可以把它想像成這樣的函數：</p><pre class="programlisting">if (表達式1)
	return 表達式2;
else
	return 表達式3;</pre><p>表達式1相當於<code class="literal">if</code>語句的控製表達式，因此它的值必須是標量類型，而表達式2和3相當於同一個函數在不同情況下的返回值，因此它們的類型要求一致，也要做Usual Arithmetic Conversion。</p><p>下面舉個例子，定義一個函數求兩個參數中較大的一個。</p><pre class="programlisting">int max(int a, int b)
{
	return (a &gt; b) ? a : b;
}</pre></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2762598"></a>2.3. 逗號運算符</h3></div></div></div><p>逗號運算符（Comma Operator）<a id="id2762605" class="indexterm"></a>也是一種雙目運算符，它的形式是<code class="literal">表達式1, 表達式2</code>，兩個表達式不要求類型一致，左邊的表達式1先求值，求完了直接把值丟掉，再求右邊表達式2的值作為整個表達式的值。逗號運算符是左結合的，類似於+ - * /運算符，根據組合規則可以寫出<code class="literal">表達式1, 表達式2, 表達式3, ..., 表達式n</code>這種形式，<code class="literal">表達式1, 表達式2</code>可以看作一個子表達式，先求表達式1的值，然後求表達式2的值作為這個子表達式的值，然後這個值再和表達式3組成一個更大的表達式，求表達式3的值作為這個更大的表達式的值，依此類推，整個計算過程就是從左到右依次求值，最後一個表達式的值成為整個表達式的值。</p><p>注意，函數調用時各實參之間也是用逗號隔開，這種逗號是分隔符而不是逗號運算符。但可以這樣使用逗號運算符：</p><pre class="programlisting">f(a, (t=3, t+2), c)</pre><p>傳給函數<code class="literal">f</code>的參數有三個，其中第二個參數的值是表達式<code class="literal">t+2</code>的值。</p></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2762676"></a>2.4. sizeof運算符與typedef類型聲明</h3></div></div></div><p><code class="literal">sizeof</code>是一個很特殊的運算符，它有兩種形式：“<span class="quote">sizeof 表達式</span>”和“<span class="quote">sizeof(類型名)</span>”。這個運算符很特殊，“<span class="quote">sizeof 表達式</span>”中的子表達式並不求值，而只是根據類型轉換規則求得子表達式的類型，然後把這種類型所占的位元組數作為整個表達式的值。有些人喜歡寫成“<span class="quote">sizeof(表達式)</span>”的形式也可以，這裡的括號和<code class="literal">return(1);</code>的括號一樣，不起任何作用。但另外一種形式“<span class="quote">sizeof(類型名)</span>”的括號則是必須寫的，整個表達式的值也是這種類型所占的位元組數。</p><p>比如用<code class="literal">sizeof</code>運算符求一個數組的長度：</p><pre class="programlisting">int a[12];
printf("%d\n", sizeof a/sizeof a[0]);</pre><p>在上面這個例子中，由於<code class="literal">sizeof 表達式</code>中的子表達式不需要求值，所以不需要到運行時才計算，事實上在編譯時就知道<code class="literal">sizeof a</code>的值是48，<code class="literal">sizeof a[0]</code>的值是4，所以在編譯時就已經把<code class="literal">sizeof a/sizeof a[0]</code>替換成常量12了，這是一個常量表達式。</p><p><code class="literal">sizeof</code>運算符的結果是<code class="literal">size_t</code>類型的，這個類型定義在<code class="literal">stddef.h</code>標頭檔中，不過你的代碼中只要不出現<code class="literal">size_t</code>這個類型名就不用包含這個標頭檔，比如像上面的例子就不用包含這個標頭檔。C標準規定<code class="literal">size_t</code>是一種無符號整型，編譯器可以用<code class="literal">typedef</code>做一個類型聲明：</p><pre class="programlisting">typedef unsigned long size_t;</pre><p>那麼<code class="literal">size_t</code>就代表<code class="literal">unsigned long</code>型。不同平台的編譯器可能會根據自己平台的具體情況定義<code class="literal">size_t</code>所代表的類型，比如有的平台定義為<code class="literal">unsigned long</code>型，有的平台定義為<code class="literal">unsigned long long</code>型，C標準規定<code class="literal">size_t</code>這個名字就是為了隱藏這些細節，使代碼具有可移植性。所以注意不要把<code class="literal">size_t</code>類型和它所代表的真實類型混用，例如：</p><pre class="programlisting">unsigned long x;
size_t y;
x = y;</pre><p>如果在一種ILP32平台上定義<code class="literal">size_t</code>代表<code class="literal">unsigned long long</code>型，這段代碼把<code class="literal">y</code>賦給<code class="literal">x</code>時就把高位截掉了，結果可能是錯的。</p><p><code class="literal">typedef</code>這個關鍵字用於給某種類型起個新名字，比如上面的<code class="literal">typedef</code>聲明可以這麼看：去掉<code class="literal">typedef</code>就成了一個變數聲明<code class="literal">unsigned long size_t;</code>，<code class="literal">size_t</code>是一個變數名，類型是<code class="literal">unsigned long</code>，那麼加上<code class="literal">typedef</code>之後，<code class="literal">size_t</code>就是一個類型名，就代表<code class="literal">unsigned long</code>類型。再舉個例子：</p><pre class="programlisting">typedef char array_t[10];
array_t a;</pre><p>這相當於聲明<code class="literal">char a[10];</code>。類型名也遵循標識符的命名規則，並且通常加個<code class="literal">_t</code>尾碼表示Type。</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch16s01.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch16.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch16s03.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">1. 位運算 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 3. Side Effect與Sequence Point</td></tr></table></div></body></html>
