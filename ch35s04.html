<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>4. 編程練習</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch35.html" title="第 35 章 綫程" /><link rel="prev" href="ch35s03.html" title="3. 綫程間同步" /><link rel="next" href="ch36.html" title="第 36 章 TCP/IP協議基礎" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4. 編程練習</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch35s03.html">上一頁</a> </td><th width="60%" align="center">第 35 章 綫程</th><td width="20%" align="right"> <a accesskey="n" href="ch36.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2897498"></a>4. 編程練習</h2></div></div></div><p>哲學家就餐問題。這是由計算機科學家Dijkstra提出的經典死鎖場景。</p><p>原版的故事裡有五個哲學家(不過我們寫的程序可以有N個哲學家)，這些哲學家們只做兩件事－－思考和吃飯，他們思考的時候不需要任何共享資源，但是吃飯的時候就必須使用餐具，而餐桌上的餐具是有限的，原版的故事裡，餐具是叉子，吃飯的時候要用兩把叉子把麵條從碗裡撈出來。很顯然把叉子換成筷子會更合理，所以：一個哲學家需要兩根筷子才能吃飯。</p><p>現在引入問題的關鍵：這些哲學家很窮，只買得起五根筷子。他們坐成一圈，兩個人的中間放一根筷子。哲學家吃飯的時候必須同時得到左手邊和右手邊的筷子。如果他身邊的任何一位正在使用筷子，那他只有等着。</p><p>假設哲學家的編號是A、B、C、D、E，筷子編號是1、2、3、4、5，哲學家和筷子圍成一圈如下圖所示：</p><div class="figure"><a id="id2897541"></a><p class="title"><b>圖 35.2. 哲學家問題</b></p><div class="figure-contents"><div><img src="images/thread.philosopher.png" alt="哲學家問題" /></div></div></div><br class="figure-break" /><p>每個哲學家都是一個單獨的綫程，每個綫程循環做以下動作：思考rand()%10秒，然後先拿左手邊的筷子再拿右手邊的筷子（筷子這種資源可以用mutex表示），有任何一邊拿不到就一直等着，全拿到就吃飯rand()%10秒，然後放下筷子。</p><p>編寫程序仿真哲學家就餐的場景：</p><pre class="screen">Philosopher A fetches chopstick 5
Philosopher B fetches chopstick 1
Philosopher B fetches chopstick 2
Philosopher D fetches chopstick 3
Philosopher B releases chopsticks 1 2
Philosopher A fetches chopstick 1
Philosopher C fetches chopstick 2
Philosopher A releases chopsticks 5 1
...</pre><p>分析一下，這個過程有沒有可能產生死鎖？調用usleep(3)函數可以實現微秒級的延時，試着用usleep(3)加快仿真的速度，看能不能觀察到死鎖現象。然後修改上述算法避免產生死鎖。
</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch35s03.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch35.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch36.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">3. 綫程間同步 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 第 36 章 TCP/IP協議基礎</td></tr></table></div></body></html>
