<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>1. 指針的基本概念</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch23.html" title="第 23 章 指針" /><link rel="prev" href="ch23.html" title="第 23 章 指針" /><link rel="next" href="ch23s02.html" title="2. 指針類型的參數和返回值" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1. 指針的基本概念</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch23.html">上一頁</a> </td><th width="60%" align="center">第 23 章 指針</th><td width="20%" align="right"> <a accesskey="n" href="ch23s02.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2809880"></a>1. 指針的基本概念</h2></div></div></div><p>在<a class="xref" href="ch12.html#stackqueue">第 12 章 <i>棧與隊列</i></a>講過，堆棧有棧頂指針，隊列有頭指針和尾指針，這些概念中的“<span class="quote">指針</span>”本質上是一個整數，是數組的索引，通過指針訪問數組中的某個元素。在<a class="xref" href="ch20s04.html#link.indirect">圖 20.3 “間接定址”</a>我們又看到另外一種指針的概念，把一個變數所在的內存單元的地址保存在另外一個內存單元中，保存地址的這個內存單元稱為指針，通過指針和間接定址訪問變數，這種指針在C語言中可以用一個指針類型的變數表示，例如某程序中定義了以下全局變數：</p><pre class="programlisting">int i;
int *pi = &amp;i;
char c;
char *pc = &amp;c;</pre><p>這幾個變數的內存佈局如下圖所示，在初學階段經常要借助于這樣的圖來理解指針。</p><div class="figure"><a id="id2810538"></a><p class="title"><b>圖 23.1. 指針的基本概念</b></p><div class="figure-contents"><div><img src="images/pointer.pointer0.png" alt="指針的基本概念" /></div></div></div><br class="figure-break" /><p>這裡的<code class="literal">&amp;</code>是取地址運算符（Address Operator）<a id="id2810563" class="indexterm"></a>，<code class="literal">&amp;i</code>表示取變數<code class="literal">i</code>的地址，<code class="literal">int *pi = &amp;i;</code>表示定義一個指向<code class="literal">int</code>型的指針變數<code class="literal">pi</code>，並用<code class="literal">i</code>的地址來初始化<code class="literal">pi</code>。我們講過全局變數只能用常量表達式初始化，如果定義<code class="literal">int p = i;</code>就錯了，因為<code class="literal">i</code>不是常量表達式，然而用<code class="literal">i</code>的地址來初始化一個指針卻沒有錯，因為<code class="literal">i</code>的地址是在編譯連結時能確定的，而不需要到運行時才知道，<code class="literal">&amp;i</code>是常量表達式。後面兩行代碼定義了一個字元型變數<code class="literal">c</code>和一個指向<code class="literal">c</code>的字元型指針<code class="literal">pc</code>，注意<code class="literal">pi</code>和<code class="literal">pc</code>雖然是不同類型的指針變數，但它們的內存單元都占4個位元組，因為要保存32位的虛擬地址，同理，在64位平台上指針變數都占8個位元組。</p><p>我們知道，在同一個語句中定義多個數組，每一個都要有<code class="literal">[]</code>號：<code class="literal">int a[5], b[5];</code>。同樣道理，在同一個語句中定義多個指針變數，每一個都要有<code class="literal">*</code>號，例如：</p><pre class="programlisting">int *p, *q;</pre><p>如果寫成<code class="literal">int* p, q;</code>就錯了，這樣是定義了一個整型指針<code class="literal">p</code>和一個整型變數<code class="literal">q</code>，定義數組的<code class="literal">[]</code>號寫在變數後面，而定義指針的<code class="literal">*</code>號寫在變數前面，更容易看錯。定義指針的<code class="literal">*</code>號前後空格都可以省，寫成<code class="literal">int*p,*q;</code>也算對，但<code class="literal">*</code>號通常和類型<code class="literal">int</code>之間留空格而和變數名寫在一起，這樣看<code class="literal">int *p, q;</code>就很明顯是定義了一個指針和一個整型變數，就不容易看錯了。</p><p>如果要讓<code class="literal">pi</code>指向另一個整型變數<code class="literal">j</code>，可以重新對<code class="literal">pi</code>賦值：</p><pre class="programlisting">pi = &amp;j;</pre><p>如果要改變<code class="literal">pi</code>所指向的整型變數的值，比如把變數<code class="literal">j</code>的值增加10，可以寫：</p><pre class="programlisting">*pi = *pi + 10;</pre><p>這裡的<code class="literal">*</code>號是指針間接定址運算符（Indirection Operator）<a id="id2810828" class="indexterm"></a>，<code class="literal">*pi</code>表示取指針<code class="literal">pi</code>所指向的變數的值，也稱為Dereference<a id="id2810848" class="indexterm"></a>操作，指針有時稱為變數的引用（Reference）<a id="id2810856" class="indexterm"></a>，所以根據指針找到變數稱為Dereference。</p><p><code class="literal">&amp;</code>運算符的操作數必須是左值，因為只有左值才表示一個內存單元，才會有地址，運算結果是指針類型。<code class="literal">*</code>運算符的操作數必須是指針類型，運算結果可以做左值。所以，如果表達式<code class="literal">E</code>可以做左值，<code class="literal">*&amp;E</code>和<code class="literal">E</code>等價，如果表達式<code class="literal">E</code>是指針類型，<code class="literal">&amp;*E</code>和<code class="literal">E</code>等價。</p><p>指針之間可以相互賦值，也可以用一個指針初始化另一個指針，例如：</p><pre class="programlisting">int *ptri = pi;</pre><p>或者：</p><pre class="programlisting">int *ptri;
ptri = pi;</pre><p>表示<span class="emphasis"><em><code class="literal">pi</code>指向哪就讓<code class="literal">ptri</code>也指向哪</em></span>，本質上就是把變數<code class="literal">pi</code>所保存的地址值賦給變數<code class="literal">ptri</code>。</p><p>用一個指針給另一個指針賦值時要注意，兩個指針必須是同一類型的。在我們的例子中，<code class="literal">pi</code>是<code class="literal">int *</code>型的，<code class="literal">pc</code>是<code class="literal">char *</code>型的，<code class="literal">pi = pc;</code>這樣賦值就是錯誤的。但是可以先強制類型轉換然後賦值：</p><pre class="programlisting">pi = (int *)pc;</pre><div class="figure"><a id="id2811004"></a><p class="title"><b>圖 23.2. 把<code class="literal">char *</code>指針的值賦給<code class="literal">int *</code>指針</b></p><div class="figure-contents"><div><img src="images/pointer.pointer1.png" alt="把char *指針的值賦給int *指針" /></div></div></div><br class="figure-break" /><p>現在<code class="literal">pi</code>指向的地址和<code class="literal">pc</code>一樣，但是通過<code class="literal">*pc</code>只能訪問到一個位元組，而通過<code class="literal">*pi</code>可以訪問到4個位元組，後3個位元組已經不屬於變數<code class="literal">c</code>了，除非你很確定變數<code class="literal">c</code>的一個位元組和後面3個位元組組合而成的<code class="literal">int</code>值是有意義的，否則就不應該給<code class="literal">pi</code>這麼賦值。因此使用指針要特別小心，很容易將指針指向錯誤的地址，訪問這樣的地址可能導致段錯誤，可能讀到無意義的值，也可能意外改寫了某些數據，使得程序在隨後的運行中出錯。有一種情況需要特別注意，定義一個指針類型的局部變數而沒有初始化：</p><pre class="programlisting">int main(void)
{
	int *p;
	...
	*p = 0;
	...
}</pre><p>我們知道，在堆棧上分配的變數初始值是不確定的，也就是說指針<code class="literal">p</code>所指向的內存地址是不確定的，後面用<code class="literal">*p</code>訪問不確定的地址就會導致不確定的後果，如果導致段錯誤還比較容易改正，如果意外改寫了數據而導致隨後的運行中出錯，就很難找到錯誤原因了。像這種指向不確定地址的指針稱為“<span class="quote">野指針</span>”（Unbound Pointer）<a id="id2811122" class="indexterm"></a>，為避免出現野指針，在定義指針變數時就應該給它明確的初值，或者把它初始化為<code class="literal">NULL</code>：</p><pre class="programlisting">int main(void)
{
	int *p = NULL;
	...
	*p = 0;
	...
}</pre><p><code class="literal">NULL</code>在C標準庫的標頭檔<code class="literal">stddef.h</code>中定義：</p><pre class="programlisting">#define NULL ((void *)0)</pre><p>就是把地址0轉換成指針類型，稱為空指針，它的特殊之處在於，操作系統不會把任何數據保存在地址0及其附近，也不會把地址0~0xfff的頁面映射到物理內存，所以任何對地址0的訪問都會立刻導致段錯誤。<code class="literal">*p = 0;</code>會導致段錯誤，就像放在眼前的炸彈一樣很容易找到，相比之下，野指針的錯誤就像埋下地雷一樣，更難發現和排除，這次走過去沒事，下次走過去就有事。</p><p>講到這裡就該講一下<code class="literal">void *</code>類型了。在編程時經常需要一種通用指針，可以轉換為任意其它類型的指針，任意其它類型的指針也可以轉換為通用指針，最初C語言沒有<code class="literal">void *</code>類型，就把<code class="literal">char *</code>當通用指針，需要轉換時就用類型轉換運算符<code class="literal">()</code>，ANSI在將C語言標準化時引入了<code class="literal">void *</code>類型，<code class="literal">void *</code>指針與其它類型的指針之間可以隱式轉換，而不必用類型轉換運算符。注意，只能定義<code class="literal">void *</code>指針，而不能定義<code class="literal">void</code>型的變數，因為<code class="literal">void *</code>指針和別的指針一樣都占4個位元組，而如果定義<code class="literal">void</code>型變數（也就是類型暫時不確定的變數），編譯器不知道該分配幾個位元組給變數。同樣道理，<code class="literal">void *</code>指針不能直接Dereference，而必須先轉換成別的類型的指針再做Dereference。<code class="literal">void *</code>指針常用於函數介面，比如：</p><pre class="programlisting">void func(void *pv)
{
	/* *pv = 'A' is illegal */
	char *pchar = pv;
	*pchar = 'A';
}

int main(void)
{
	char c;
	func(&amp;c);
	printf("%c\n", c);
...
}</pre><p>下一章講函數介面時再詳細介紹<code class="literal">void *</code>指針的用處。</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch23.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch23.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch23s02.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">第 23 章 指針 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 2. 指針類型的參數和返回值</td></tr></table></div></body></html>
