<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>3. 遞歸</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch05.html" title="第 5 章 深入理解函數" /><link rel="prev" href="ch05s02.html" title="2. 增量式開發" /><link rel="next" href="ch06.html" title="第 6 章 循環語句" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. 遞歸</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch05s02.html">上一頁</a> </td><th width="60%" align="center">第 5 章 深入理解函數</th><td width="20%" align="right"> <a accesskey="n" href="ch06.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2722951"></a>3. 遞歸</h2></div></div></div><p>如果定義一個概念需要用到這個概念本身，我們稱它的定義是遞歸的（Recursive）<a id="id2722964" class="indexterm"></a>。例如：</p><div class="variablelist"><dl><dt><span class="term">frabjuous</span></dt><dd><p>an adjective used to describe something that is frabjuous.</p></dd></dl></div><p>這只是一個玩笑，如果你在字典上看到這麼一個詞條肯定要怒了。然而數學上確實有很多概念是用它自己來定義的，比如n的階乘（Factorial）<a id="id2722991" class="indexterm"></a>是這樣定義的：n的階乘等於n乘以n-1的階乘。如果這樣就算定義完了，恐怕跟上面那個詞條有異曲同工之妙了：n-1的階乘是什麼？是n-1乘以n-2的階乘。那n-2的階乘又是什麼？這樣下去永遠也沒完。因此需要定義一個最關鍵的基礎條件（Base Case）<a id="id2723009" class="indexterm"></a>：0的階乘等於1。</p><div class="literallayout"><p>0! = 1<br />
n! = n · (n-1)!</p></div><p>因此，3!=3*2!，2!=2*1!，1!=1*0!=1*1=1，正因為有了Base Case，才不會永遠沒完地數下去，知道了1!=1我們再反過來算回去，2!=2*1!=2*1=2，3!=3*2!=3*2=6。下面用程序來完成這一計算過程，我們要寫一個計算階乘的函數<code class="literal">factorial</code>，先把Base Case這種最簡單的情況寫進去：</p><pre class="programlisting">int factorial(int n)
{
	if (n == 0)
		return 1;
}</pre><p>如果參數<code class="literal">n</code>不是0應該<code class="literal">return</code>什麼呢？根據定義，應該<code class="literal">return n*factorial(n-1);</code>，為了下面的分析方便，我們引入幾個臨時變數把這個語句拆分一下：</p><pre class="programlisting">int factorial(int n)
{
	if (n == 0)
		return 1;
	else {
		int recurse = factorial(n-1);
		int result = n * recurse;
		return result;
	}
}</pre><p><code class="literal">factorial</code>這個函數居然可以自己調用自己？是的。自己直接或間接調用自己的函數稱為遞歸函數。這裡的<code class="literal">factorial</code>是直接調用自己，有些時候函數A調用函數B，函數B又調用函數A，也就是函數A間接調用自己，這也是遞歸函數。如果你覺得迷惑，可以把<code class="literal">factorial(n-1)</code>這一步看成是在調用另一個函數－－另一個有着相同函數名和相同代碼的函數，調用它就是跳到它的代碼裡執行，然後再返回<code class="literal">factorial(n-1)</code>這個調用的下一步繼續執行。我們以<code class="literal">factorial(3)</code>為例分析整個調用過程，如下圖所示：</p><div class="figure"><a id="id2723116"></a><p class="title"><b>圖 5.2. factorial(3)的調用過程</b></p><div class="figure-contents"><div><img src="images/func2.factorial.png" alt="factorial(3)的調用過程" /></div></div></div><br class="figure-break" /><p>圖中用實線箭頭表示調用，用虛線箭頭表示返回，右側的框表示在調用和返回過程中各層函數調用的存儲空間變化情況。</p><div class="orderedlist"><ol type="1"><li><p><code class="literal">main()</code>有一個局部變數<code class="literal">result</code>，用一個框表示。</p></li><li><p>調用<code class="literal">factorial(3)</code>時要分配參數和局部變數的存儲空間，於是在<code class="literal">main()</code>的下面又多了一個框表示<code class="literal">factorial(3)</code>的參數和局部變數，其中<code class="literal">n</code>已初始化為3。</p></li><li><p><code class="literal">factorial(3)</code>又調用<code class="literal">factorial(2)</code>，又要分配<code class="literal">factorial(2)</code>的參數和局部變數，於是在<code class="literal">main()</code>和<code class="literal">factorial(3)</code>下面又多了一個框。<a class="xref" href="ch03s04.html#func.localvar">第 4 節 “全局變數、局部變數和作用域”</a>講過，每次調用函數時分配參數和局部變數的存儲空間，退出函數時釋放它們的存儲空間。<code class="literal">factorial(3)</code>和<code class="literal">factorial(2)</code>是兩次不同的調用，<code class="literal">factorial(3)</code>的參數<code class="literal">n</code>和<code class="literal">factorial(2)</code>的參數<code class="literal">n</code>各有各的存儲單元，雖然我們寫代碼時只寫了一次參數<code class="literal">n</code>，但運行時卻是兩個不同的參數<code class="literal">n</code>。並且由於調用<code class="literal">factorial(2)</code>時<code class="literal">factorial(3)</code>還沒退出，所以兩個函數調用的參數<code class="literal">n</code>同時存在，所以在原來的基礎上多畫一個框。</p></li><li><p>依此類推，請讀者對照着圖自己分析整個調用過程。讀者會發現這個過程和前面我們用數學公式計算3!的過程是一樣的，都是先一步步展開然後再一步步收回去。</p></li></ol></div><p>我們看上圖右側存儲空間的變化過程，隨着函數調用的層層深入，存儲空間的一端逐漸增長，然後隨着函數調用的層層返回，存儲空間的這一端又逐漸縮短，並且每次訪問參數和局部變數時只能訪問這一端的存儲單元，而不能訪問內部的存儲單元，比如當<code class="literal">factorial(2)</code>的存儲空間位於末端時，只能訪問它的參數和局部變數，而不能訪問<code class="literal">factorial(3)</code>和<code class="literal">main()</code>的參數和局部變數。具有這種性質的資料結構稱為堆棧或棧（Stack）<a id="id2723347" class="indexterm"></a>，隨着函數調用和返回而不斷變化的這一端稱為棧頂，每個函數調用的參數和局部變數的存儲空間（上圖的每個小方框）稱為一個棧幀（Stack Frame）<a id="id2723357" class="indexterm"></a>。操作系統為程序的運行預留了一塊棧空間，函數調用時就在這個棧空間裡分配棧幀，函數返回時就釋放棧幀。</p><p>在寫一個遞歸函數時，你如何證明它是正確的？像上面那樣跟蹤函數的調用和返回過程算是一種辦法，但只是<code class="literal">factorial(3)</code>就已經這麼麻煩了，如果是<code class="literal">factorial(100)</code>呢？雖然我們已經證明了<code class="literal">factorial(3)</code>是正確的，因為它跟我們用數學公式計算的過程一樣，結果也一樣，但這不能代替<code class="literal">factorial(100)</code>的證明，你怎麼辦？別的函數你可以跟蹤它的調用過程去證明它的正確性，因為每個函數隻調用一次就返回了，但是對於遞歸函數，這麼跟下去只會跟得你頭都大了。事實上並不是每個函數調用都需要鑽進去看的。我們在調用<code class="literal">printf</code>時沒有鑽進去看它是怎麼打印的，我們只是<span class="emphasis"><em>相信</em></span>它能打印，能正確完成它的工作，然後就繼續寫下面的代碼了。在上一節中，我們寫了<code class="literal">distance</code>和<code class="literal">area</code>函數，然後立刻測試證明了這兩個函數是正確的，然後我們寫<code class="literal">area_point</code>時調用了這兩個函數：</p><pre class="programlisting">return area(distance(x1, y1, x2, y2));</pre><p>在寫這一句的時候，我們需要鑽進<code class="literal">distance</code>和<code class="literal">area</code>函數中去走一趟才知道我們調用得是否正確嗎？不需要，因為我們已經<span class="emphasis"><em>相信</em></span>這兩個函數能正確工作了，也就是相信把座標傳給<code class="literal">distance</code>它就能返回正確的距離，把半徑傳給<code class="literal">area</code>它就能返回正確的面積，因此調用它們去完成另外一件工作也應該是正確的。這種“<span class="quote">相信</span>”稱為Leap of Faith<a id="id2723481" class="indexterm"></a>，首先相信一些結論，然後再用它們去證明另外一些結論。</p><p>在寫<code class="literal">factorial(n)</code>的代碼時寫到這個地方：</p><pre class="programlisting">...
int recurse = factorial(n-1);
int result = n * recurse;
...</pre><p>這時，如果我們相信<code class="literal">factorial(n-1)</code>是正確的，也就是相信傳給它<code class="literal">n-1</code>它就能返回(n-1)!，那麼<code class="literal">recurse</code>就是(n-1)!，那麼<code class="literal">result</code>就是n*(n-1)!，也就是n!，這正是我們要返回的<code class="literal">factorial(n)</code>的結果。當然這有點奇怪：我們還沒寫完<code class="literal">factorial</code>這個函數，憑什麼要相信<code class="literal">factorial(n-1)</code>是正確的？可Leap of Faith本身就是Leap（跳躍）的，不是嗎？<span class="emphasis"><em>如果你相信你正在寫的遞歸函數是正確的，並調用它，然後在此基礎上寫完這個遞歸函數，那麼它就會是正確的，從而值得你相信它正確。</em></span></p><p>這麼說好像有點兒玄，我們從數學上嚴格證明一下<code class="literal">factorial</code>函數的正確性。剛纔說了，<code class="literal">factorial(n)</code>的正確性依賴于<code class="literal">factorial(n-1)</code>的正確性，只要後者正確，在後者的結果上乘個<code class="literal">n</code>返回這一步顯然也沒有疑問，那麼我們的函數實現就是正確的。因此要證明<code class="literal">factorial(n)</code>的正確性就是要證明<code class="literal">factorial(n-1)</code>的正確性，同理，要證明<code class="literal">factorial(n-1)</code>的正確性就是要證明<code class="literal">factorial(n-2)</code>的正確性，依此類推下去，最後是：要證明<code class="literal">factorial(1)</code>的正確性就是要證明<code class="literal">factorial(0)</code>的正確性。而<code class="literal">factorial(0)</code>的正確性不依賴于別的函數調用，它就是程序中的一個小的分支<code class="literal">return 1;</code>，這個1是我們根據階乘的定義寫的，肯定是正確的，因此<code class="literal">factorial(1)</code>的實現是正確的，因此<code class="literal">factorial(2)</code>也正確，依此類推，最後<code class="literal">factorial(n)</code>也是正確的。其實這就是在中學時學的數學歸納法（Mathematical Induction）<a id="id2723665" class="indexterm"></a>，用數學歸納法來證明只需要證明兩點：Base Case正確，遞推關係正確。<span class="emphasis"><em>寫遞歸函數時一定要記得寫Base Case</em></span>，否則即使遞推關係正確，整個函數也不正確。如果<code class="literal">factorial</code>函數漏掉了Base Case：</p><pre class="programlisting">int factorial(int n)
{
	int recurse = factorial(n-1);
	int result = n * recurse;
	return result;
}</pre><p>那麼這個函數就會永遠調用下去，直到操作系統為程序預留的棧空間耗盡程序崩潰（段錯誤）為止，這稱為無窮遞歸（Infinite recursion）<a id="id2723697" class="indexterm"></a>。</p><p>到目前為止我們只學習了全部C語法的一個小的子集，但是現在應該告訴你：這個子集是完備的，它本身就可以作為一門編程語言了，以後還要學習很多C語言特性，但全部都可以用已經學過的這些特性來代替。也就是說，以後要學的C語言特性會使代碼寫起來更加方便，但不是必不可少的，現在學的這些已經完全覆蓋了<a class="xref" href="intro.program.html" title="1. 程序和編程語言">第 1 節 “程序和編程語言”</a>講的五種基本指令了。有的讀者會說循環還沒講到呢，是的，循環在下一章才講，但有一個重要的結論就是<span class="emphasis"><em>遞歸和循環是等價的</em></span>，用循環能做的事用遞歸都能做，反之亦然，事實上有的編程語言（比如某些LISP實現）只有遞歸而沒有循環。計算機指令能做的所有事情就是數據存取、運算、測試和分支、循環（或遞歸），在計算機上運行高級語言寫的程序最終也要翻譯成指令，指令做不到的事情高級語言寫的程序肯定也做不到，雖然高級語言有豐富的語法特性，但也只是比指令寫起來更方便而已，能做的事情是一樣多的。那麼，為什麼計算機要設計成這樣？在設計時怎麼想到計算機應該具備這幾樣功能，而不是更多或更少的功能？這些要歸功于早期的計算機科學家，例如Alan Turing，他們在計算機還沒有誕生的年代就從數學理論上為計算機的設計指明了方向。有興趣的讀者可以參考有關計算理論的教材，例如<a class="xref" href="bi01.html#bibli.iatlc" title="Introduction to Automata Theory, Languages, and Computation">[<abbr class="abbrev">IATLC</abbr>]</a>。</p><p>遞歸絶不只是為解決一些奇技淫巧的數學題<sup>[<a id="id2723765" href="#ftn.id2723765" class="footnote">8</a>]</sup>而想出來的招，它是計算機的精髓所在，也是編程語言的精髓所在。我們學習在C的語法時已經看到很多遞歸定義了，例如在<a class="xref" href="ch03s01.html#func.mathfunc">第 1 節 “數學函數”</a>講過的語法規則中，“<span class="quote">表達式</span>”就是遞歸定義的：</p><div class="literallayout"><p><span class="emphasis"><em>表達式</em></span> → <span class="emphasis"><em>表達式</em></span>(參數列表)<br />
參數列表 → <span class="emphasis"><em>表達式</em></span>, <span class="emphasis"><em>表達式</em></span>, ...</p></div><p>再比如在<a class="xref" href="ch04s01.html#cond.if">第 1 節 “if語句”</a>講過的語規則中，“<span class="quote">語句</span>”也是遞歸定義的：</p><div class="literallayout"><p><span class="emphasis"><em>語句</em></span> → if (控製表達式) <span class="emphasis"><em>語句</em></span></p></div><p>可見編譯器在解析我們寫的程序時一定也用了大量的遞歸，有關編譯器的實現原理可參考<a class="xref" href="bi01.html#bibli.dragonbook" title="Compilers: Principles, Techniques, &amp; Tools">[<abbr class="abbrev">Dragon Book</abbr>]</a>。</p><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2723842"></a>習題</h3></div></div></div><p>1、編寫遞歸函數求兩個正整數<code class="literal">a</code>和<code class="literal">b</code>的最大公約數（GCD，Greatest Common Divisor）<a id="id2723863" class="indexterm"></a>，使用Euclid算法：</p><div class="orderedlist"><ol type="1"><li><p>如果<code class="literal">a</code>除以<code class="literal">b</code>能整除，則最大公約數是<code class="literal">b</code>。</p></li><li><p>否則，最大公約數等於<code class="literal">b</code>和<code class="literal">a%b</code>的最大公約數。</p></li></ol></div><p>Euclid算法是很容易證明的，請讀者自己證明一下為什麼這麼算就能算出最大公約數。最後，修改你的程序使之適用於所有整數，而不僅僅是正整數。</p><p>2、編寫遞歸函數求Fibonacci數列的第<code class="literal">n</code>項，這個數列是這樣定義的：</p><div class="literallayout"><p>fib(0)=1<br />
fib(1)=1<br />
fib(n)=fib(n-1)+fib(n-2)</p></div><p>上面兩個看似毫不相干的問題之間卻有一個有意思的聯繫：</p><div class="variablelist"><dl><dt><span class="term">Lamé定理</span></dt><dd><p>如果Euclid算法需要k步來計算兩個數的GCD，那麼這兩個數之中較小的一個必然大於等於Fibonacci數列的第k項。</p></dd></dl></div><p>感興趣的讀者可以參考<a class="xref" href="bi01.html#bibli.sicp" title="Structure and Interpretation of Computer Programs">[<abbr class="abbrev">SICP</abbr>]</a>第1.2節的簡略證明。</p></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id2723765" href="#id2723765" class="para">8</a>] </sup>例如很多編程書都會舉例的漢諾塔問題，本書不打算再重複這個題目了。</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch05s02.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch05.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch06.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">2. 增量式開發 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 第 6 章 循環語句</td></tr></table></div></body></html>
