<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>1. 整型</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch15.html" title="第 15 章 數據類型詳解" /><link rel="prev" href="ch15.html" title="第 15 章 數據類型詳解" /><link rel="next" href="ch15s02.html" title="2. 浮點型" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1. 整型</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch15.html">上一頁</a> </td><th width="60%" align="center">第 15 章 數據類型詳解</th><td width="20%" align="right"> <a accesskey="n" href="ch15s02.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2756569"></a>1. 整型</h2></div></div></div><p>我們知道，在C語言中<code class="literal">char</code>型占一個位元組的存儲空間，一個位元組通常是8個bit。如果這8個bit按無符號整數來解釋，取值範圍是0~255，如果按有符號整數來解釋，採用2's Complement表示法，取值範圍是-128~127。C語言規定了<code class="literal">signed</code>和<code class="literal">unsigned</code>兩個關鍵字，<code class="literal">unsigned char</code>型表示無符號數，<code class="literal">signed char</code>型表示有符號數。</p><p>那麼以前我們常用的不帶<code class="literal">signed</code>或<code class="literal">unsigned</code>關鍵字的<code class="literal">char</code>型是無符號數還是有符號數呢？C標準規定這是Implementation Defined，編譯器可以定義<code class="literal">char</code>型是無符號的，也可以定義<code class="literal">char</code>型是有符號的，在該編譯器所對應的體繫結構上哪種實現效率高就可以採用哪種實現，x86平台的<code class="literal">gcc</code>定義<code class="literal">char</code>型是有符號的。這也是C標準的Rationale之一：<span class="emphasis"><em>優先考慮效率，而可移植性尚在其次</em></span>。這就要求程序員非常清楚這些規則，如果你要寫可移植的代碼，就必須清楚哪些寫法是不可移植的，應該避免使用。另一方面，寫不可移植的代碼有時候也是必要的，比如Linux內核代碼使用了很多只有<code class="literal">gcc</code>支持的語法特性以得到最佳的執行效率，在寫這些代碼的時候就沒打算用別的編譯器編譯，也就沒考慮可移植性的問題。如果要寫不可移植的代碼，你也必須清楚代碼中的哪些部分是不可移植的，以及為什麼要這樣寫，如果不是為了效率，一般來說就沒有理由故意寫不可移植的代碼。從現在開始，我們會接觸到很多Implementation Defined的特性，C語言與平台和編譯器是密不可分的，離開了具體的平台和編譯器討論C語言，就只能討論到本書第一部分的程度了。注意，ASCII碼的取值範圍是0~127，所以不管<code class="literal">char</code>型是有符號的還是無符號的，存一個ASCII碼都沒有問題，一般來說，如果用<code class="literal">char</code>型存ASCII碼字元，就不必明確寫是<code class="literal">signed</code>還是<code class="literal">unsigned</code>，如果用<code class="literal">char</code>型表示8位的整數，為了可移植性就必須寫明是<code class="literal">signed</code>還是<code class="literal">unsigned</code>。</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h3 class="title">Implementation-defined、Unspecified和Undefined</h3><p>在C標準中沒有做明確規定的地方會用Implementation-defined<a id="id2756724" class="indexterm"></a>、Unspecified<a id="id2756731" class="indexterm"></a>或Undefined<a id="id2756738" class="indexterm"></a>來表述，在本書中有時把這三種情況統稱為“<span class="quote">未明確定義</span>”的。這三種情況到底有什麼不同呢？</p><p>我們剛纔看到一種Implementation-defined的情況，C標準沒有明確規定<code class="literal">char</code>是有符號的還是無符號的，但是要求編譯器必須對此做出明確規定，並寫在編譯器的文檔中。</p><p>而對於Unspecified的情況，往往有幾種可選的處理方式，C標準沒有明確規定按哪種方式處理，編譯器可以自己決定，並且也不必寫在編譯器的文檔中，這樣即便用同一個編譯器的不同版本來編譯也可能得到不同的結果，因為編譯器沒有在文檔中明確寫它會怎麼處理，那麼不同版本的編譯器就可以選擇不同的處理方式，比如下一章我們會講到一個函數調用的各個實參表達式按什麼順序求值是Unspecified的。</p><p>Undefined的情況則是完全不確定的，C標準沒規定怎麼處理，編譯器很可能也沒規定，甚至也沒做出錯處理，有很多Undefined的情況編譯器是檢查不出來的，最終會導致運行時錯誤，比如數組訪問越界就是Undefined的。</p><p>初學者看到這些規則通常會很不舒服，覺得這不是在學編程而是在啃法律條文，結果越學越泄氣。是的，C語言並不像一個數學定理那麼完美，現實世界裡的東西總是不夠完美的。但還好啦，C程序員已經很幸福了，只要嚴格遵照C標準來寫代碼，不要去觸碰那些陰暗角落，寫出來的代碼就有很好的可移植性。想想那些可憐的JavaScript程序員吧，他們甚至連一個可以遵照的標準都沒有，一個瀏覽器一個樣，甚至同一個瀏覽器的不同版本也差別很大，程序員不得不為每一種瀏覽器的每一個版本分別寫不同的代碼。</p></div><p>除了<code class="literal">char</code>型之外，整型還包括<code class="literal">short int</code>（或者簡寫為<code class="literal">short</code>）、<code class="literal">int</code>、<code class="literal">long int</code>（或者簡寫為<code class="literal">long</code>）、<code class="literal">long long int</code>（或者簡寫為<code class="literal">long long</code>）等幾種<sup>[<a id="id2756873" href="#ftn.id2756873" class="footnote">25</a>]</sup>，這些類型都可以加上<code class="literal">signed</code>或<code class="literal">unsigned</code>關鍵字表示有符號或無符號數。其實，對於有符號數在計算機中的表示是Sign and Magnitude、1's Complement還是2's Complement，C標準也沒有明確規定，也是Implementation Defined。大多數體繫結構都採用2's Complement表示法，x86平台也是如此，從現在開始我們只討論2's Complement表示法的情況。還有一點要注意，除了<code class="literal">char</code>型以外的這些類型如果不明確寫<code class="literal">signed</code>或<code class="literal">unsigned</code>關鍵字都表示<code class="literal">signed</code>，這一點是C標準明確規定的，不是Implementation Defined。</p><p>除了<code class="literal">char</code>型在C標準中明確規定占一個位元組之外，其它整型占幾個位元組都是Implementation Defined。通常的編譯器實現遵守ILP32<a id="id2756951" class="indexterm"></a>或LP64<a id="id2756958" class="indexterm"></a>規範，如下表所示。</p><div class="table"><a id="id2756966"></a><p class="title"><b>表 15.1. ILP32和LP64</b></p><div class="table-contents"><table summary="ILP32和LP64" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>類型</th><th>ILP32（位數）</th><th>LP64（位數）</th></tr></thead><tbody><tr><td>char</td><td>8</td><td>8</td></tr><tr><td>short</td><td>16</td><td>16</td></tr><tr><td>int</td><td>32</td><td>32</td></tr><tr><td>long</td><td>32</td><td>64</td></tr><tr><td>long long</td><td>64</td><td>64</td></tr><tr><td>指針</td><td>32</td><td>64</td></tr></tbody></table></div></div><br class="table-break" /><p>ILP32這個縮寫的意思是<code class="literal">int</code>（I）、<code class="literal">long</code>（L）和指針（P）類型都占32位，通常32位計算機的C編譯器採用這種規範，x86平台的<code class="literal">gcc</code>也是如此。LP64是指<code class="literal">long</code>（L）和指針占64位，通常64位計算機的C編譯器採用這種規範。指針類型的長度總是和計算機的位數一致，至于什麼是計算機的位數，指針又是一種什麼樣的類型，我們到<a class="xref" href="ch17.html#arch">第 17 章 <i>計算機體繫結構基礎</i></a>和<a class="xref" href="ch23.html#pointer">第 23 章 <i>指針</i></a>再分別詳細解釋。從現在開始本書做以下約定：<span class="emphasis"><em>在以後的陳述中，預設平台是x86/Linux/gcc，遵循ILP32，並且<code class="literal">char</code>是有符號的，我不會每次都加以說明，但說到其它平台時我會明確指出是什麼平台</em></span>。</p><p>在<a class="xref" href="ch02s02.html#expr.constant">第 2 節 “常量”</a>講過C語言的常量有整數常量、字元常量、枚舉常量和浮點數常量四種，其實字元常量和枚舉常量的類型都是<code class="literal">int</code>型，因此前三種常量的類型都屬於整型。整數常量有很多種，不全是<code class="literal">int</code>型的，下面我們詳細討論整數常量。</p><p>以前我們只用到十進制的整數常量，其實在C語言中也可以用八進制和十六進制的整數常量<sup>[<a id="id2757137" href="#ftn.id2757137" class="footnote">26</a>]</sup>。八進制整數常量以0開頭，後面的數字只能是0~7，例如022，因此十進制的整數常量就不能以0開頭了，否則無法和八進制區分。十六進制整數常量以0x或0X開頭，後面的數字可以是0~9、a~f和A~F。在<a class="xref" href="ch02s06.html#expr.charencoding">第 6 節 “字元類型與字元編碼”</a>講過一種轉義序列，以\或\x加八進制或十六進制數字表示，這種表示方式相當於把八進制和十六進制整數常量開頭的0替換成\了。</p><p>整數常量還可以在末尾加u或U表示“<span class="quote">unsigned</span>”，加l或L表示“<span class="quote">long</span>”，加ll或LL表示“<span class="quote">long long</span>”，例如0x1234U，98765ULL等。但事實上u、l、ll這幾種尾碼和上面講的<code class="literal">unsigned</code>、<code class="literal">long</code>、<code class="literal">long long</code>關鍵字並不是一一對應的。這個對應關係比較複雜，準確的描述如下表所示（出自<a class="xref" href="bi01.html#bibli.c99" title="ISO/IEC 9899: Programming Languages － C">[<abbr class="abbrev">C99</abbr>]</a>條款6.4.4.1）。</p><div class="table"><a id="id2757215"></a><p class="title"><b>表 15.2. 整數常量的類型</b></p><div class="table-contents"><table summary="整數常量的類型" border="1"><colgroup><col /><col /><col /></colgroup><thead><tr><th>尾碼</th><th>十進制常量</th><th>八進制或十六進制常量</th></tr></thead><tbody><tr><td>無</td><td><div class="literallayout"><p>int<br />
long int<br />
long long int</p></div></td><td><div class="literallayout"><p>int<br />
unsigned int<br />
long int<br />
unsigned long int<br />
long long int<br />
unsigned long long int</p></div></td></tr><tr><td>u或U</td><td><div class="literallayout"><p>unsigned int<br />
unsigned long int<br />
unsigned long long int</p></div></td><td><div class="literallayout"><p>unsigned int<br />
unsigned long int<br />
unsigned long long int</p></div></td></tr><tr><td>l或L</td><td><div class="literallayout"><p>long int<br />
long long int</p></div></td><td><div class="literallayout"><p>long int<br />
unsigned long int<br />
long long int<br />
unsigned long long int</p></div></td></tr><tr><td>既有u或U，又有l或L</td><td><div class="literallayout"><p>unsigned long int<br />
unsigned long long int</p></div></td><td><div class="literallayout"><p>unsigned long int<br />
unsigned long long int</p></div></td></tr><tr><td>ll或LL</td><td><div class="literallayout"><p>long long int</p></div></td><td><div class="literallayout"><p>long long int<br />
unsigned long long int</p></div></td></tr><tr><td>既有u或U，又有ll或LL</td><td><div class="literallayout"><p>unsigned long long int</p></div></td><td><div class="literallayout"><p>unsigned long long int</p></div></td></tr></tbody></table></div></div><br class="table-break" /><p>給定一個整數常量，比如1234U，那麼它應該屬於“<span class="quote">u或U</span>”這一行的“<span class="quote">十進制常量</span>”這一列，這個表格單元中列了三種類型<code class="literal">unsigned int</code>、<code class="literal">unsigned long int</code>、<code class="literal">unsigned long long int</code>，從上到下找出第一個足夠長的類型可以表示1234這個數，那麼它就是這個整數常量的類型，如果<code class="literal">int</code>是32位的那麼<code class="literal">unsigned int</code>就可以表示。</p><p>再比如0xffff0000，應該屬於第一行“<span class="quote">無</span>”的第二列“<span class="quote">八進制或十六進制常量</span>”，這一列有六種類型<code class="literal">int</code>、<code class="literal">unsigned int</code>、<code class="literal">long int</code>、<code class="literal">unsigned long int</code>、<code class="literal">long long int</code>、<code class="literal">unsigned long long int</code>，第一個類型<code class="literal">int</code>表示不了0xffff0000這麼大的數，我們寫這個十六進制常量是要表示一個正數，而它的MSB（第31位）是1，如果按有符號<code class="literal">int</code>類型來解釋就成了負數了，第二個類型<code class="literal">unsigned int</code>可以表示這個數，所以這個十六進制常量的類型應該算<code class="literal">unsigned int</code>。所以請注意，0x7fffffff和0xffff0000這兩個常量雖然看起來差不多，但前者是<code class="literal">int</code>型，而後者是<code class="literal">unsigned int</code>型。</p><p>講一個有意思的問題。我們知道x86平台上<code class="literal">int</code>的取值範圍是-2147483648~2147483647，那麼用<code class="literal">printf("%d\n", -2147483648);</code>打印<code class="literal">int</code>類型的下界有沒有問題呢？如果用<code class="literal">gcc main.c -std=c99</code>編譯會有警告信息：<code class="literal">warning: format ‘%d’ expects type ‘int’, but argument 2 has type ‘long long int’</code>。這是因為，雖然-2147483648這個數值能夠用<code class="literal">int</code>型表示，但在C語言中卻沒法寫出對應這個數值的<code class="literal">int</code>型常量，C編譯器會把它當成一個整數常量2147483648和一個負號運算符組成的表達式，而整數常量2147483648已經超過了<code class="literal">int</code>型的取值範圍，在x86平台上<code class="literal">int</code>和<code class="literal">long</code>的取值範圍相同，所以這個常量也超過了<code class="literal">long</code>型的取值範圍，根據上表第一行“<span class="quote">無</span>”的第一列<code class="literal">十進制常量</code>，這個整數常量應該算<code class="literal">long long</code>型的，前面再加個負號組成的表達式仍然是<code class="literal">long long</code>型，而<code class="literal">printf</code>的<code class="literal">%d</code>轉換說明要求後面的參數是<code class="literal">int</code>型，所以編譯器報警告。之所以編譯命令要加<code class="literal">-std=c99</code>選項是因為C99以前對於整數常量的類型規定和上表有一些出入，即使不加這個選項也會報警告，但警告信息不准確，讀者可以試試。如果改成<code class="literal">printf("%d\n", -2147483647-1);</code>編譯器就不會報警告了，-號運算符的兩個操作數-2147483647和1都是<code class="literal">int</code>型，計算結果也應該是<code class="literal">int</code>型，並且它的值也沒有超出<code class="literal">int</code>型的取值範圍；或者改成<code class="literal">printf("%lld\n", -2147483648);</code>也可以，轉換說明<code class="literal">%lld</code>告訴<code class="literal">printf</code>後面的參數是<code class="literal">long long</code>型，有些轉換說明格式目前還沒講到，詳見<a class="xref" href="ch25s02.html#stdlib.formatio">第 2.9 節 “格式化I/O函數”</a>。</p><p>怎麼樣，整數常量沒有你原來想的那麼簡單吧。再看一個不簡單的問題。<code class="literal">long long i = 1234567890 * 1234567890;</code>編譯時會有警告信息：<code class="literal">warning: integer overflow in expression</code>。1234567890是<code class="literal">int</code>型，兩個<code class="literal">int</code>型相乘的表達式仍然是<code class="literal">int</code>型，而乘積已經超過<code class="literal">int</code>型的取值範圍了，因此提示計算結果溢出。如果改成<code class="literal">long long i = 1234567890LL * 1234567890;</code>，其中一個常量是<code class="literal">long long</code>型，另一個常量也會先轉換成<code class="literal">long long</code>型再做乘法運算，兩數相乘的表達式也是<code class="literal">long long</code>型，編譯器就不會報警告了。有關類型轉換的規則將在<a class="xref" href="ch15s03.html#type.conversion">第 3 節 “類型轉換”</a>詳細介紹。</p><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id2756873" href="#id2756873" class="para">25</a>] </sup>我們在<a class="xref" href="ch19s04.html#asmc.structunion">第 4 節 “結構體和聯合體”</a>還要介紹一種特殊的整型－－Bit-field。</p></div><div class="footnote"><p><sup>[<a id="ftn.id2757137" href="#id2757137" class="para">26</a>] </sup>有些編譯器（比如<code class="literal">gcc</code>）也支持二進制的整數常量，以0b或0B開頭，比如0b0001111，但二進制的整數常量從未進入C標準，只是某些編譯器的擴展，所以不建議使用，由於二進制和八進制、十六進制的對應關係非常明顯，用八進制或十六進制常量完全可以代替使用二進制常量。</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch15.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch15.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch15s02.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">第 15 章 數據類型詳解 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 2. 浮點型</td></tr></table></div></body></html>
