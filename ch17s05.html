<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>5. Memory Hierarchy</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch17.html" title="第 17 章 計算機體繫結構基礎" /><link rel="prev" href="ch17s04.html" title="4. MMU" /><link rel="next" href="ch18.html" title="第 18 章 x86彙編程序基礎" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">5. Memory Hierarchy</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch17s04.html">上一頁</a> </td><th width="60%" align="center">第 17 章 計算機體繫結構基礎</th><td width="20%" align="right"> <a accesskey="n" href="ch18.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2767397"></a>5. Memory Hierarchy</h2></div></div></div><p>硬碟、內存、CPU寄存器，還有本節要講的Cache，這些都是存儲器，計算機為什麼要有這麼多種存儲器呢？這些存儲器各自有什麼特點？這是本節要討論的問題。</p><p>由於硬件技術的限制，我們可以製造出容量很小但很快的存儲器，也可以製造出容量很大但很慢的存儲器，但不可能兩邊的好處都占着，不可能製造出訪問速度又快容量又大的存儲器。因此，現代計算機都把存儲器分成若干級，稱為Memory Hierarchy<a id="id2767425" class="indexterm"></a>，按照離CPU由近到遠的順序依次是CPU寄存器、Cache、內存、硬碟，越靠近CPU的存儲器容量越小但訪問速度越快，下圖給出了各種存儲器的容量和訪問速度的典型值。</p><div class="figure"><a id="id2767436"></a><p class="title"><b>圖 17.8. Memory Hierarchy</b></p><div class="figure-contents"><div><img src="images/arch.memhie.png" alt="Memory Hierarchy" /></div></div></div><br class="figure-break" /><div class="table"><a id="id2767450"></a><p class="title"><b>表 17.1. Memory Hierarchy</b></p><div class="table-contents"><table summary="Memory Hierarchy" border="1"><colgroup><col /><col /><col /><col /><col /><col /></colgroup><thead><tr><th>存儲器類型</th><th>位於哪裡</th><th>存儲容量</th><th>半導體工藝</th><th>訪問時間</th><th>如何訪問</th></tr></thead><tbody><tr><td>CPU寄存器</td><td>位於CPU執行單元中。</td><td>CPU寄存器通常只有幾個到幾十個，每個寄存器的容量取決於CPU的字長，所以一共只有幾十到幾百位元組。</td><td>“<span class="quote">寄存器</span>”這個名字就是一種數字電路的名字，它由一組觸發器（Flip-flop）<a id="id2767501" class="indexterm"></a>組成，每個觸發器保存一個Bit的數據，可以做存取和移位等操作。計算機掉電時寄存器中保存的數據會丟失。</td><td>寄存器是訪問速度最快的存儲器，典型的訪問時間是幾納秒。</td><td>使用哪個寄存器，如何使用寄存器，這些都是由指令決定的。</td></tr><tr><td>Cache<a id="id2767524" class="indexterm"></a></td><td>和MMU一樣位於CPU核中。</td><td>Cache通常分為幾級，最典型的是如上圖所示的兩級Cache，一級Cache更靠近CPU執行單元，二級Cache更靠近物理內存，通常一級Cache有幾十到幾百KB，二級Cache有幾百KB到幾MB。</td><td>Cache和內存都是由RAM（Random Access Memory）<a id="id2767548" class="indexterm"></a>組成的，可以根據地址隨機訪問，計算機掉電時RAM中保存的數據會丟失。不同的是，Cache通常由SRAM（Static RAM，靜態RAM）<a id="id2767558" class="indexterm"></a>組成，而內存通常由DRAM（Dynamic RAM，動態RAM）<a id="id2767566" class="indexterm"></a>組成。DRAM電路比SRAM簡單，存儲容量可以做得更大，但DRAM的訪問速度比SRAM慢。</td><td>典型的訪問時間是幾十納秒。</td><td>Cache緩存最近訪問過的內存數據，由於Cache的訪問速度是內存的幾十倍，所以有效利用Cache可以大大提高計算機的整體性能。一級Cache是這樣工作的：CPU執行單元要訪問內存時首先發出VA，Cache利用VA查找相應的數據有沒有被緩存，如果Cache中有就不需要訪問物理內存了，如果是讀操作就直接將Cache中的數據傳給CPU寄存器，如果是寫操作就直接改寫到Cache中；如果Cache沒有緩存該數據，就去物理內存中取數據，但並不是要哪個位元組就取哪個位元組，而是把相鄰的幾十個位元組都取上來緩存着，以備下次用到，這稱為一個Cache Line<a id="id2767606" class="indexterm"></a>，典型的Cache Line大小是32~256位元組。如果計算機還配置了二級緩存，則在訪問物理內存之前先用PA去二級緩存中查找。一級緩存是用VA定址的，二級緩存是用PA定址的，這是它們的區別。Cache所做的工作是由硬件自動完成的，而不是像寄存器一樣由指令決定先做什麼後做什麼。</td></tr><tr><td>內存</td><td>位於CPU外的晶片，與CPU通過地址和數據匯流排相連。</td><td>典型的存儲容量是幾百MB到幾GB。</td><td>由DRAM組成，詳見上面關於Cache的說明。</td><td>典型的訪問時間是幾百納秒。</td><td>內存是通過地址來訪問的，在啟用MMU的情況下，程序指令中的地址是VA，而訪問內存用的是PA，它們之間的映射關係由操作系統維護。</td></tr><tr><td>硬碟</td><td>位於設備匯流排上，並不直接和CPU相連，CPU通過設備匯流排的控製器訪問硬碟。</td><td>典型的存儲容量是幾百GB到幾TB。</td><td>硬碟由磁性介質和磁頭組成，訪問硬碟時存在機械運動，磁頭要移動，磁性介質要旋轉，機械運動的速度很難提高到電子的速度，所以訪問速度很受限制。保存在硬碟上的數據掉電後不會丟失。</td><td>典型的訪問時間是幾毫秒，是寄存器訪問時間的10<sup>6</sup>倍。</td><td>由驅動程式操作設備匯流排控製器去訪問。由於硬碟的訪問速度較慢，操作系統通常一次從硬碟上讀幾個頁面到內存中緩存起來，如果這幾個頁面後來都被程序訪問到了，那麼這一次讀硬碟的時間就可以分攤（Amortize）<a id="id2767689" class="indexterm"></a>給程序的多次訪問了。</td></tr></tbody></table></div></div><br class="table-break" /><p>對這個表格總結如下。</p><div class="itemizedlist"><ul type="disc"><li><p>寄存器、Cache和內存中的數據都是掉電丟失的，這稱為易失性存儲器（Volatile Memory）<a id="id2767713" class="indexterm"></a>，與之相對的，硬碟是一種非易失性存儲器（Non-volatile Memory）<a id="id2767722" class="indexterm"></a>。</p></li><li><p>除了訪問寄存器由程序指令直接控制之外，訪問其它存儲器都不是由指令直接控制的，有些是硬件自動完成的，有些是操作系統配合硬件完成的。</p></li><li><p>Cache從內存取數據時會預取一個Cache Line緩存起來，操作系統從硬碟讀數據時會預讀幾個頁面緩存起來，都是希望這些數據以後會被程序訪問到。大多數程序的行為都具有局部性（Locality）<a id="id2767749" class="indexterm"></a>的特點：它們會花費大量的時間反覆執行一小段代碼（例如循環），或者反覆訪問一個很小的地址範圍中的數據（例如訪問一個數組）。所以預讀緩存的辦法是很有效的：CPU取一條指令，我把和它相鄰的指令也都緩存起來，CPU很可能馬上就會取到；CPU訪問一個數據，我把和它相鄰的數據也都緩存起來，CPU很可能馬上就會訪問到。設想有兩台計算機，一台有256KB的Cache，另一台沒有Cache，兩台計算機的內存都是512MB的，硬碟都是100GB的，雖然多出來256KB的Cache與內存、硬碟的容量相比微不足道，但訪問Cache比訪問內存、硬碟快幾個數量級，由於局部性原理，CPU大部分時間是在和Cache打交道，有Cache的計算機明顯會快很多。高速存儲器的容量只能做得很小，卻能顯著提升計算機的性能，這就是Memory Hierarchy的意義所在。</p></li></ul></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch17s04.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch17.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch18.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">4. MMU </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 第 18 章 x86彙編程序基礎</td></tr></table></div></body></html>
