<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>1. 預備知識</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch37.html" title="第 37 章 socket編程" /><link rel="prev" href="ch37.html" title="第 37 章 socket編程" /><link rel="next" href="ch37s02.html" title="2. 基于TCP協議的網絡程序" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1. 預備知識</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch37.html">上一頁</a> </td><th width="60%" align="center">第 37 章 socket編程</th><td width="20%" align="right"> <a accesskey="n" href="ch37s02.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2902215"></a>1. 預備知識</h2></div></div></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2902826"></a>1.1. 網絡位元組序</h3></div></div></div><p>我們已經知道，內存中的多位元組數據相對於內存地址有大端和小端之分，磁碟檔案中的多位元組數據相對於檔案中的偏移地址也有大端小端之分。網絡數據流同樣有大端小端之分，那麼如何定義網絡數據流的地址呢？發送主機通常將發送緩衝區中的數據按內存地址從低到高的順序發出，接收主機把從網絡上接到的位元組依次保存在接收緩衝區中，也是按內存地址從低到高的順序保存，因此，網絡數據流的地址應這樣規定：先發出的數據是低地址，後發出的數據是高地址。</p><p>TCP/IP協議規定，網絡數據流應採用大端位元組序，即低地址高位元組。例如上一節的UDP段格式，地址0-1是16位的源連接埠號，如果這個連接埠號是1000（0x3e8），則地址0是0x03，地址1是0xe8，也就是先發0x03，再發0xe8，這16位在發送主機的緩衝區中也應該是低地址存0x03，高地址存0xe8。但是，如果發送主機是小端位元組序的，這16位被解釋成0xe803，而不是1000。因此，發送主機把1000填到發送緩衝區之前需要做位元組序的轉換。同樣地，接收主機如果是小端位元組序的，接到16位的源連接埠號也要做位元組序的轉換。如果主機是大端位元組序的，發送和接收都不需要做轉換。同理，32位的IP地址也要考慮網絡位元組序和主機位元組序的問題。</p><p>為使網絡程序具有可移植性，使同樣的C代碼在大端和小端計算機上編譯後都能正常運行，可以調用以下庫函數做網絡位元組序和主機位元組序的轉換。</p><pre class="programlisting">#include &lt;arpa/inet.h&gt;

uint32_t htonl(uint32_t hostlong);
uint16_t htons(uint16_t hostshort);
uint32_t ntohl(uint32_t netlong);
uint16_t ntohs(uint16_t netshort);</pre><p>這些函數名很好記，h表示host，n表示network，l表示32位長整數，s表示16位短整數。例如htonl表示將32位的長整數從主機位元組序轉換為網絡位元組序，例如將IP地址轉換後準備發送。如果主機是小端位元組序，這些函數將參數做相應的大小端轉換然後返回，如果主機是大端位元組序，這些函數不做轉換，將參數原封不動地返回。</p></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2902915"></a>1.2. socket地址的數據類型及相關函數</h3></div></div></div><p>socket API是一層抽象的網絡編程介面，適用於各種底層網絡協議，如IPv4、IPv6，以及後面要講的UNIX Domain Socket。然而，各種網絡協議的地址格式並不相同，如下圖所示：</p><div class="figure"><a id="id2902932"></a><p class="title"><b>圖 37.1. sockaddr資料結構</b></p><div class="figure-contents"><div><img src="images/socket.sockaddr.png" alt="sockaddr資料結構" /></div></div></div><br class="figure-break" /><p>IPv4和IPv6的地址格式定義在<code class="literal">netinet/in.h</code>中，IPv4地址用sockaddr_in結構體表示，包括16位連接埠號和32位IP地址，IPv6地址用sockaddr_in6結構體表示，包括16位連接埠號、128位IP地址和一些控制欄位。UNIX Domain Socket的地址格式定義在<code class="literal">sys/un.h</code>中，用sockaddr_un結構體表示。各種socket地址結構體的開頭都是相同的，前16位表示整個結構體的長度（並不是所有UNIX的實現都有長度欄位，如Linux就沒有），後16位表示地址類型。IPv4、IPv6和UNIX Domain Socket的地址類型分別定義為常數AF_INET、AF_INET6、AF_UNIX。這樣，只要取得某種sockaddr結構體的首地址，不需要知道具體是哪種類型的sockaddr結構體，就可以根據地址類型欄位確定結構體中的內容。因此，socket API可以接受各種類型的sockaddr結構體指針做參數，例如bind、accept、connect等函數，這些函數的參數應該設計成void *類型以便接受各種類型的指針，但是sock API的實現早于ANSI C標準化，那時還沒有void *類型，因此這些函數的參數都用struct sockaddr *類型表示，在傳遞參數之前要強制類型轉換一下，例如：</p><pre class="programlisting">struct sockaddr_in servaddr;
/* initialize servaddr */
bind(listen_fd, (struct sockaddr *)&amp;servaddr, sizeof(servaddr));</pre><p>本節只介紹基于IPv4的socket網絡編程，sockaddr_in中的成員struct in_addr sin_addr表示32位的IP地址。但是我們通常用點分十進制的字元串表示IP地址，以下函數可以在字元串表示和in_addr表示之間轉換。</p><p>字元串轉in_addr的函數：</p><pre class="programlisting">#include &lt;arpa/inet.h&gt;

int inet_aton(const char *strptr, struct in_addr *addrptr);
in_addr_t inet_addr(const char *strptr);
int inet_pton(int family, const char *strptr, void *addrptr);</pre><p>in_addr轉字元串的函數：</p><pre class="programlisting">char *inet_ntoa(struct in_addr inaddr);
const char *inet_ntop(int family, const void *addrptr, char *strptr, size_t len);</pre><p>其中inet_pton和inet_ntop不僅可以轉換IPv4的in_addr，還可以轉換IPv6的in6_addr，因此函數介面是void *addrptr。</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch37.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch37.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch37s02.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">第 37 章 socket編程 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 2. 基于TCP協議的網絡程序</td></tr></table></div></body></html>
