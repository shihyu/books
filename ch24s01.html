<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>1. 本章的預備知識</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch24.html" title="第 24 章 函數介面" /><link rel="prev" href="ch24.html" title="第 24 章 函數介面" /><link rel="next" href="ch24s02.html" title="2. 傳入參數與傳出參數" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1. 本章的預備知識</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch24.html">上一頁</a> </td><th width="60%" align="center">第 24 章 函數介面</th><td width="20%" align="right"> <a accesskey="n" href="ch24s02.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2818430"></a>1. 本章的預備知識</h2></div></div></div><p>這一節介紹本章的範例代碼要用的幾個C標準庫函數。我們先體會一下這幾個函數的介面是怎麼設計的，Man Page是怎麼寫的。其它常用的C標準庫函數將在下一章介紹。</p><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2819066"></a>1.1. <code class="literal">strcpy</code>與<code class="literal">strncpy</code></h3></div></div></div><p>從現在開始我們要用到很多庫函數，在學習每個庫函數時一定要看Man Page。Man Page隨時都在我們手邊，想查什麼只要敲一個命令就行，然而很多初學者就是不喜歡看Man Page，寧可滿世界去查書、查資料，也不願意看Man Page。據我分析原因有三：</p><div class="orderedlist"><ol type="1"><li><p>英文不好。那還是先學好了英文再學編程吧，否則即使你把這本書都學透了也一樣無法勝任開發工作，因為你沒有進一步學習的能力。</p></li><li><p>Man Page的語言不夠友好。Man Page不像本書這樣由淺入深地講解，而是平鋪直敘，不過看習慣了就好了，每個Man Page都不長，多看幾遍自然可以抓住重點，理清頭緒。本節分析一個例子，幫助讀者把握Man Page的語言特點。</p></li><li><p>Man Page通常沒有例子。描述一個函數怎麼用，一靠介面，二靠文檔，而不是靠例子。函數的用法無非是本章所總結的幾種模式，只要把本章學透了，你就不需要每個函數都得有個例子教你怎麼用了。</p></li></ol></div><p>總之，Man Page是一定要看的，一開始看不懂硬着頭皮也要看，為了鼓勵讀者看Man Page，本書不會像<a class="xref" href="bi01.html#bibli.kr" title="The C Programming Language">[<abbr class="abbrev">K&amp;R</abbr>]</a>那樣把庫函數總結成一個附錄附在書後面。現在我們來分析<code class="literal">strcpy(3)</code>。</p><div class="figure"><a id="id2819154"></a><p class="title"><b>圖 24.1. <code class="literal">strcpy(3)</code></b></p><div class="figure-contents"><div><img src="images/interface.synopsis.png" alt="strcpy(3)" /></div></div></div><br class="figure-break" /><p>這個Man Page描述了兩個函數，<code class="literal">strcpy</code>和<code class="literal">strncpy</code>，敲命令<code class="literal">man strcpy</code>或者<code class="literal">man strncpy</code>都可以看到這個Man Page。這兩個函數的作用是把一個字元串拷貝給另一個字元串。<span class="emphasis"><em>SYNOPSIS</em></span>部分給出了這兩個函數的原型，以及要用這些函數需要包含哪些標頭檔。參數<code class="literal">dest</code>、<code class="literal">src</code>和<code class="literal">n</code>都加了下劃線，有時候並不想從頭到尾閲讀整個Man Page，而是想查一下某個參數的含義，通過下劃線和參數名就能很快找到你關心的部分。</p><p><code class="literal">dest</code>表示Destination，<code class="literal">src</code>表示Source，看名字就能猜到是把<code class="literal">src</code>所指向的字元串拷貝到<code class="literal">dest</code>所指向的內存空間。這一點從兩個參數的類型也能看出來，<code class="literal">dest</code>是<code class="literal">char *</code>型的，而<code class="literal">src</code>是<code class="literal">const char *</code>型的，說明<code class="literal">src</code>所指向的內存空間在函數中只能讀不能改寫，而<code class="literal">dest</code>所指向的內存空間在函數中是要改寫的，顯然改寫的目的是當函數返回後調用者可以讀取改寫的結果。因此可以猜到<code class="literal">strcpy</code>函數是這樣用的：</p><pre class="programlisting">char buf[10];
strcpy(buf, "hello");
printf(buf);</pre><p>至于<code class="literal">strncpy</code>的參數<code class="literal">n</code>是幹什麼用的，單從函數介面猜不出來，就需要看下面的文檔。</p><div class="figure"><a id="id2819320"></a><p class="title"><b>圖 24.2. <code class="literal">strcpy(3)</code></b></p><div class="figure-contents"><div><img src="images/interface.description.png" alt="strcpy(3)" /></div></div></div><br class="figure-break" /><p>在文檔中強調了<code class="literal">strcpy</code>在拷貝字元串時會把結尾的<code class="literal">'\0'</code>也拷到<code class="literal">dest</code>中，因此保證了<code class="literal">dest</code>中是以<code class="literal">'\0'</code>結尾的字元串。但另外一個要注意的問題是，<code class="literal">strcpy</code>只知道<code class="literal">src</code>字元串的首地址，不知道長度，它會一直拷貝到<code class="literal">'\0'</code>為止，所以<code class="literal">dest</code>所指向的內存空間要足夠大，否則有可能寫越界，例如：</p><pre class="programlisting">char buf[10];
strcpy(buf, "hello world");</pre><p>如果沒有保證<code class="literal">src</code>所指向的內存空間以<code class="literal">'\0'</code>結尾，也有可能讀越界，例如：</p><pre class="programlisting">char buf[10] = "abcdefghij", str[4] = "hell";
strcpy(buf, str);</pre><p>因為<code class="literal">strcpy</code>函數的實現者通過函數介面無法得知<code class="literal">src</code>字元串的長度和<code class="literal">dest</code>內存空間的大小，所以“<span class="quote">確保不會寫越界</span>”應該是調用者的責任，調用者提供的<code class="literal">dest</code>參數應該指向足夠大的內存空間，“<span class="quote">確保不會讀越界</span>”也是調用者的責任，調用者提供的<code class="literal">src</code>參數指向的內存應該確保以<code class="literal">'\0'</code>結尾。</p><p>此外，文檔中還強調了<code class="literal">src</code>和<code class="literal">dest</code>所指向的內存空間不能有重疊。凡是有指針參數的C標準庫函數基本上都有這條要求，每個指針參數所指向的內存空間互不重疊，例如這樣調用是不允許的：</p><pre class="programlisting">char buf[10] = "hello";
strcpy(buf, buf+1);</pre><p><code class="literal">strncpy</code>的參數<code class="literal">n</code>指定最多從<code class="literal">src</code>中拷貝<code class="literal">n</code>個位元組到<code class="literal">dest</code>中，換句話說，如果拷貝到<code class="literal">'\0'</code>就結束，如果拷貝到<code class="literal">n</code>個位元組還沒有碰到<code class="literal">'\0'</code>，那麼也結束，調用者負責提供適當的<code class="literal">n</code>值，以確保讀寫不會越界，比如讓<code class="literal">n</code>的值等於<code class="literal">dest</code>所指向的內存空間的大小：</p><pre class="programlisting">char buf[10];
strncpy(buf, "hello world", sizeof(buf));</pre><p>然而這意味着什麼呢？文檔中特別用了<span class="emphasis"><em>Warning</em></span>指出，這意味着<code class="literal">dest</code>有可能不是以<code class="literal">'\0'</code>結尾的。例如上面的調用，雖然把<code class="literal">"hello world"</code>截斷到10個字元拷貝至<code class="literal">buf</code>中，但<code class="literal">buf</code>不是以<code class="literal">'\0'</code>結尾的，如果再<code class="literal">printf(buf)</code>就會讀越界。如果你需要確保<code class="literal">dest</code>以<code class="literal">'\0'</code>結束，可以這麼調用：</p><pre class="programlisting">char buf[10];
strncpy(buf, "hello world", sizeof(buf));
buf[sizeof(buf)-1] = '\0';</pre><p><code class="literal">strncpy</code>還有一個特性，如果<code class="literal">src</code>字元串全部拷完了不足<code class="literal">n</code>個位元組，那麼還差多少個位元組就補多少個<code class="literal">'\0'</code>，但是正如上面所述，這並不保證<code class="literal">dest</code>一定以<code class="literal">'\0'</code>結束，當<code class="literal">src</code>字元串的長度大於<code class="literal">n</code>時，不但不補多餘的<code class="literal">'\0'</code>，連字元串的結尾<code class="literal">'\0'</code>也不拷貝。<code class="literal">strcpy(3)</code>的文檔已經相當友好了，為了幫助理解，還給出一個<code class="literal">strncpy</code>的簡單實現。</p><div class="figure"><a id="id2819716"></a><p class="title"><b>圖 24.3. <code class="literal">strcpy(3)</code></b></p><div class="figure-contents"><div><img src="images/interface.return.png" alt="strcpy(3)" /></div></div></div><br class="figure-break" /><p>函數的Man Page都有一部分專門講返回值的。這兩個函數的返回值都是<code class="literal">dest</code>指針。可是為什麼要返回<code class="literal">dest</code>指針呢？<code class="literal">dest</code>指針本來就是調用者傳過去的，再返回一遍<code class="literal">dest</code>指針並沒有提供任何有用的信息。之所以這麼規定是為了把函數調用當作一個指針類型的表達式使用，比如<code class="literal">printf("%s\n", strcpy(buf, "hello"))</code>，一舉兩得，如果<code class="literal">strcpy</code>的返回值是<code class="literal">void</code>就沒有這麼方便了。</p><p><span class="emphasis"><em>CONFORMING TO</em></span>部分描述了這個函數是遵照哪些標準實現的。<code class="literal">strcpy</code>和<code class="literal">strncpy</code>是C標準庫函數，當然遵照C99標準。以後我們還會看到<code class="literal">libc</code>中有些函數屬於POSIX標準但並不屬於C標準，例如<code class="literal">write(2)</code>。</p><p><span class="emphasis"><em>NOTES</em></span>部分給出一些提示信息。這裡指出如何確保<code class="literal">strncpy</code>的<code class="literal">dest</code>以<code class="literal">'\0'</code>結尾，和我們上面給出的代碼類似，但由於<code class="literal">n</code>是個變數，在執行<code class="literal">buf[n - 1]= '\0';</code>之前先檢查一下<code class="literal">n</code>是否大於0，如果<code class="literal">n</code>不大於0，<code class="literal">buf[n - 1]</code>就訪問越界了，所以要避免。</p><div class="figure"><a id="id2819873"></a><p class="title"><b>圖 24.4. <code class="literal">strcpy(3)</code></b></p><div class="figure-contents"><div><img src="images/interface.bugs.png" alt="strcpy(3)" /></div></div></div><br class="figure-break" /><p><span class="emphasis"><em>BUGS</em></span>部分說明了使用這些函數可能引起的Bug，這部分一定要仔細看。用<code class="literal">strcpy</code>比用<code class="literal">strncpy</code>更加不安全，如果在調用<code class="literal">strcpy</code>之前不仔細檢查<code class="literal">src</code>字元串的長度就有可能寫越界，這是一個很常見的錯誤，例如：</p><pre class="programlisting">void foo(char *str)
{
	char buf[10];
	strcpy(buf, str);
	...
}</pre><p><code class="literal">str</code>所指向的字元串有可能超過10個字元而導致寫越界，在<a class="xref" href="ch10s04.html#gdb.segfault">第 4 節 “段錯誤”</a>我們看到過，這種寫越界可能當時不出錯，而在函數返回時出現段錯誤，原因是寫越界覆蓋了保存在棧幀上的返回地址，函數返回時跳轉到非法地址，因而出錯。像<code class="literal">buf</code>這種由調用者分配並傳給函數讀或寫的一段內存通常稱為緩衝區（Buffer）<a id="id2819951" class="indexterm"></a>，緩衝區寫越界的錯誤稱為緩衝區溢出（Buffer Overflow）<a id="id2819959" class="indexterm"></a>。如果只是出現段錯誤那還不算嚴重，更嚴重的是緩衝區溢出Bug經常被惡意用戶利用，使函數返回時跳轉到一個事先設好的地址，執行事先設好的指令，如果設計得巧妙甚至可以啟動一個Shell，然後隨心所欲執行任何命令，可想而知，如果一個用<code class="literal">root</code>權限執行的程序存在這樣的Bug，被攻陷了，後果將很嚴重。至于怎樣巧妙設計和攻陷一個有緩衝區溢出Bug的程序，有興趣的讀者可以參考<a class="xref" href="bi01.html#bibli.smashstack" title="Smashing The Stack For Fun And Profit，網上到處都可以搜到這篇文章">[<abbr class="abbrev">SmashStack</abbr>]</a>。</p><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h4 class="title"><a id="id2819997"></a>習題</h4></div></div></div><p>1、自己實現一個<code class="literal">strcpy</code>函數，儘可能簡潔，按照本書的編碼風格你能用三行代碼寫出函數體嗎？</p><p>2、編一個函數，輸入一個字元串，要求做一個新字元串，把其中所有的一個或多個連續的空白字元都壓縮為一個空格。這裡所說的空白包括空格、'\t'、'\n'、'\r'。例如原來的字元串是：</p><pre class="programlisting">This Content hoho       is ok
        ok?

        file system
uttered words   ok ok      ?
end.</pre><p>壓縮了空白之後就是：</p><pre class="programlisting">This Content hoho is ok ok? file system uttered words ok ok ? end.</pre><p>實現該功能的函數介面要求符合下述規範：</p><pre class="programlisting">char *shrink_space(char *dest, const char *src, size_t n);</pre><p>各項參數和返回值的含義和<code class="literal">strncpy</code>類似。完成之後，為自己實現的函數寫一個Man Page。</p></div></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2820062"></a>1.2. <code class="literal">malloc</code>與<code class="literal">free</code></h3></div></div></div><p>程序中需要動態分配一塊內存時怎麼辦呢？可以像上一節那樣定義一個緩衝區數組。這種方法不夠靈活，C89要求定義的數組是固定長度的，而程序往往在運行時才知道要動態分配多大的內存，例如：</p><pre class="programlisting">void foo(char *str, int n)
{
	char buf[?];
	strncpy(buf, str, n);
	...
}</pre><p><code class="literal">n</code>是由參數傳進來的，事先不知道是多少，那麼<code class="literal">buf</code>該定義多大呢？在<a class="xref" href="ch08s01.html#array.intro">第 1 節 “數組的基本概念”</a>講過C99引入VLA特性，可以定義<code class="literal">char buf[n+1] = {};</code>，這樣可確保<code class="literal">buf</code>是以<code class="literal">'\0'</code>結尾的。但即使用VLA仍然不夠靈活，VLA是在棧上動態分配的，函數返回時就要釋放，如果我們希望動態分配一塊全局的內存空間，在各函數中都可以訪問呢？由於全局數組無法定義成VLA，所以仍然不能滿足要求。</p><p>其實在<a class="xref" href="ch20s05.html#link.vm">第 5 節 “虛擬內存管理”</a>提過，進程有一個堆空間，C標準庫函數<code class="literal">malloc</code>可以在堆空間動態分配內存，它的底層通過<code class="literal">brk</code>系統調用向操作系統申請內存。動態分配的內存用完之後可以用<code class="literal">free</code>釋放，更準確地說是歸還給<code class="literal">malloc</code>，這樣下次調用<code class="literal">malloc</code>時這塊內存可以再次被分配。本節學習這兩個函數的用法和工作原理。</p><pre class="programlisting">#include &lt;stdlib.h&gt;

void *malloc(size_t size);
返回值：成功返回所分配內存空間的首地址，出錯返回NULL

void free(void *ptr);</pre><p><code class="literal">malloc</code>的參數<code class="literal">size</code>表示要分配的位元組數，如果分配失敗（可能是由於系統內存耗盡）則返回<code class="literal">NULL</code>。由於<code class="literal">malloc</code>函數不知道用戶拿到這塊內存要存放什麼類型的數據，所以返回通用指針<code class="literal">void *</code>，用戶程序可以轉換成其它類型的指針再訪問這塊內存。<code class="literal">malloc</code>函數保證它返回的指針所指向的地址滿足系統的對齊要求，例如在32位平台上返回的指針一定對齊到4位元組邊界，以保證用戶程序把它轉換成任何類型的指針都能用。</p><p>動態分配的內存用完之後可以用<code class="literal">free</code>釋放掉，傳給<code class="literal">free</code>的參數正是先前<code class="literal">malloc</code>返回的內存塊首地址。舉例如下：</p><div class="example"><a id="id2820249"></a><p class="title"><b>例 24.1. malloc和free</b></p><div class="example-contents"><pre class="programlisting">#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

typedef struct {
	int number;
	char *msg;
} unit_t;

int main(void)
{
	unit_t *p = malloc(sizeof(unit_t));

	if (p == NULL) {
		printf("out of memory\n");
		exit(1);
	}
	p-&gt;number = 3;
	p-&gt;msg = malloc(20);
	strcpy(p-&gt;msg, "Hello world!");
	printf("number: %d\nmsg: %s\n", p-&gt;number, p-&gt;msg);
	free(p-&gt;msg);
	free(p);
	p = NULL;

	return 0;
}</pre></div></div><br class="example-break" /><p>關於這個程序要注意以下幾點：</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">unit_t *p = malloc(sizeof(unit_t));</code>這一句，等號右邊是<code class="literal">void *</code>類型，等號左邊是<code class="literal">unit_t *</code>類型，編譯器會做隱式類型轉換，我們講過<code class="literal">void *</code>類型和任何指針類型之間可以相互隱式轉換。</p></li><li><p>雖然內存耗儘是很不常見的錯誤，但寫程序要規範，<code class="literal">malloc</code>之後應該判斷是否成功。以後要學習的大部分系統函數都有成功的返回值和失敗的返回值，每次調用系統函數都應該判斷是否成功。</p></li><li><p><code class="literal">free(p);</code>之後，<code class="literal">p</code>所指的內存空間是歸還了，但是<code class="literal">p</code>的值並沒有變，因為從<code class="literal">free</code>的函數介面來看根本就沒法改變<code class="literal">p</code>的值，<code class="literal">p</code>現在指向的內存空間已經不屬於用戶，換句話說，<code class="literal">p</code>成了野指針，為避免出現野指針，我們應該在<code class="literal">free(p);</code>之後手動置<code class="literal">p = NULL;</code>。</p></li><li><p>應該先<code class="literal">free(p-&gt;msg)</code>，再<code class="literal">free(p)</code>。如果先<code class="literal">free(p)</code>，<code class="literal">p</code>成了野指針，就不能再通過<code class="literal">p-&gt;msg</code>訪問內存了。</p></li></ul></div><p>上面的例子只有一個簡單的順序控制流程，分配內存，賦值，打印，釋放內存，退出程序。這種情況下即使不用<code class="literal">free</code>釋放內存也可以，因為程序退出時整個進程地址空間都會釋放，包括堆空間，該進程占用的所有內存都會歸還給操作系統。但如果一個程序長年累月運行（例如網絡伺服器程序），並且在循環或遞歸中調用<code class="literal">malloc</code>分配內存，則必須有<code class="literal">free</code>與之配對，分配一次就要釋放一次，否則每次循環都分配內存，分配完了又不釋放，就會慢慢耗盡系統內存，這種錯誤稱為內存泄漏（Memory Leak）<a id="id2820441" class="indexterm"></a>。另外，<code class="literal">malloc</code>返回的指針一定要保存好，只有把它傳給<code class="literal">free</code>才能釋放這塊內存，如果這個指針丟失了，就沒有辦法<code class="literal">free</code>這塊內存了，也會造成內存泄漏。例如：</p><pre class="programlisting">void foo(void)
{
	char *p = malloc(10);
	...
}</pre><p><code class="literal">foo</code>函數返回時要釋放局部變數<code class="literal">p</code>的內存空間，它所指向的內存地址就丟失了，這10個位元組也就沒法釋放了。內存泄漏的Bug很難找到，因為它不會像訪問越界一樣導致程序運行錯誤，少量內存泄漏並不影響程序的正確運行，大量的內存泄漏會使系統內存緊缺，導致頻繁換頁，不僅影響噹前進程，而且把整個系統都拖得很慢。</p><p>關於<code class="literal">malloc</code>和<code class="literal">free</code>還有一些特殊情況。<code class="literal">malloc(0)</code>這種調用也是合法的，也會返回一個非<code class="literal">NULL</code>的指針，這個指針也可以傳給<code class="literal">free</code>釋放，但是不能通過這個指針訪問內存。<code class="literal">free(NULL)</code>也是合法的，不做任何事情，但是<code class="literal">free</code>一個野指針是不合法的，例如先調用<code class="literal">malloc</code>返回一個指針<code class="literal">p</code>，然後連着調用兩次<code class="literal">free(p);</code>，則後一次調用會產生運行時錯誤。</p><p><a class="xref" href="bi01.html#bibli.kr" title="The C Programming Language">[<abbr class="abbrev">K&amp;R</abbr>]</a>的8.7節給出了<code class="literal">malloc</code>和<code class="literal">free</code>的簡單實現，基于環形鏈表。目前讀者還沒有學習鏈表，看那段代碼會有點困難，我再做一些簡化，圖示如下，目的是讓讀者理解<code class="literal">malloc</code>和<code class="literal">free</code>的工作原理。<code class="literal">libc</code>的實現比這要複雜得多，但基本工作原理也是如此。讀者只要理解了基本工作原理，就很容易分析在使用<code class="literal">malloc</code>和<code class="literal">free</code>時遇到的各種Bug了。</p><div class="figure"><a id="id2820626"></a><p class="title"><b>圖 24.5. 簡單的<code class="literal">malloc</code>和<code class="literal">free</code>實現</b></p><div class="figure-contents"><div><img src="images/interface.malloc.png" alt="簡單的malloc和free實現" /></div></div></div><br class="figure-break" /><p>圖中白色背景的框表示<code class="literal">malloc</code>管理的空閒內存塊，深色背景的框不歸<code class="literal">malloc</code>管，可能是已經分配給用戶的內存塊，也可能不屬於當前進程，Break之上的地址不屬於當前進程，需要通過<code class="literal">brk</code>系統調用向內核申請。每個內存塊開頭都有一個頭節點，裡面有一個指針欄位和一個長度欄位，指針欄位把所有空閒塊的頭節點串在一起，組成一個環形鏈表，長度欄位記錄著頭節點和後面的內存塊加起來一共有多長，以8位元組為單位（也就是以頭節點的長度為單位）。</p><div class="orderedlist"><ol type="1"><li><p>一開始堆空間由一個空閒塊組成，長度為7×8=56位元組，除頭節點之外的長度為48位元組。</p></li><li><p>調用<code class="literal">malloc</code>分配8個位元組，要在這個空閒塊的末尾截出16個位元組，其中新的頭節點占了8個位元組，另外8個位元組返回給用戶使用，注意返回的指針<code class="literal">p1</code>指向頭節點後面的內存塊。</p></li><li><p>又調用<code class="literal">malloc</code>分配16個位元組，又在空閒塊的末尾截出24個位元組，步驟和上一步類似。</p></li><li><p>調用<code class="literal">free</code>釋放<code class="literal">p1</code>所指向的內存塊，內存塊（包括頭節點在內）歸還給了<code class="literal">malloc</code>，現在<code class="literal">malloc</code>管理着兩塊不連續的內存，用環形鏈表串起來。注意這時<code class="literal">p1</code>成了野指針，指向不屬於用戶的內存，<code class="literal">p1</code>所指向的內存地址在Break之下，是屬於當前進程的，所以訪問<code class="literal">p1</code>時不會出現段錯誤，但在訪問<code class="literal">p1</code>時這段內存可能已經被<code class="literal">malloc</code>再次分配出去了，可能會讀到意外改寫數據。另外注意，此時如果通過<code class="literal">p2</code>向右寫越界，有可能覆蓋右邊的頭節點，從而破壞<code class="literal">malloc</code>管理的環形鏈表，<code class="literal">malloc</code>就無法從一個空閒塊的指針欄位找到下一個空閒塊了，找到哪去都不一定，全亂套了。</p></li><li><p>調用<code class="literal">malloc</code>分配16個位元組，現在雖然有兩個空閒塊，各有8個位元組可分配，但是這兩塊不連續，<code class="literal">malloc</code>只好通過<code class="literal">brk</code>系統調用抬高Break，獲得新的內存空間。在<a class="xref" href="bi01.html#bibli.kr" title="The C Programming Language">[<abbr class="abbrev">K&amp;R</abbr>]</a>的實現中，每次調用<code class="literal">sbrk</code>函數時申請1024×8=8192個位元組，在Linux系統上<code class="literal">sbrk</code>函數也是通過<code class="literal">brk</code>實現的，這裡為了畫圖方便，我們假設每次調用<code class="literal">sbrk</code>申請32個位元組，建立一個新的空閒塊。</p></li><li><p>新申請的空閒塊和前一個空閒塊連續，因此可以合併成一個。在能合併時要儘量合併，以免空閒塊越割越小，無法滿足大的分配請求。</p></li><li><p>在合併後的這個空閒塊末尾截出24個位元組，新的頭節點占8個位元組，另外16個位元組返回給用戶。</p></li><li><p>調用<code class="literal">free(p3)</code>釋放這個內存塊，由於它和前一個空閒塊連續，又重新合併成一個空閒塊。注意，Break只能抬高而不能降低，從內核申請到的內存以後都歸<code class="literal">malloc</code>管了，即使調用<code class="literal">free</code>也不會還給內核。</p></li></ol></div><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h4 class="title"><a id="id2820918"></a>習題</h4></div></div></div><p>1、小練習：編寫一個小程序讓它耗盡系統內存。觀察一下，分配了多少內存後才會出現分配失敗？內存耗盡之後會怎麼樣？會不會死機？</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch24.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch24.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch24s02.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">第 24 章 函數介面 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 2. 傳入參數與傳出參數</td></tr></table></div></body></html>
