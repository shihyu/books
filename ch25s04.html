<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>4. 分配內存的函數</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch25.html" title="第 25 章 C標準庫" /><link rel="prev" href="ch25s03.html" title="3. 數值字元串轉換函數" /><link rel="next" href="ch26.html" title="第 26 章 鏈表、二叉樹和哈希表" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4. 分配內存的函數</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch25s03.html">上一頁</a> </td><th width="60%" align="center">第 25 章 C標準庫</th><td width="20%" align="right"> <a accesskey="n" href="ch26.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2835580"></a>4. 分配內存的函數</h2></div></div></div><p>除了<code class="literal">malloc</code>之外，C標準庫還提供了另外兩個在堆空間分配內存的函數，它們分配的內存同樣由<code class="literal">free</code>釋放。</p><pre class="programlisting">#include &lt;stdlib.h&gt;

void *calloc(size_t nmemb, size_t size);
void *realloc(void *ptr, size_t size);
返回值：成功返回所分配內存空間的首地址，出錯返回NULL</pre><p><code class="literal">calloc</code>的參數很像<code class="literal">fread</code>/<code class="literal">fwrite</code>的參數，分配<code class="literal">nmemb</code>個元素的內存空間，每個元素占<code class="literal">size</code>位元組，並且<code class="literal">calloc</code>負責把這塊內存空間用位元組0填充，而<code class="literal">malloc</code>並不負責把分配的內存空間清零。</p><p>有時候用<code class="literal">malloc</code>或<code class="literal">calloc</code>分配的內存空間使用了一段時間之後需要改變它的大小，一種辦法是調用<code class="literal">malloc</code>分配一塊新的內存空間，把原內存空間中的數據拷到新的內存空間，然後調用<code class="literal">free</code>釋放原內存空間。使用<code class="literal">realloc</code>函數簡化了這些步驟，把原內存空間的指針<code class="literal">ptr</code>傳給<code class="literal">realloc</code>，通過參數<code class="literal">size</code>指定新的大小（位元組數），<code class="literal">realloc</code>返回新內存空間的首地址，並釋放原內存空間。新內存空間中的數據儘量和原來保持一致，如果<code class="literal">size</code>比原來小，則前<code class="literal">size</code>個位元組不變，後面的數據被截斷，如果<code class="literal">size</code>比原來大，則原來的數據全部保留，後面長出來的一塊內存空間未初始化（<code class="literal">realloc</code>不負責清零）。注意，參數<code class="literal">ptr</code>要麼是<code class="literal">NULL</code>，要麼必須是先前調用<code class="literal">malloc</code>、<code class="literal">calloc</code>或<code class="literal">realloc</code>返回的指針，不能把任意指針傳給<code class="literal">realloc</code>要求重新分配內存空間。作為兩個特例，如果調用<code class="literal">realloc(NULL, size)</code>，則相當於調用<code class="literal">malloc(size)</code>，如果調用<code class="literal">realloc(ptr, 0)</code>，<code class="literal">ptr</code>不是<code class="literal">NULL</code>，則相當於調用<code class="literal">free(ptr)</code>。</p><pre class="programlisting">#include &lt;alloca.h&gt;

void *alloca(size_t size);
返回值：返回所分配內存空間的首地址，如果size太大導致棧空間耗盡，結果是未定義的</pre><p>參數<code class="literal">size</code>是請求分配的位元組數，<code class="literal">alloca</code>函數不是在堆上分配空間，而是在調用者函數的棧幀上分配空間，類似於C99的變長數組，當調用者函數返回時自動釋放棧幀，所以不需要<code class="literal">free</code>。這個函數不屬於C標準庫，而是在POSIX標準中定義的。</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch25s03.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch25.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch26.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">3. 數值字元串轉換函數 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 第 26 章 鏈表、二叉樹和哈希表</td></tr></table></div></body></html>
