<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>3. open/close</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch28.html" title="第 28 章 檔案與I/O" /><link rel="prev" href="ch28s02.html" title="2. C標準I/O庫函數與Unbuffered I/O函數" /><link rel="next" href="ch28s04.html" title="4. read/write" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. open/close</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch28s02.html">上一頁</a> </td><th width="60%" align="center">第 28 章 檔案與I/O</th><td width="20%" align="right"> <a accesskey="n" href="ch28s04.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2851400"></a>3. open/close</h2></div></div></div><p><code class="literal">open</code>函數可以打開或創建一個檔案。</p><pre class="programlisting">#include &lt;sys/types.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;

int open(const char *pathname, int flags);
int open(const char *pathname, int flags, mode_t mode);
返回值：成功返回新分配的檔案描述符，出錯返回-1並設置errno</pre><p>在Man Page中<code class="literal">open</code>函數有兩種形式，一種帶兩個參數，一種帶三個參數，其實在C代碼中<code class="literal">open</code>函數是這樣聲明的：</p><pre class="programlisting">int open(const char *pathname, int flags, ...);</pre><p>最後的可變參數可以是0個或1個，由<code class="literal">flags</code>參數中的標誌位決定，見下面的詳細說明。</p><p><code class="literal">pathname</code>參數是要打開或創建的檔案名，和<code class="literal">fopen</code>一樣，<code class="literal">pathname</code>既可以是相對路徑也可以是絶對路徑。<code class="literal">flags</code>參數有一系列常數值可供選擇，可以同時選擇多個常數用按位或運算符連接起來，所以這些常數的宏定義都以<code class="literal">O_</code>開頭，表示or。</p><p>必選項：以下三個常數中必須指定一個，且僅允許指定一個。</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">O_RDONLY</code> 只讀打開</p></li><li><p><code class="literal">O_WRONLY</code> 只寫打開</p></li><li><p><code class="literal">O_RDWR</code> 可讀可寫打開</p></li></ul></div><p>以下可選項可以同時指定0個或多個，和必選項按位或起來作為<code class="literal">flags</code>參數。可選項有很多，這裡只介紹一部分，其它選項可參考<code class="literal">open(2)</code>的Man Page：</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">O_APPEND</code> 表示追加。如果檔案已有內容，這次打開檔案所寫的數據附加到檔案的末尾而不覆蓋原來的內容。</p></li><li><p><code class="literal">O_CREAT</code> 若此檔案不存在則創建它。使用此選項時需要提供第三個參數<code class="literal">mode</code>，表示該檔案的訪問權限。</p></li><li><p><code class="literal">O_EXCL</code> 如果同時指定了<code class="literal">O_CREAT</code>，並且檔案已存在，則出錯返回。</p></li><li><p><code class="literal">O_TRUNC</code> 如果檔案已存在，並且以只寫或可讀可寫方式打開，則將其長度截斷（Truncate）<a id="id2851609" class="indexterm"></a>為0位元組。</p></li><li><p><code class="literal">O_NONBLOCK</code> 對於設備檔案，以<code class="literal">O_NONBLOCK</code>方式打開可以做非阻塞I/O（Nonblock I/O）<a id="id2851635" class="indexterm"></a>，非阻塞I/O在下一節詳細講解。</p></li></ul></div><p>注意<code class="literal">open</code>函數與C標準I/O庫的<code class="literal">fopen</code>函數有些細微的區別：</p><div class="itemizedlist"><ul type="disc"><li><p>以可寫的方式<code class="literal">fopen</code>一個檔案時，如果檔案不存在會自動創建，而<code class="literal">open</code>一個檔案時必須明確指定<code class="literal">O_CREAT</code>才會創建檔案，否則檔案不存在就出錯返回。</p></li><li><p>以<code class="literal">w</code>或<code class="literal">w+</code>方式<code class="literal">fopen</code>一個檔案時，如果檔案已存在就截斷為0位元組，而<code class="literal">open</code>一個檔案時必須明確指定<code class="literal">O_TRUNC</code>才會截斷檔案，否則直接在原來的數據上改寫。</p></li></ul></div><p>第三個參數<code class="literal">mode</code>指定檔案權限，可以用八進制數表示，比如0644表示<code class="literal">-rw-r--r--</code>，也可以用<code class="literal">S_IRUSR</code>、<code class="literal">S_IWUSR</code>等宏定義按位或起來表示，詳見<code class="literal">open(2)</code>的Man Page。要注意的是，檔案權限由<code class="literal">open</code>的<code class="literal">mode</code>參數和當前進程的<code class="literal">umask</code>掩碼共同決定。</p><p>補充說明一下Shell的<code class="literal">umask</code>命令。Shell進程的<code class="literal">umask</code>掩碼可以用<code class="literal">umask</code>命令查看：</p><pre class="screen">$ umask
0022</pre><p>用<code class="literal">touch</code>命令創建一個檔案時，創建權限是0666，而<code class="literal">touch</code>進程繼承了Shell進程的<code class="literal">umask</code>掩碼，所以最終的檔案權限是0666&amp;~022=0644。</p><pre class="screen">$ touch file123
$ ls -l file123
-rw-r--r-- 1 akaedu akaedu 0 2009-03-08 15:07 file123</pre><p>同樣道理，用<code class="literal">gcc</code>編譯生成一個執行檔時，創建權限是0777，而最終的檔案權限是0777&amp;~022=0755。</p><pre class="screen">$ gcc main.c
$ ls -l a.out
-rwxr-xr-x 1 akaedu akaedu 6483 2009-03-08 15:07 a.out</pre><p>我們看到的都是被<code class="literal">umask</code>掩碼修改之後的權限，那麼如何證明<code class="literal">touch</code>或<code class="literal">gcc</code>創建檔案的權限本來應該是0666和0777呢？我們可以把Shell進程的<code class="literal">umask</code>改成0，再重複上述實驗：</p><pre class="screen">$ umask 0
$ touch file123
$ rm file123 a.out
$ touch file123
$ ls -l file123
-rw-rw-rw- 1 akaedu akaedu 0 2009-03-08 15:09 file123
$ gcc main.c
$ ls -l a.out
-rwxrwxrwx 1 akaedu akaedu 6483 2009-03-08 15:09 a.out</pre><p>現在我們自己寫一個程序，在其中調用<code class="literal">open("somefile", O_WRONLY|O_CREAT, 0664);</code>創建檔案，然後在Shell中運行並查看結果：</p><pre class="screen">$ umask 022
$ ./a.out
$ ls -l somefile
-rw-r--r-- 1 akaedu akaedu 6483 2009-03-08 15:11 somefile</pre><p>不出所料，檔案<code class="literal">somefile</code>的權限是0664&amp;~022=0644。有幾個問題現在我沒有解釋：為什麼被Shell啟動的進程可以繼承Shell進程的<code class="literal">umask</code>掩碼？為什麼<code class="literal">umask</code>命令可以讀寫Shell進程的<code class="literal">umask</code>掩碼？這些問題將在<a class="xref" href="ch30s01.html#process.intro">第 1 節 “引言”</a>解釋。</p><p><code class="literal">close</code>函數關閉一個已打開的檔案：</p><pre class="programlisting">#include &lt;unistd.h&gt;

int close(int fd);
返回值：成功返回0，出錯返回-1並設置errno</pre><p>參數<code class="literal">fd</code>是要關閉的檔案描述符。需要說明的是，當一個進程終止時，內核對該進程所有尚未關閉的檔案描述符調用<code class="literal">close</code>關閉，所以即使用戶程序不調用<code class="literal">close</code>，在終止時內核也會自動關閉它打開的所有檔案。但是對於一個長年累月運行的程序（比如網絡伺服器），打開的檔案描述符一定要記得關閉，否則隨着打開的檔案越來越多，會占用大量檔案描述符和系統資源。</p><p>由<code class="literal">open</code>返回的檔案描述符一定是該進程尚未使用的最小描述符。由於程序啟動時自動打開檔案描述符0、1、2，因此第一次調用<code class="literal">open</code>打開檔案通常會返回描述符3，再調用<code class="literal">open</code>就會返回4。可以利用這一點在標準輸入、標準輸出或標准錯誤輸出上打開一個新檔案，實現重定向的功能。例如，首先調用<code class="literal">close</code>關閉檔案描述符1，然後調用<code class="literal">open</code>打開一個常規檔案，則一定會返回檔案描述符1，這時候標準輸出就不再是終端，而是一個常規檔案了，再調用<code class="literal">printf</code>就不會打印到屏幕上，而是寫到這個檔案中了。後面要講的<code class="literal">dup2</code>函數提供了另外一種辦法在指定的檔案描述符上打開檔案。</p><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2852046"></a>習題</h3></div></div></div><p>1、在系統標頭檔中查找<code class="literal">flags</code>和<code class="literal">mode</code>參數用到的這些宏定義的值是多少。把這些宏定義按位或起來是什麼效果？為什麼必選項只能選一個而可選項可以選多個？</p><p>2、請按照下述要求分別寫出相應的<code class="literal">open</code>調用。</p><div class="itemizedlist"><ul type="disc"><li><p>打開檔案<code class="literal">/home/akae.txt</code>用於寫操作，以追加方式打開</p></li><li><p>打開檔案<code class="literal">/home/akae.txt</code>用於寫操作，如果該檔案不存在則創建它</p></li><li><p>打開檔案<code class="literal">/home/akae.txt</code>用於寫操作，如果該檔案已存在則截斷為0位元組，如果該檔案不存在則創建它</p></li><li><p>打開檔案<code class="literal">/home/akae.txt</code>用於寫操作，如果該檔案已存在則報錯退出，如果該檔案不存在則創建它</p></li></ul></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch28s02.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch28.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch28s04.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">2. C標準I/O庫函數與Unbuffered I/O函數 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 4. read/write</td></tr></table></div></body></html>
