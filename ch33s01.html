<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>1. 信號的基本概念</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch33.html" title="第 33 章 信號" /><link rel="prev" href="ch33.html" title="第 33 章 信號" /><link rel="next" href="ch33s02.html" title="2. 產生信號" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1. 信號的基本概念</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch33.html">上一頁</a> </td><th width="60%" align="center">第 33 章 信號</th><td width="20%" align="right"> <a accesskey="n" href="ch33s02.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2883230"></a>1. 信號的基本概念</h2></div></div></div><p>為了理解信號，先從我們最熟悉的場景說起：</p><div class="orderedlist"><ol type="1"><li><p>用戶輸入命令，在Shell下啟動一個前台進程。</p></li><li><p>用戶按下Ctrl-C，這個鍵盤輸入產生一個硬件中斷。</p></li><li><p>如果CPU當前正在執行這個進程的代碼，則該進程的用戶空間代碼暫停執行，CPU從用戶態切換到內核態處理硬件中斷。</p></li><li><p>終端驅動程式將Ctrl-C解釋成一個<code class="literal">SIGINT</code>信號，記在該進程的PCB中（也可以說發送了一個<code class="literal">SIGINT</code>信號給該進程）。</p></li><li><p>當某個時刻要從內核返回到該進程的用戶空間代碼繼續執行之前，首先處理PCB中記錄的信號，發現有一個<code class="literal">SIGINT</code>信號待處理，而這個信號的預設處理動作是終止進程，所以直接終止進程而不再返回它的用戶空間代碼執行。</p></li></ol></div><p>注意，Ctrl-C產生的信號只能發給前台進程。在<a class="xref" href="ch30s03.html#process.wait">第 3.3 節 “wait和waitpid函數”</a>中我們看到一個命令後面加個<code class="literal">&amp;</code>可以放到後台運行，這樣Shell不必等待進程結束就可以接受新的命令，啟動新的進程。Shell可以同時運行一個前台進程和任意多個後台進程，只有前台進程才能接到像Ctrl-C這種修飾鍵產生的信號。前台進程在運行過程中用戶隨時可能按下Ctrl-C而產生一個信號，也就是說該進程的用戶空間代碼執行到任何地方都有可能收到<code class="literal">SIGINT</code>信號而終止，所以信號相對於進程的控制流程來說是非同步（Asynchronous）<a id="id2883948" class="indexterm"></a>的。</p><p>用<code class="literal">kill -l</code>命令可以察看系統定義的信號列表：</p><pre class="screen">$ kill -l
 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL
 5) SIGTRAP      6) SIGABRT      7) SIGBUS       8) SIGFPE
 9) SIGKILL     10) SIGUSR1     11) SIGSEGV     12) SIGUSR2
13) SIGPIPE     14) SIGALRM     15) SIGTERM     16) SIGSTKFLT
17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU
25) SIGXFSZ     26) SIGVTALRM   27) SIGPROF     28) SIGWINCH
29) SIGIO       30) SIGPWR      31) SIGSYS      34) SIGRTMIN
35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3  38) SIGRTMIN+4
...</pre><p>每個信號都有一個編號和一個宏定義名稱，這些宏定義可以在<code class="literal">signal.h</code>中找到，例如其中有定義<code class="literal">#define SIGINT 2</code>。編號34以上的是實時信號，本章只討論編號34以下的信號，不討論實時信號。這些信號各自在什麼條件下產生，預設的處理動作是什麼，在<code class="literal">signal(7)</code>中都有詳細說明：</p><pre class="screen">Signal     Value     Action   Comment
-------------------------------------------------------------------------
SIGHUP        1       Term    Hangup detected on controlling terminal
                              or death of controlling process
SIGINT        2       Term    Interrupt from keyboard
SIGQUIT       3       Core    Quit from keyboard
SIGILL        4       Core    Illegal Instruction
...</pre><p>上表中第一列是各信號的宏定義名稱，第二列是各信號的編號，第三列是預設處理動作，<code class="literal">Term</code>表示終止當前進程，<code class="literal">Core</code>表示終止當前進程並且Core Dump（下一節詳細介紹什麼是Core Dump），<code class="literal">Ign</code>表示忽略該信號，<code class="literal">Stop</code>表示停止當前進程，<code class="literal">Cont</code>表示繼續執行先前停止的進程，表中最後一列是簡要介紹，說明什麼條件下產生該信號。</p><p>產生信號的條件主要有：</p><div class="itemizedlist"><ul type="disc"><li><p>用戶在終端按下某些鍵時，終端驅動程式會發送信號給前台進程，例如Ctrl-C產生<code class="literal">SIGINT</code>信號，Ctrl-\產生<code class="literal">SIGQUIT</code>信號，Ctrl-Z產生<code class="literal">SIGTSTP</code>信號（可使前台進程停止，這個信號將在<a class="xref" href="ch34.html#jobs">第 34 章 <i>終端、作業控制與守護進程</i></a>詳細解釋）。</p></li><li><p>硬件異常產生信號，這些條件由硬件檢測到並通知內核，然後內核向當前進程發送適當的信號。例如當前進程執行了除以0的指令，CPU的運算單元會產生異常，內核將這個異常解釋為<code class="literal">SIGFPE</code>信號發送給進程。再比如當前進程訪問了非法內存地址，，MMU會產生異常，內核將這個異常解釋為<code class="literal">SIGSEGV</code>信號發送給進程。</p></li><li><p>一個進程調用<code class="literal">kill(2)</code>函數可以發送信號給另一個進程。</p></li><li><p>可以用<code class="literal">kill(1)</code>命令發送信號給某個進程，<code class="literal">kill(1)</code>命令也是調用<code class="literal">kill(2)</code>函數實現的，如果不明確指定信號則發送<code class="literal">SIGTERM</code>信號，該信號的預設處理動作是終止進程。</p></li><li><p>當內核檢測到某種軟件條件發生時也可以通過信號通知進程，例如閙鐘超時產生<code class="literal">SIGALRM</code>信號，向讀端已關閉的管道寫數據時產生<code class="literal">SIGPIPE</code>信號。</p></li></ul></div><p>如果不想按預設動作處理信號，用戶程序可以調用<code class="literal">sigaction(2)</code>函數告訴內核如何處理某種信號（<code class="literal">sigaction</code>函數稍後詳細介紹），可選的處理動作有以下三種：</p><div class="orderedlist"><ol type="1"><li><p>忽略此信號。</p></li><li><p>執行該信號的預設處理動作。</p></li><li><p>提供一個信號處理函數，要求內核在處理該信號時切換到用戶態執行這個處理函數，這種方式稱為捕捉（Catch）<a id="id2884226" class="indexterm"></a>一個信號。</p></li></ol></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch33.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch33.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch33s02.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">第 33 章 信號 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 2. 產生信號</td></tr></table></div></body></html>
