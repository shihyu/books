<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>3. Side Effect與Sequence Point</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch16.html" title="第 16 章 運算符詳解" /><link rel="prev" href="ch16s02.html" title="2. 其它運算符" /><link rel="next" href="ch16s04.html" title="4. 運算符總結" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. Side Effect與Sequence Point</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch16s02.html">上一頁</a> </td><th width="60%" align="center">第 16 章 運算符詳解</th><td width="20%" align="right"> <a accesskey="n" href="ch16s04.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2762987"></a>3. Side Effect與Sequence Point</h2></div></div></div><p>如果你只想規規矩矩地寫代碼，那麼基本用不着看這一節。本節的內容基本上是鑽牛角尖兒的，除了Short-circuit比較實用，其它寫法都應該避免使用。但沒辦法，有時候不是你想鑽牛角尖兒，而是有人逼你去鑽牛角尖兒。這是我們的學員在找工作筆試時碰到的問題：</p><pre class="programlisting">int a=0;
a = (++a)+(++a)+(++a)+(++a);</pre><p>據我瞭解，似乎很多公司都有出這種筆試題的惡趣味。答案應該是Undefined，我甚至有些懷疑出題人是否真的知道答案。下面我來解釋為什麼是Undefined。</p><p>我們知道，調用一個函數可能產生Side Effect，使用某些運算符（++ -- = 復合賦值）也會產生Side Effect，如果一個表達式中隱含着多個Side Effect，究竟哪個先發生哪個後發生呢？C標準規定代碼中的某些點是Sequence Point<a id="id2763025" class="indexterm"></a>，當執行到一個Sequence Point時，在此之前的Side Effect必須全部作用完畢，在此之後的Side Effect必須一個都沒發生。至于兩個Sequence Point之間的多個Side Effect哪個先發生哪個後發生則沒有規定，編譯器可以任意選擇各Side Effect的作用順序。下面詳細解釋各種Sequence Point。</p><p>1、調用一個函數時，在所有準備工作做完之後、函數調用開始之前是Sequence Point。比如調用<code class="literal">foo(f(), g())</code>時，<code class="literal">foo</code>、<code class="literal">f()</code>、<code class="literal">g()</code>這三個表達式哪個先求值哪個後求值是Unspecified，但是必須都求值完了才能做最後的函數調用，所以<code class="literal">f()</code>和<code class="literal">g()</code>的Side Effect按什麼順序發生不一定，但必定在這些Side Effect全部作用完之後才開始調用<code class="literal">foo</code>函數。</p><p>2、條件運算符?:、逗號運算符、邏輯與&amp;&amp;、邏輯或||的第一個操作數求值之後是Sequence Point。我們剛講過條件運算符和逗號運算符，條件運算符要根據表達式1的值是否為真決定下一步求表達式2還是表達式3的值，如果決定求表達式2的值，表達式3就不會被求值了，反之也一樣，逗號運算符也是這樣，表達式1求值結束才繼續求表達式2的值。</p><p>邏輯與和邏輯或早在<a class="xref" href="ch04s03.html#cond.bool">第 3 節 “布爾代數”</a>就講了，但在初學階段我一直迴避它們的操作數求值順序問題。這兩個運算符和條件運算符類似，先求左操作數的值，然後根據這個值是否為真，右操作數可能被求值，也可能不被求值。比如<a class="xref" href="ch08s05.html#array.scissor">例 8.5 “剪刀石頭布”</a>這個程序中的這幾句：</p><pre class="programlisting">ret = scanf("%d", &amp;man);
if (ret != 1 || man &lt; 0 || man &gt; 2) {
	printf("Invalid input! Please input 0, 1 or 2.\n");
	continue;
}</pre><p>其實可以寫得更簡單（類似於<a class="xref" href="bi01.html#bibli.kr" title="The C Programming Language">[<abbr class="abbrev">K&amp;R</abbr>]</a>的簡潔風格）：</p><pre class="programlisting">if (scanf("%d", &amp;man) != 1 || man &lt; 0 || man &gt; 2) {
	printf("Invalid input! Please input 0, 1 or 2.\n");
	continue;
}</pre><p>這個控製表達式的求值順序是：先求<code class="literal">scanf("%d", &amp;man) = 1</code>的值，如果<code class="literal">scanf</code>調用失敗，則返回值不等於1成立，||運算有一個操作數為真則整個表達式為真，這時直接執行下一句<code class="literal">printf</code>，根本不會再去求<code class="literal">man &lt; 0</code>或<code class="literal">man &gt; 2</code>的值；如果<code class="literal">scanf</code>調用成功，則讀入的數保存在變數<code class="literal">man</code>中，並且返回值等於1，那麼說它不等於1就不成立了，第一個||運算的左操作數為假，就會去求右操作數<code class="literal">man &lt; 0</code>的值作為整個表達式的值，這時變數<code class="literal">man</code>的值正是<code class="literal">scanf</code>讀上來的值，我們判斷它是否在[0, 2]之間，如果<code class="literal">man &lt; 0</code>不成立，則整個表達式<code class="literal">scanf("%d", &amp;man) != 1 || man &lt; 0 </code>的值為假，也就是第二個||運算的左操作數為假，所以最後求右操作數<code class="literal">man &gt; 2</code>的值作為整個表達式的值。</p><p>&amp;&amp;運算與此類似，<code class="literal">a &amp;&amp; b</code>的計算過程是：首先求表達式<code class="literal">a</code>的值，如果<code class="literal">a</code>的值是假則整個表達式的值是假，不會再去求<code class="literal">b</code>的值；如果<code class="literal">a</code>的值是真，則下一步求<code class="literal">b</code>的值作為整個表達式的值。所以，<code class="literal">a &amp;&amp; b</code>相當於“<span class="quote">if a then b</span>”，而<code class="literal">a || b</code>相當於“<span class="quote">if not a then b</span>”。這種特性稱為Short-circuit<a id="id2763307" class="indexterm"></a>，很多人喜歡利用Short-circuit特性簡化代碼。</p><p>3、在一個完整的聲明末尾是Sequence Point，所謂完整的聲明是指這個聲明不是另外一個聲明的一部分。比如聲明<code class="literal">int a[10], b[20];</code>，在<code class="literal">a[10]</code>末尾是Sequence Point，在<code class="literal">b[20]</code>末尾也是。</p><p>4、在一個完整的表達式末尾是Sequence Point，所謂完整的表達式是指這個表達式不是另外一個表達式的一部分。所以如果有<code class="literal">f(); g();</code>這樣兩條語句，<code class="literal">f()</code>和<code class="literal">g()</code>是兩個完整的表達式，<code class="literal">f()</code>的Side Effect必定在<code class="literal">g()</code>之前發生。</p><p>5、在庫函數即將返回時是Sequence Point。這條規則似乎可以包含在上一條規則裡面，因為函數返回時必然會結束掉一個完整的表達式。而事實上很多庫函數是以宏定義的形式實現的（<a class="xref" href="ch21s02.html#prep.funcmacro">第 2.1 節 “函數式宏定義”</a>），並不是真正的函數，所以才需要有這條規則。</p><p>還有兩種Sequence Point和某些C標準庫函數的執行過程相關，此處從略，有興趣的讀者可參考<a class="xref" href="bi01.html#bibli.c99" title="ISO/IEC 9899: Programming Languages － C">[<abbr class="abbrev">C99</abbr>]</a>的Annex C。</p><p>現在可以分析一下本節開頭的例子了。<code class="literal">a = (++a)+(++a)+(++a)+(++a);</code>的結果之所以是Undefined，因為在這個表達式中有五個Side Effect都在改變<code class="literal">a</code>的值，這些Side Effect按什麼順序發生不一定，只知道在整個表達式求值結束時一定都發生了。比如現在求第二個<code class="literal">++a</code>的值，這時第一個、第三個、第四個<code class="literal">++a</code>的Side Effect發生了沒有，<code class="literal">a</code>的值被加過幾次了，這些都不確定，所以第二個<code class="literal">++a</code>的值也不確定。這行代碼用不同平台的不同編譯器來編譯結果是不同的，甚至在同一平台上用同一編譯器的不同版本來編譯也可能不同。</p><p>寫表達式應遵循的原則一：<span class="emphasis"><em>在兩個Sequence Point之間，同一個變數的值只允許被改變一次</em></span>。僅有這一條原則還不夠，例如<code class="literal">a[i++] = i;</code>的變數<code class="literal">i</code>只改變了一次，但結果仍是Undefined，因為等號左邊改<code class="literal">i</code>的值，等號右邊讀<code class="literal">i</code>的值，到底是先改還是先讀？這個讀寫順序是不確定的。但為什麼<code class="literal">i = i + 1;</code>就沒有歧義呢？雖然也是等號左邊改<code class="literal">i</code>的值，等號右邊讀<code class="literal">i</code>的值，但你不讀出<code class="literal">i</code>的值就沒法計算<code class="literal">i + 1</code>，那拿什麼去改<code class="literal">i</code>的值呢？所以這個讀寫順序是確定的。寫表達式應遵循的原則二：<span class="emphasis"><em>如果在兩個Sequence Point之間既要讀一個變數的值又要改它的值，只有在讀寫順序確定的情況下才可以這麼寫</em></span>。</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch16s02.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch16.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch16s04.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">2. 其它運算符 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 4. 運算符總結</td></tr></table></div></body></html>
