<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>2. Shell如何執行命令</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch31.html" title="第 31 章 Shell腳本" /><link rel="prev" href="ch31s01.html" title="1. Shell的歷史" /><link rel="next" href="ch31s03.html" title="3. Shell的基本語法" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">2. Shell如何執行命令</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch31s01.html">上一頁</a> </td><th width="60%" align="center">第 31 章 Shell腳本</th><td width="20%" align="right"> <a accesskey="n" href="ch31s03.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2872012"></a>2. Shell如何執行命令</h2></div></div></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2872017"></a>2.1. 執行互動式命令</h3></div></div></div><p>用戶在命令行輸入命令後，一般情況下Shell會<code class="literal">fork</code>並<code class="literal">exec</code>該命令，但是Shell的內建命令例外，執行內建命令相當於調用Shell進程中的一個函數，並不創建新的進程。以前學過的<code class="literal">cd</code>、<code class="literal">alias</code>、<code class="literal">umask</code>、<code class="literal">exit</code>等命令即是內建命令，凡是用<code class="literal">which</code>命令查不到程序檔案所在位置的命令都是內建命令，內建命令沒有單獨的man手冊，要在man手冊中查看內建命令，應該</p><pre class="screen">$ man bash-builtins</pre><p>本節會介紹很多內建命令，如<code class="literal">export</code>、<code class="literal">shift</code>、<code class="literal">if</code>、<code class="literal">eval</code>、<code class="literal">[</code>、<code class="literal">for</code>、<code class="literal">while</code>等等。內建命令雖然不創建新的進程，但也會有Exit Status，通常也用0表示成功非零表示失敗，雖然內建命令不創建新的進程，但執行結束後也會有一個狀態碼，也可以用特殊變數<code class="literal">$?</code>讀出。</p><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h4 class="title"><a id="id2872131"></a>習題</h4></div></div></div><p>1、在完成<a class="xref" href="ch30s05.html#process.implementshell">第 5 節 “練習：實現簡單的Shell”</a>時也許有的讀者已經試過了，在自己實現的Shell中不能執行<code class="literal">cd</code>命令，因為<code class="literal">cd</code>是一個內建命令，沒有程序檔案，不能用<code class="literal">exec</code>執行。現在請完善該程序，實現<code class="literal">cd</code>命令的功能，用<code class="literal">chdir(2)</code>函數可以改變進程的當前工作目錄。</p><p>2、思考一下，為什麼<code class="literal">cd</code>命令要實現成內建命令？可不可以實現一個獨立的<code class="literal">cd</code>程序，例如<code class="literal">/bin/cd</code>，就像<code class="literal">/bin/ls</code>一樣？</p></div></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2872211"></a>2.2. 執行腳本</h3></div></div></div><p>首先編寫一個簡單的腳本，保存為<code class="literal">script.sh</code>：</p><div class="example"><a id="id2872225"></a><p class="title"><b>例 31.1. 簡單的Shell腳本</b></p><div class="example-contents"><pre class="programlisting">#! /bin/sh

cd ..
ls</pre></div></div><br class="example-break" /><p>Shell腳本中用<code class="literal">#</code>表示註釋，相當於C語言的<code class="literal">//</code>註釋。但如果<code class="literal">#</code>位於第一行開頭，並且是<code class="literal">#!</code>（稱為Shebang<a id="id2872262" class="indexterm"></a>）則例外，它表示該腳本使用後面指定的解釋器<code class="literal">/bin/sh</code>解釋執行。如果把這個腳本檔案加上可執行權限然後執行：</p><pre class="screen">$ chmod +x script.sh
$ ./script.sh</pre><p>Shell會<code class="literal">fork</code>一個子進程並調用<code class="literal">exec</code>執行<code class="literal">./script.sh</code>這個程序，<code class="literal">exec</code>系統調用應該把子進程的代碼段替換成<code class="literal">./script.sh</code>程序的代碼段，並從它的<code class="literal">_start</code>開始執行。然而<code class="literal">script.sh</code>是個文本檔案，根本沒有代碼段和<code class="literal">_start</code>函數，怎麼辦呢？其實<code class="literal">exec</code>還有另外一種機制，如果要執行的是一個文本檔案，並且第一行用Shebang指定瞭解釋器，則用解釋器程序的代碼段替換當前進程，並且從解釋器的<code class="literal">_start</code>開始執行，而這個文本檔案被當作命令行參數傳給解釋器。因此，執行上述腳本相當於執行程序</p><pre class="screen">$ /bin/sh ./script.sh</pre><p>以這種方式執行不需要<code class="literal">script.sh</code>檔案具有可執行權限。再舉個例子，比如某個<code class="literal">sed</code>腳本的檔案名是<code class="literal">script</code>，它的開頭是</p><pre class="programlisting">#! /bin/sed -f</pre><p>執行<code class="literal">./script</code>相當於執行程序</p><pre class="screen">$ /bin/sed -f ./script.sh</pre><p>以上介紹了兩種執行Shell腳本的方法：</p><pre class="screen">$ ./script.sh
$ sh ./script.sh</pre><p>這兩種方法本質上是一樣的，執行上述腳本的步驟為：</p><div class="figure"><a id="id2872410"></a><p class="title"><b>圖 31.1. Shell腳本的執行過程</b></p><div class="figure-contents"><div><img src="images/shellscript.shellexec.png" alt="Shell腳本的執行過程" /></div></div></div><br class="figure-break" /><div class="orderedlist"><ol type="1"><li><p>交互Shell（<code class="literal">bash</code>）<code class="literal">fork</code>/<code class="literal">exec</code>一個子Shell（<code class="literal">sh</code>）用於執行腳本，父進程<code class="literal">bash</code>等待子進程<code class="literal">sh</code>終止。</p></li><li><p><code class="literal">sh</code>讀取腳本中的<code class="literal">cd ..</code>命令，調用相應的函數執行內建命令，改變當前工作目錄為上一級目錄。</p></li><li><p><code class="literal">sh</code>讀取腳本中的<code class="literal">ls</code>命令，<code class="literal">fork</code>/<code class="literal">exec</code>這個程序，列出當前工作目錄下的檔案，<code class="literal">sh</code>等待<code class="literal">ls</code>終止。</p></li><li><p><code class="literal">ls</code>終止後，<code class="literal">sh</code>繼續執行，讀到腳本檔案末尾，<code class="literal">sh</code>終止。</p></li><li><p><code class="literal">sh</code>終止後，<code class="literal">bash</code>繼續執行，打印提示符等待用戶輸入。</p></li></ol></div><p>如果將命令行下輸入的命令用()括號括起來，那麼也會<code class="literal">fork</code>出一個子Shell執行小括號中的命令，一行中可以輸入由分號;隔開的多個命令，比如：</p><pre class="screen">$ (cd ..;ls -l)</pre><p>和上面兩種方法執行Shell腳本的效果是相同的，<code class="literal">cd ..</code>命令改變的是子Shell的<code class="literal">PWD</code>，而不會影響到互動式Shell。然而命令</p><pre class="screen">$ cd ..;ls -l</pre><p>則有不同的效果，<code class="literal">cd ..</code>命令是直接在互動式Shell下執行的，改變互動式Shell的<code class="literal">PWD</code>，然而這種方式相當於這樣執行Shell腳本：</p><pre class="screen">$ source ./script.sh</pre><p>或者</p><pre class="screen">$ . ./script.sh</pre><p><code class="literal">source</code>或者<code class="literal">.</code>命令是Shell的內建命令，這種方式也不會創建子Shell，而是直接在互動式Shell下逐行執行腳本中的命令。</p><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h4 class="title"><a id="id2872645"></a>習題</h4></div></div></div><p>1、解釋如下命令的執行過程：</p><pre class="screen">$ (exit 2)
$ echo $?
2</pre></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch31s01.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch31.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch31s03.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">1. Shell的歷史 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 3. Shell的基本語法</td></tr></table></div></body></html>
