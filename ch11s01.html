<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>1. 算法的概念</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch11.html" title="第 11 章 排序與查找" /><link rel="prev" href="ch11.html" title="第 11 章 排序與查找" /><link rel="next" href="ch11s02.html" title="2. 插入排序" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1. 算法的概念</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch11.html">上一頁</a> </td><th width="60%" align="center">第 11 章 排序與查找</th><td width="20%" align="right"> <a accesskey="n" href="ch11s02.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2745184"></a>1. 算法的概念</h2></div></div></div><p>算法（Algorithm）<a id="id2744553" class="indexterm"></a>是將一組輸入轉化成一組輸出的一系列計算步驟，其中每個步驟必須能在有限時間內完成。比如<a class="xref" href="ch05s03.html#func2.recursion">第 3 節 “遞歸”</a>習題1中的Euclid算法，輸入是兩個正整數，輸出是它們的最大公約數，計算步驟是取模、比較等操作，這個算法一定能在有限的步驟和時間內完成（想一想為什麼？）。再比如將一組數從小到大排序，輸入是一組原始數據，輸出是排序之後的數據，計算步驟包括比較、移動數據等操作。</p><p>算法是用來解決一類計算問題的，注意是一類問題，而不是一個特定的問題。例如，一個排序算法應該能對任意一組數據進行排序，而不是僅對<code class="literal">int a[] = { 1, 3, 4, 2, 6, 5 };</code>這樣一組數據排序，如果只需要對這一組數據排序可以寫這樣一個函數來做：</p><pre class="programlisting">void sort(void)
{
	a[0] = 1;
	a[1] = 2;
	a[2] = 3;
	a[3] = 4;
	a[4] = 5;
	a[5] = 6;
}</pre><p>這顯然不叫算法，因為不具有通用性。由於算法是用來解決一類問題的，它必須能夠正確地解決這一類問題中的任何一個實例，這個算法才是正確的。對於排序算法，任意輸入一組數據，它必須都能輸出正確的排序結果，這個排序算法才是正確的。不正確的算法有兩種可能，一是對於該問題的某些輸入，該算法會無限計算下去，不會終止，二是對於該問題的某些輸入，該算法終止時輸出的是錯誤的結果。有時候不正確的算法也是有用的，如果對於某個問題尋求正確的算法很困難，而某個不正確的算法可以在有限時間內終止，並且能把誤差控制在一定範圍內，那麼這樣的算法也是有實際意義的。例如有時候尋找最優解的開銷很大，往往會選擇能給出次優解的算法。</p><p>本章介紹幾種典型的排序和查找算法，並圍繞這幾種算法做時間複雜度分析。學完本章之後如果想進一步學習，可以參考一些全面系統地介紹算法的書，例如<a class="xref" href="bi01.html#bibli.taocp" title="The Art of Computer Programming">[<abbr class="abbrev">TAOCP</abbr>]</a>和<a class="xref" href="bi01.html#bibli.algorithm" title="Introduction to Algorithms">[<abbr class="abbrev">算法導論</abbr>]</a>。</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch11.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch11.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch11s02.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">第 11 章 排序與查找 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 2. 插入排序</td></tr></table></div></body></html>
