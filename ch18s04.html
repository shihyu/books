<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>4. 定址方式</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch18.html" title="第 18 章 x86彙編程序基礎" /><link rel="prev" href="ch18s03.html" title="3. 第二個彙編程序" /><link rel="next" href="ch18s05.html" title="5. ELF檔案" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">4. 定址方式</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch18s03.html">上一頁</a> </td><th width="60%" align="center">第 18 章 x86彙編程序基礎</th><td width="20%" align="right"> <a accesskey="n" href="ch18s05.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2770425"></a>4. 定址方式</h2></div></div></div><p>通過上一節的例子我們瞭解到，訪問內存時在指令中可以用多種方式表示內存地址，比如可以用數組基地址、元素長度和下標三個量來表示，增加了定址的靈活性。本節介紹x86常用的幾種定址方式（Addressing Mode）<a id="id2770436" class="indexterm"></a>。內存定址在指令中可以表示成如下的通用格式：</p><div class="literallayout"><p>ADDRESS_OR_OFFSET(%BASE_OR_OFFSET,%INDEX,MULTIPLIER)</p></div><p>它所表示的地址可以這樣計算出來：</p><div class="literallayout"><p>FINAL ADDRESS = ADDRESS_OR_OFFSET + BASE_OR_OFFSET + MULTIPLIER * INDEX</p></div><p>其中ADDRESS_OR_OFFSET和MULTIPLIER必須是常數，BASE_OR_OFFSET和INDEX必須是寄存器。在有些定址方式中會省略這4項中的某些項，相當於這些項是0。</p><div class="itemizedlist"><ul type="disc"><li><p>直接定址（Direct Addressing Mode）<a id="id2770476" class="indexterm"></a>。只使用ADDRESS_OR_OFFSET定址，例如<code class="literal">movl ADDRESS, %eax</code>把ADDRESS地址處的32位數傳送到<code class="literal">eax</code>寄存器。</p></li><li><p>變址定址（Indexed Addressing Mode）<a id="id2770501" class="indexterm"></a> 。上一節的<code class="literal">movl data_items(,%edi,4), %eax</code>就屬於這種定址方式，用於訪問數組元素比較方便。</p></li><li><p>間接定址（Indirect Addressing Mode）<a id="id2770521" class="indexterm"></a>。只使用BASE_OR_OFFSET定址，例如<code class="literal">movl (%eax), %ebx</code>，把<code class="literal">eax</code>寄存器的值看作地址，把內存中這個地址處的32位數傳送到<code class="literal">ebx</code>寄存器。注意和<code class="literal">movl %eax, %ebx</code>區分開。</p></li><li><p>基址定址（Base Pointer Addressing Mode）<a id="id2770560" class="indexterm"></a>。只使用ADDRESS_OR_OFFSET和BASE_OR_OFFSET定址，例如<code class="literal">movl 4(%eax), %ebx</code>，用於訪問結構體成員比較方便，例如一個結構體的基地址保存在<code class="literal">eax</code>寄存器中，其中一個成員在結構體內的偏移量是4位元組，要把這個成員讀上來就可以用這條指令。</p></li><li><p>立即數定址（Immediate Mode）<a id="id2770588" class="indexterm"></a>。就是指令中有一個操作數是立即數，例如<code class="literal">movl $12, %eax</code>中的<code class="literal">$12</code>，這其實跟定址沒什麼關係，但也算作一種定址方式。</p></li><li><p>寄存器定址（Register Addressing Mode）<a id="id2770614" class="indexterm"></a>。就是指令中有一個操作數是寄存器，例如<code class="literal">movl $12, %eax</code>中的<code class="literal">%eax</code>，這跟內存定址沒什麼關係，但也算作一種定址方式。在彙編程序中寄存器用助記符來表示，在機器指令中則要用幾個Bit表示寄存器的編號，這幾個Bit也可以看作寄存器的地址，但是和內存地址不在一個地址空間。</p></li></ul></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch18s03.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch18.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch18s05.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">3. 第二個彙編程序 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 5. ELF檔案</td></tr></table></div></body></html>
