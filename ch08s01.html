<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>1. 數組的基本概念</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch08.html" title="第 8 章 數組" /><link rel="prev" href="ch08.html" title="第 8 章 數組" /><link rel="next" href="ch08s02.html" title="2. 數組應用實例：統計隨機數" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1. 數組的基本概念</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch08.html">上一頁</a> </td><th width="60%" align="center">第 8 章 數組</th><td width="20%" align="right"> <a accesskey="n" href="ch08s02.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2733213"></a>1. 數組的基本概念</h2></div></div></div><p>數組（Array）<a id="id2732586" class="indexterm"></a>也是一種復合數據類型，它由一系列相同類型的元素（Element）<a id="id2732594" class="indexterm"></a>組成。例如定義一個由4個<code class="literal">int</code>型元素組成的數組count：</p><pre class="programlisting">int count[4];</pre><p>和結構體成員類似，數組<code class="literal">count</code>的4個元素的存儲空間也是相鄰的。結構體成員可以是基本數據類型，也可以是復合數據類型，數組中的元素也是如此。根據組合規則，我們可以定義一個由4個結構體元素組成的數組：</p><pre class="programlisting">struct complex_struct {
	double x, y;
} a[4];</pre><p>也可以定義一個包含數組成員的結構體：</p><pre class="programlisting">struct {
	double x, y;
	int count[4];
} s;</pre><p>數組類型的長度應該用一個整數常量表達式來指定<sup>[<a id="id2733250" href="#ftn.id2733250" class="footnote">16</a>]</sup>。數組中的元素通過下標（或者叫索引，Index）<a id="id2733270" class="indexterm"></a>來訪問。例如前面定義的由4個<code class="literal">int</code>型元素組成的數組<code class="literal">count</code>圖示如下：</p><div class="figure"><a id="id2733290"></a><p class="title"><b>圖 8.1. 數組count</b></p><div class="figure-contents"><div><img src="images/array.count.png" alt="數組count" /></div></div></div><br class="figure-break" /><p>整個數組占了4個<code class="literal">int</code>型的存儲單元，存儲單元用小方框表示，裡面的數字是存儲在這個單元中的數據（假設都是0），而框外面的數字是下標，這四個單元分別用<code class="literal">count[0]</code>、<code class="literal">count[1]</code>、<code class="literal">count[2]</code>、<code class="literal">count[3]</code>來訪問。注意，在定義數組<code class="literal">int count[4];</code>時，方括號（Bracket）<a id="id2733345" class="indexterm"></a>中的數字4表示數組的長度，而在訪問數組時，方括號中的數字表示訪問數組的第幾個元素。和我們平常數數不同，數組元素是從“<span class="quote">第0個</span>”開始數的，大多數編程語言都是這麼規定的，所以計算機術語中有Zeroth<a id="id2733360" class="indexterm"></a>這個詞。這樣規定使得訪問數組元素非常方便，比如<code class="literal">count</code>數組中的每個元素占4個位元組，則<code class="literal">count[i]</code>表示從數組開頭跳過<code class="literal">4*i</code>個位元組之後的那個存儲單元。這種數組下標的表達式不僅可以表示存儲單元中的值，也可以表示存儲單元本身，也就是說可以做左值，因此以下語句都是正確的：</p><pre class="programlisting">count[0] = 7;
count[1] = count[0] * 2;
++count[2];</pre><p>到目前為止我們學習了五種尾碼運算符：尾碼++、尾碼--、結構體取成員.、數組取下標[]、函數調用()。還學習了五種單目運算符（或者叫首碼運算符）：首碼++、首碼--、正號+、負號-、邏輯非!。在C語言中尾碼運算符的優先順序最高，單目運算符的優先順序僅次於尾碼運算符，比其它運算符的優先順序都高，所以上面舉例的<code class="literal">++count[2]</code>應該看作對<code class="literal">count[2]</code>做首碼++運算。</p><p>數組下標也可以是表達式，但表達式的值必須是整型的。例如：</p><pre class="programlisting">int i = 10;
count[i] = count[i+1];</pre><p>使用數組下標不能超出數組的長度範圍，這一點在使用變數做數組下標時尤其要注意。C編譯器並不檢查<code class="literal">count[-1]</code>或是<code class="literal">count[100]</code>這樣的訪問越界錯誤，編譯時能順利通過，所以屬於運行時錯誤<sup>[<a id="id2733456" href="#ftn.id2733456" class="footnote">17</a>]</sup>。但有時候這種錯誤很隱蔽，發生訪問越界時程序可能並不會立即崩潰，而執行到後面某個正確的語句時卻有可能突然崩潰（在<a class="xref" href="ch10s04.html#gdb.segfault">第 4 節 “段錯誤”</a>我們會看到這樣的例子）。所以從一開始寫代碼時就要小心避免出問題，事後依靠調試來解決問題的成本是很高的。</p><p>數組也可以像結構體一樣初始化，未賦初值的元素也是用0來初始化，例如：</p><pre class="programlisting">int count[4] = { 3, 2, };</pre><p>則<code class="literal">count[0]</code>等於3， <code class="literal">count[1]</code>等於2，後面兩個元素等於0。如果定義數組的同時初始化它，也可以不指定數組的長度，例如：</p><pre class="programlisting">int count[] = { 3, 2, 1, };</pre><p>編譯器會根據Initializer有三個元素確定數組的長度為3。利用C99的新特性也可以做Memberwise Initialization：</p><pre class="programlisting">int count[4] = { [2] = 3 };</pre><p>下面舉一個完整的例子：</p><div class="example"><a id="id2733545"></a><p class="title"><b>例 8.1. 定義和訪問數組</b></p><div class="example-contents"><pre class="programlisting">#include &lt;stdio.h&gt;

int main(void)
{
	int count[4] = { 3, 2, }, i;

	for (i = 0; i &lt; 4; i++)
		printf("count[%d]=%d\n", i, count[i]);
	return 0;
}</pre></div></div><br class="example-break" /><p>這個例子通過循環把數組中的每個元素依次訪問一遍，在計算機術語中稱為遍歷（Traversal）<a id="id2733562" class="indexterm"></a>。注意控製表達式<code class="literal">i &lt; 4</code>，如果寫成<code class="literal">i &lt;= 4</code>就錯了，因為<code class="literal">count[4]</code>是訪問越界。</p><p>數組和結構體雖然有很多相似之處，但也有一個顯著的不同：數組不能相互賦值或初始化。例如這樣是錯的：</p><pre class="programlisting">int a[5] = { 4, 3, 2, 1 };
int b[5] = a;</pre><p>相互賦值也是錯的：</p><pre class="programlisting">a = b;</pre><p>既然不能相互賦值，也就<span class="emphasis"><em>不能用數組類型作為函數的參數或返回值</em></span>。如果寫出這樣的函數定義：</p><pre class="programlisting">void foo(int a[5])
{
	...
}</pre><p>然後這樣調用：</p><pre class="programlisting">int array[5] = {0};
foo(array);</pre><p>編譯器也不會報錯，但這樣寫並不是傳一個數組類型參數的意思。對於數組類型有一條特殊規則：<span class="emphasis"><em>數組類型做右值使用時，自動轉換成指向數組首元素的指針</em></span>。所以上面的函數調用其實是傳一個指針類型的參數，而不是數組類型的參數。接下來的幾章裡有的函數需要訪問數組，我們就把數組定義為全局變數給函數訪問，等以後講了指針再使用傳參的辦法。這也解釋了為什麼數組類型不能相互賦值或初始化，例如上面提到的<code class="literal">a = b</code>這個表達式，<code class="literal">a</code>和<code class="literal">b</code>都是數組類型的變數，但是<code class="literal">b</code>做右值使用，自動轉換成指針類型，而左邊仍然是數組類型，所以編譯器報的錯是<code class="literal">error: incompatible types in assignment</code>。</p><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2733680"></a>習題</h3></div></div></div><p>1、編寫一個程序，定義兩個類型和長度都相同的數組，將其中一個數組的所有元素拷貝給另一個。既然數組不能直接賦值，想想應該怎麼實現。</p></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id2733250" href="#id2733250" class="para">16</a>] </sup>C99的新特性允許在數組長度表達式中使用變數，稱為變長數組（VLA，Variable Length Array）<a id="id2733257" class="indexterm"></a>，VLA只能定義為局部變數而不能是全局變數，與VLA有關的語法規則比較複雜，而且很多編譯器不支持這種新特性，不建議使用。</p></div><div class="footnote"><p><sup>[<a id="ftn.id2733456" href="#id2733456" class="para">17</a>] </sup>你可能會想為什麼編譯器對這麼明顯的錯誤都視而不見？理由一，這種錯誤並不總是顯而易見的，在<a class="xref" href="ch23s01.html#pointer.intro">第 1 節 “指針的基本概念”</a>會講到通過指針而不是數組名來訪問數組的情況，指針指向數組中的什麼位置只有運行時才知道，編譯時無法檢查是否越界，而運行時每次訪問數組元素都檢查越界會嚴重影響性能，所以乾脆不檢查了；理由二，<a class="xref" href="bi01.html#bibli.rationale" title="Rationale for International Standard － Programming Languages － C">[<abbr class="abbrev">C99 Rationale</abbr>]</a>指出C語言的設計精神是：相信每個C程序員都是高手，不要阻止程序員去幹他們需要干的事，高手們使用<code class="literal">count[-1]</code>這種技巧其實並不少見，不應該當作錯誤。</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch08.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch08.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch08s02.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">第 8 章 數組 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 2. 數組應用實例：統計隨機數</td></tr></table></div></body></html>
