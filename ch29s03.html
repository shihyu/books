<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>3. VFS</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch29.html" title="第 29 章 檔案系統" /><link rel="prev" href="ch29s02.html" title="2. ext2檔案系統" /><link rel="next" href="ch30.html" title="第 30 章 進程" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. VFS</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch29s02.html">上一頁</a> </td><th width="60%" align="center">第 29 章 檔案系統</th><td width="20%" align="right"> <a accesskey="n" href="ch30.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2860197"></a>3. VFS</h2></div></div></div><p>Linux支持各種各樣的檔案系統格式，如ext2、ext3、reiserfs、FAT、NTFS、iso9660等等，不同的磁碟分區、光盤或其它存儲設備都有不同的檔案系統格式，然而這些檔案系統都可以<code class="literal">mount</code>到某個目錄下，使我們看到一個統一的目錄樹，各種檔案系統上的目錄和檔案我們用<code class="literal">ls</code>命令看起來是一樣的，讀寫操作用起來也都是一樣的，這是怎麼做到的呢？Linux內核在各種不同的檔案系統格式之上做了一個抽象層，使得檔案、目錄、讀寫訪問等概唸成為抽象層的概念，因此各種檔案系統看起來用起來都一樣，這個抽象層稱為虛擬檔案系統（VFS，Virtual Filesystem）<a id="id2860253" class="indexterm"></a>。上一節我們介紹了一種典型的檔案系統在磁碟上的存儲佈局，這一節我們介紹運行時檔案系統在內核中的表示。</p><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2860264"></a>3.1. 內核資料結構</h3></div></div></div><p>Linux內核的VFS子系統可以圖示如下：</p><div class="figure"><a id="id2860273"></a><p class="title"><b>圖 29.8. VFS</b></p><div class="figure-contents"><div><img src="images/fs.vfs.png" alt="VFS" /></div></div></div><br class="figure-break" /><p>在<a class="xref" href="ch28.html#io">第 28 章 <i>檔案與I/O</i></a>中講過，每個進程在PCB（Process Control Block）中都保存着一份檔案描述符表，檔案描述符就是這個表的索引，每個表項都有一個指向已打開檔案的指針，現在我們明確一下：已打開的檔案在內核中用<code class="literal">file</code>結構體表示，檔案描述符表中的指針指向<code class="literal">file</code>結構體。</p><p>在<code class="literal">file</code>結構體中維護File Status Flag（<code class="literal">file</code>結構體的成員<code class="literal">f_flags</code>）和當前讀寫位置（<code class="literal">file</code>結構體的成員<code class="literal">f_pos</code>）。在上圖中，進程1和進程2都打開同一檔案，但是對應不同的<code class="literal">file</code>結構體，因此可以有不同的File Status Flag和讀寫位置。<code class="literal">file</code>結構體中比較重要的成員還有<code class="literal">f_count</code>，表示引用計數（Reference Count）<a id="id2860367" class="indexterm"></a>，後面我們會講到，<code class="literal">dup</code>、<code class="literal">fork</code>等系統調用會導致多個檔案描述符指向同一個<code class="literal">file</code>結構體，例如有<code class="literal">fd1</code>和<code class="literal">fd2</code>都引用同一個<code class="literal">file</code>結構體，那麼它的引用計數就是2，當<code class="literal">close(fd1)</code>時並不會釋放<code class="literal">file</code>結構體，而只是把引用計數減到1，如果再<code class="literal">close(fd2)</code>，引用計數就會減到0同時釋放<code class="literal">file</code>結構體，這才真的關閉了檔案。</p><p>每個<code class="literal">file</code>結構體都指向一個<code class="literal">file_operations</code>結構體，這個結構體的成員都是函數指針，指向實現各種檔案操作的內核函數。比如在用戶程序中<code class="literal">read</code>一個檔案描述符，<code class="literal">read</code>通過系統調用進入內核，然後找到這個檔案描述符所指向的<code class="literal">file</code>結構體，找到<code class="literal">file</code>結構體所指向的<code class="literal">file_operations</code>結構體，調用它的<code class="literal">read</code>成員所指向的內核函數以完成用戶請求。在用戶程序中調用<code class="literal">lseek</code>、<code class="literal">read</code>、<code class="literal">write</code>、<code class="literal">ioctl</code>、<code class="literal">open</code>等函數，最終都由內核調用<code class="literal">file_operations</code>的各成員所指向的內核函數完成用戶請求。<code class="literal">file_operations</code>結構體中的<code class="literal">release</code>成員用於完成用戶程序的<code class="literal">close</code>請求，之所以叫<code class="literal">release</code>而不叫<code class="literal">close</code>是因為它不一定真的關閉檔案，而是減少引用計數，只有引用計數減到0才關閉檔案。對於同一個檔案系統上打開的常規檔案來說，<code class="literal">read</code>、<code class="literal">write</code>等檔案操作的步驟和方法應該是一樣的，調用的函數應該是相同的，所以圖中的三個打開檔案的<code class="literal">file</code>結構體指向同一個<code class="literal">file_operations</code>結構體。如果打開一個字元設備檔案，那麼它的<code class="literal">read</code>、<code class="literal">write</code>操作肯定和常規檔案不一樣，不是讀寫磁碟的數據塊而是讀寫硬件設備，所以<code class="literal">file</code>結構體應該指向不同的<code class="literal">file_operations</code>結構體，其中的各種檔案操作函數由該設備的驅動程式實現。</p><p>每個<code class="literal">file</code>結構體都有一個指向<code class="literal">dentry</code>結構體的指針，“<span class="quote">dentry</span>”是directory entry（目錄項）的縮寫。我們傳給<code class="literal">open</code>、<code class="literal">stat</code>等函數的參數的是一個路徑，例如<code class="literal">/home/akaedu/a</code>，需要根據路徑找到檔案的inode。為了減少讀盤次數，內核緩存了目錄的樹狀結構，稱為dentry cache<a id="id2860666" class="indexterm"></a>，其中每個節點是一個<code class="literal">dentry</code>結構體，只要沿著路徑各部分的dentry搜索即可，從根目錄<code class="literal">/</code>找到<code class="literal">home</code>目錄，然後找到<code class="literal">akaedu</code>目錄，然後找到檔案<code class="literal">a</code>。dentry cache只保存最近訪問過的目錄項，如果要找的目錄項在cache中沒有，就要從磁碟讀到內存中。</p><p>每個<code class="literal">dentry</code>結構體都有一個指針指向<code class="literal">inode</code>結構體。<code class="literal">inode</code>結構體保存着從磁碟inode讀上來的信息。在上圖的例子中，有兩個dentry，分別表示<code class="literal">/home/akaedu/a</code>和<code class="literal">/home/akaedu/b</code>，它們都指向同一個inode，說明這兩個檔案互為硬連結。<code class="literal">inode</code>結構體中保存着從磁碟分區的inode讀上來信息，例如所有者、檔案大小、檔案類型和權限位等。每個<code class="literal">inode</code>結構體都有一個指向<code class="literal">inode_operations</code>結構體的指針，後者也是一組函數指針指向一些完成檔案目錄操作的內核函數。和<code class="literal">file_operations</code>不同，<code class="literal">inode_operations</code>所指向的不是針對某一個檔案進行操作的函數，而是影響檔案和目錄佈局的函數，例如添加刪除檔案和目錄、跟蹤符號連結等等，屬於同一檔案系統的各<code class="literal">inode</code>結構體可以指向同一個<code class="literal">inode_operations</code>結構體。</p><p><code class="literal">inode</code>結構體有一個指向<code class="literal">super_block</code>結構體的指針。<code class="literal">super_block</code>結構體保存着從磁碟分區的超級塊讀上來的信息，例如檔案系統類型、塊大小等。<code class="literal">super_block</code>結構體的<code class="literal">s_root</code>成員是一個指向<code class="literal">dentry</code>的指針，表示這個檔案系統的根目錄被<code class="literal">mount</code>到哪裡，在上圖的例子中這個分區被<code class="literal">mount</code>到<code class="literal">/home</code>目錄下。</p><p><code class="literal">file</code>、<code class="literal">dentry</code>、<code class="literal">inode</code>、<code class="literal">super_block</code>這幾個結構體組成了VFS的核心概念。對於ext2檔案系統來說，在磁碟存儲佈局上也有inode和超級塊的概念，所以很容易和VFS中的概念建立對應關係。而另外一些檔案系統格式來自非UNIX系統（例如Windows的FAT32、NTFS），可能沒有inode或超級塊這樣的概念，但為了能<code class="literal">mount</code>到Linux系統，也只好在驅動程式中硬湊一下，在Linux下看FAT32和NTFS分區會發現權限位是錯的，所有檔案都是<code class="literal">rwxrwxrwx</code>，因為它們本來就沒有inode和權限位的概念，這是硬湊出來的。</p></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2860911"></a>3.2. dup和dup2函數</h3></div></div></div><p><code class="literal">dup</code>和<code class="literal">dup2</code>都可用來複制一個現存的檔案描述符，使兩個檔案描述符指向同一個<code class="literal">file</code>結構體。如果兩個檔案描述符指向同一個<code class="literal">file</code>結構體，File Status Flag和讀寫位置只保存一份在<code class="literal">file</code>結構體中，並且<code class="literal">file</code>結構體的引用計數是2。如果兩次<code class="literal">open</code>同一檔案得到兩個檔案描述符，則每個描述符對應一個不同的<code class="literal">file</code>結構體，可以有不同的File Status Flag和讀寫位置。請注意區分這兩種情況。</p><pre class="programlisting">#include &lt;unistd.h&gt;

int dup(int oldfd);
int dup2(int oldfd, int newfd);</pre><p>如果調用成功，這兩個函數都返回新分配或指定的檔案描述符，如果出錯則返回-1。<code class="literal">dup</code>返回的新檔案描述符一定該進程未使用的最小檔案描述符，這一點和<code class="literal">open</code>類似。<code class="literal">dup2</code>可以用<code class="literal">newfd</code>參數指定新描述符的數值。如果<code class="literal">newfd</code>當前已經打開，則先將其關閉再做<code class="literal">dup2</code>操作，如果<code class="literal">oldfd</code>等於<code class="literal">newfd</code>，則<code class="literal">dup2</code>直接返回<code class="literal">newfd</code>而不用先關閉<code class="literal">newfd</code>再複製。</p><p>下面這個例子演示了<code class="literal">dup</code>和<code class="literal">dup2</code>函數的用法，請結合後面的連環畫理解程序的執行過程。</p><div class="example"><a id="id2861068"></a><p class="title"><b>例 29.2. dup和dup2示常式序</b></p><div class="example-contents"><pre class="programlisting">#include &lt;unistd.h&gt;
#include &lt;sys/stat.h&gt;
#include &lt;fcntl.h&gt;
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;string.h&gt;

int main(void)
{
	int fd, save_fd;
	char msg[] = "This is a test\n";

	fd = open("somefile", O_RDWR|O_CREAT, S_IRUSR|S_IWUSR);
	if(fd&lt;0) {
		perror("open");
		exit(1);
	}
	save_fd = dup(STDOUT_FILENO);
	dup2(fd, STDOUT_FILENO);
	close(fd);
	write(STDOUT_FILENO, msg, strlen(msg));
	dup2(save_fd, STDOUT_FILENO);
	write(STDOUT_FILENO, msg, strlen(msg));
	close(save_fd);
	return 0;
}</pre></div></div><br class="example-break" /><div class="figure"><a id="id2861076"></a><p class="title"><b>圖 29.9. dup/dup2示常式序</b></p><div class="figure-contents"><div><img src="images/fs.dup.png" alt="dup/dup2示常式序" /></div></div></div><br class="figure-break" /><p>重點解釋兩個地方：</p><div class="itemizedlist"><ul type="disc"><li><p>第3幅圖，要執行<code class="literal">dup2(fd, 1);</code>，檔案描述符1原本指向<code class="literal">tty</code>，現在要指向新的檔案<code class="literal">somefile</code>，就把原來的關閉了，但是<code class="literal">tty</code>這個檔案原本有兩個引用計數，還有檔案描述符<code class="literal">save_fd</code>也指向它，所以只是將引用計數減1，並不真的關閉檔案。</p></li><li><p>第5幅圖，要執行<code class="literal">dup2(save_fd, 1);</code>，檔案描述符1原本指向<code class="literal">somefile</code>，現在要指向新的檔案<code class="literal">tty</code>，就把原來的關閉了，<code class="literal">somefile</code>原本只有一個引用計數，所以這次減到0，是真的關閉了。</p></li></ul></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch29s02.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch29.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch30.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">2. ext2檔案系統 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 第 30 章 進程</td></tr></table></div></body></html>
