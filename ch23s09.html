<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>9. 不完全類型和複雜聲明</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch23.html" title="第 23 章 指針" /><link rel="prev" href="ch23s08.html" title="8. 函數類型和函數指針類型" /><link rel="next" href="ch24.html" title="第 24 章 函數介面" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">9. 不完全類型和複雜聲明</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch23s08.html">上一頁</a> </td><th width="60%" align="center">第 23 章 指針</th><td width="20%" align="right"> <a accesskey="n" href="ch24.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2813989"></a>9. 不完全類型和複雜聲明</h2></div></div></div><p>在<a class="xref" href="ch07s01.html#struct.intro">第 1 節 “復合類型與結構體”</a>講過算術類型、標量類型的概念，現在又學習了幾種類型，我們完整地總結一下C語言的類型。下圖出自<a class="xref" href="bi01.html#bibli.standardc" title="Standard C: A Reference">[<abbr class="abbrev">Standard C</abbr>]</a>。</p><div class="figure"><a id="id2814014"></a><p class="title"><b>圖 23.5. C語言類型總結</b></p><div class="figure-contents"><div><img src="images/pointer.type.gif" alt="C語言類型總結" /></div></div></div><br class="figure-break" /><p>C語言的類型分為函數類型、對象類型和不完全類型三大類。對象類型又分為標量類型和非標量類型。指針類型屬於標量類型，因此也可以做邏輯與、或、非運算的操作數和<code class="literal">if</code>、<code class="literal">for</code>、<code class="literal">while</code>的控製表達式，<code class="literal">NULL</code>指針表示假，非<code class="literal">NULL</code>指針表示真。不完全類型是暫時沒有完全定義好的類型，編譯器不知道這種類型該占幾個位元組的存儲空間，例如：</p><pre class="programlisting">struct s;
union u;
char str[];</pre><p>具有不完全類型的變數可以通過多次聲明組合成一個完全類型，比如數組<code class="literal">str</code>聲明兩次：</p><pre class="programlisting">char str[];
char str[10];</pre><p>當編譯器碰到第一個聲明時，認為<code class="literal">str</code>是一個不完全類型，碰到第二個聲明時<code class="literal">str</code>就組合成完全類型了，如果編譯器處理到程序檔案的末尾仍然無法把<code class="literal">str</code>組合成一個完全類型，就會報錯。讀者可能會想，這個語法有什麼用呢？為何不在第一次聲明時就把<code class="literal">str</code>聲明成完全類型？有些情況下這麼做有一定的理由，比如第一個聲明是寫在標頭檔裡的，第二個聲明寫在<code class="literal">.c</code>檔案裡，這樣如果要改數組長度，只改<code class="literal">.c</code>檔案就行了，標頭檔可以不用改。</p><p>不完全的結構體類型有重要作用：</p><pre class="programlisting">struct s {
	struct t *pt;
};

struct t {
	struct s *ps;
};</pre><p><code class="literal">struct s</code>和<code class="literal">struct t</code>各有一個指針成員指向另一種類型。編譯器從前到後依次處理，當看到<code class="literal">struct s { struct t* pt; };</code>時，認為<code class="literal">struct t</code>是一個不完全類型，<code class="literal">pt</code>是一個指向不完全類型的指針，儘管如此，這個指針卻是完全類型，因為不管什麼指針都占4個位元組存儲空間，這一點很明確。然後編譯器又看到<code class="literal">struct t { struct s *ps; };</code>，這時<code class="literal">struct t</code>有了完整的定義，就組合成一個完全類型了，<code class="literal">pt</code>的類型就組合成一個指向完全類型的指針。由於<code class="literal">struct s</code>在前面有完整的定義，所以<code class="literal">struct s *ps;</code>也定義了一個指向完全類型的指針。</p><p>這樣的類型定義是錯誤的：</p><pre class="programlisting">struct s {
	struct t ot;
};

struct t {
	struct s os;
};</pre><p>編譯器看到<code class="literal">struct s { struct t ot; };</code>時，認為<code class="literal">struct t</code>是一個不完全類型，無法定義成員<code class="literal">ot</code>，因為不知道它該占幾個位元組。所以結構體中可以遞歸地定義指針成員，但不能遞歸地定義變數成員，你可以設想一下，假如允許遞歸地定義變數成員，<code class="literal">struct s</code>中有一個<code class="literal">struct t</code>，<code class="literal">struct t</code>中又有一個<code class="literal">struct s</code>，<code class="literal">struct s</code>又中有一個<code class="literal">struct t</code>，這就成了一個無窮遞歸的定義。</p><p>以上是兩個結構體構成的遞歸定義，一個結構體也可以遞歸定義：</p><pre class="programlisting">struct s {
	char data[6];
	struct s* next;
};</pre><p>當編譯器處理到第一行<code class="literal">struct s {</code>時，認為<code class="literal">struct s</code>是一個不完全類型，當處理到第三行<code class="literal">struct s *next;</code>時，認為<code class="literal">next</code>是一個指向不完全類型的指針，當處理到第四行<code class="literal">};</code>時，<code class="literal">struct s</code>成了一個完全類型，<code class="literal">next</code>也成了一個指向完全類型的指針。類似這樣的結構體是很多種資料結構的基本組成單元，如鏈表、二叉樹等，我們將在後面詳細介紹。下圖示意了由幾個<code class="literal">struct s</code>結構體組成的鏈表，這些結構體稱為鏈表的節點（Node）<a id="id2814359" class="indexterm"></a>。</p><div class="figure"><a id="id2814368"></a><p class="title"><b>圖 23.6. 鏈表</b></p><div class="figure-contents"><div><img src="images/pointer.linkedlist.png" alt="鏈表" /></div></div></div><br class="figure-break" /><p><code class="literal">head</code>指針是鏈表的頭指針，指向第一個節點，每個節點的<code class="literal">next</code>指針域指向下一個節點，最後一個節點的<code class="literal">next</code>指針域為<code class="literal">NULL</code>，在圖中用0表示。</p><p>可以想像得到，如果把指針和數組、函數、結構體層層組合起來可以構成非常複雜的類型，下面看幾個複雜的聲明。</p><pre class="programlisting">typedef void (*sighandler_t)(int);
sighandler_t signal(int signum, sighandler_t handler);</pre><p>這個聲明來自<code class="literal">signal(2)</code>。<code class="literal">sighandler_t</code>是一個函數指針，它所指向的函數帶一個參數，返回值為<code class="literal">void</code>，<code class="literal">signal</code>是一個函數，它帶兩個參數，一個<code class="literal">int</code>參數，一個<code class="literal">sighandler_t</code>參數，返回值也是<code class="literal">sighandler_t</code>參數。如果把這兩行合成一行寫，就是：</p><pre class="programlisting">void (*signal(int signum, void (*handler)(int)))(int);</pre><p>在分析複雜聲明時，要借助<code class="literal">typedef</code>把複雜聲明分解成幾種基本形式：</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">T *p;</code>，<code class="literal">p</code>是指向<code class="literal">T</code>類型的指針。</p></li><li><p><code class="literal">T a[];</code>，<code class="literal">a</code>是由<code class="literal">T</code>類型的元素組成的數組，但有一個例外，如果<code class="literal">a</code>是函數的形參，則相當於<code class="literal">T *a;</code></p></li><li><p><code class="literal">T1 f(T2, T3...);</code>，<code class="literal">f</code>是一個函數，參數類型是<code class="literal">T2</code>、<code class="literal">T3</code>等等，返回值類型是<code class="literal">T1</code>。</p></li></ul></div><p>我們分解一下這個複雜聲明：</p><pre class="programlisting">int (*(*fp)(void *))[10];</pre><p>1、<code class="literal">fp</code>和<code class="literal">*</code>號括在一起，說明<code class="literal">fp</code>是一個指針，指向<code class="literal">T1</code>類型：</p><pre class="programlisting">typedef int (*T1(void *))[10];
T1 *fp;</pre><p>2、<code class="literal">T1</code>應該是一個函數類型，參數是<code class="literal">void *</code>，返回值是<code class="literal">T2</code>類型：</p><pre class="programlisting">typedef int (*T2)[10];
typedef T2 T1(void *);
T1 *fp;</pre><p>3、<code class="literal">T2</code>和<code class="literal">*</code>號括在一起，應該也是個指針，指向<code class="literal">T3</code>類型：</p><pre class="programlisting">typedef int T3[10];
typedef T3 *T2;
typedef T2 T1(void *);
T1 *fp;</pre><p>顯然，<code class="literal">T3</code>是一個<code class="literal">int</code>數組，由10個元素組成。分解完畢。</p></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch23s08.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch23.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch24.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">8. 函數類型和函數指針類型 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 第 24 章 函數介面</td></tr></table></div></body></html>
