<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>1. 終端</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch34.html" title="第 34 章 終端、作業控制與守護進程" /><link rel="prev" href="ch34.html" title="第 34 章 終端、作業控制與守護進程" /><link rel="next" href="ch34s02.html" title="2. 作業控制" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1. 終端</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch34.html">上一頁</a> </td><th width="60%" align="center">第 34 章 終端、作業控制與守護進程</th><td width="20%" align="right"> <a accesskey="n" href="ch34s02.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2890992"></a>1. 終端</h2></div></div></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2890359"></a>1.1. 終端的基本概念</h3></div></div></div><p>在UNIX系統中，用戶通過終端登錄系統後得到一個Shell進程，這個終端成為Shell進程的控制終端（Controlling Terminal）<a id="id2890371" class="indexterm"></a>，在<a class="xref" href="ch30s01.html#process.intro">第 1 節 “引言”</a>講過，控制終端是保存在PCB中的信息，而我們知道<code class="literal">fork</code>會複製PCB中的信息，因此由Shell進程啟動的其它進程的控制終端也是這個終端。預設情況下（沒有重定向），每個進程的標準輸入、標準輸出和標准錯誤輸出都指向控制終端，進程從標準輸入讀也就是讀用戶的鍵盤輸入，進程往標準輸出或標准錯誤輸出寫也就是輸出到顯示器上。此外在<a class="xref" href="ch33.html#signal">第 33 章 <i>信號</i></a>還講過，在控制終端輸入一些特殊的修飾鍵可以給前台進程發信號，例如Ctrl-C表示<code class="literal">SIGINT</code>，Ctrl-\表示<code class="literal">SIGQUIT</code>。</p><p>在<a class="xref" href="ch28.html#io">第 28 章 <i>檔案與I/O</i></a>中講過，每個進程都可以通過一個特殊的設備檔案<code class="literal">/dev/tty</code>訪問它的控制終端。事實上每個終端設備都對應一個不同的設備檔案，<code class="literal">/dev/tty</code>提供了一個通用的介面，一個進程要訪問它的控制終端既可以通過<code class="literal">/dev/tty</code>也可以通過該終端設備所對應的設備檔案來訪問。<code class="literal">ttyname</code>函數可以由檔案描述符查出對應的檔案名，該檔案描述符必須指向一個終端設備而不能是任意檔案。下面我們通過實驗看一下各種不同的終端所對應的設備檔案名。</p><div class="example"><a id="id2891071"></a><p class="title"><b>例 34.1. 查看終端對應的設備檔案名</b></p><div class="example-contents"><pre class="programlisting">#include &lt;unistd.h&gt;
#include &lt;stdio.h&gt;

int main()
{
    printf("fd 0: %s\n", ttyname(0));
    printf("fd 1: %s\n", ttyname(1));
    printf("fd 2: %s\n", ttyname(2));
    return 0;
}</pre></div></div><br class="example-break" /><p>在圖形終端窗口下運行這個程序，可能會得到</p><pre class="screen">$ ./a.out
fd 0: /dev/pts/0
fd 1: /dev/pts/0
fd 2: /dev/pts/0</pre><p>再開一個終端窗口運行這個程序，可能又會得到</p><pre class="screen">$ ./a.out
fd 0: /dev/pts/1
fd 1: /dev/pts/1
fd 2: /dev/pts/1</pre><p>用Ctrl-Alt-F1切換到字元終端運行這個程序，結果是</p><pre class="screen">$ ./a.out
fd 0: /dev/tty1
fd 1: /dev/tty1
fd 2: /dev/tty1</pre><p>讀者可以再試試在Ctrl-Alt-F2的字元終端下或者在<code class="literal">telnet</code>或<code class="literal">ssh</code>登陸的網絡終端下運行這個程序，看看結果是什麼。</p></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2891132"></a>1.2. 終端登錄過程</h3></div></div></div><p>一台PC通常只有一套鍵盤和顯示器，也就是只有一套終端設備，但是可以通過Ctrl-Alt-F1~Ctrl-Alt-F6切換到6個字元終端，相當於有6套虛擬的終端設備，它們共用同一套物理終端設備，對應的設備檔案分別是<code class="literal">/dev/tty1</code>~<code class="literal">/dev/tty6</code>，所以稱為虛擬終端（Virtual Terminal）<a id="id2891156" class="indexterm"></a>。設備檔案<code class="literal">/dev/tty0</code>表示當前虛擬終端，比如切換到Ctrl-Alt-F1的字元終端時<code class="literal">/dev/tty0</code>就表示<code class="literal">/dev/tty1</code>，切換到Ctrl-Alt-F2的字元終端時<code class="literal">/dev/tty0</code>就表示<code class="literal">/dev/tty2</code>，就像<code class="literal">/dev/tty</code>一樣也是一個通用的介面，但它不能表示圖形終端窗口所對應的終端。</p><p>再舉個例子，做嵌入式開發時經常會用到串口終端，目標板的每個串口對應一個終端設備，比如<code class="literal">/dev/ttyS0</code>、<code class="literal">/dev/ttyS1</code>等，將主機和目標板用串口綫連起來，就可以在主機上通過Linux的<code class="literal">minicom</code>或Windows的超級終端工具登錄到目標板的系統。</p><p>內核中處理終端設備的模組包括硬件驅動程式和線路規程（Line Discipline）<a id="id2891233" class="indexterm"></a>。</p><div class="figure"><a id="id2891241"></a><p class="title"><b>圖 34.1. 終端設備模組</b></p><div class="figure-contents"><div><img src="images/jobs.terminalmodule.png" alt="終端設備模組" /></div></div></div><br class="figure-break" /><p>硬件驅動程式負責讀寫實際的硬件設備，比如從鍵盤讀入字元和把字元輸出到顯示器，線路規程像一個過濾器，對於某些特殊字元並不是讓它直接通過，而是做特殊處理，比如在鍵盤上按下Ctrl-Z，對應的字元並不會被用戶程序的<code class="literal">read</code>讀到，而是被線路規程截獲，解釋成<code class="literal">SIGTSTP</code>信號發給前台進程，通常會使該進程停止。線路規程應該過濾哪些字元和做哪些特殊處理是可以配置的。</p><p>終端設備有輸入和輸出隊列緩衝區，如下圖所示。</p><div class="figure"><a id="id2891282"></a><p class="title"><b>圖 34.2. 終端緩衝</b></p><div class="figure-contents"><div><img src="images/jobs.terminalqueue.png" alt="終端緩衝" /></div></div></div><br class="figure-break" /><p>以輸入隊列為例，從鍵盤輸入的字元經線路規程過濾後進入輸入隊列，用戶程序以先進先出的順序從隊列中讀取字元，一般情況下，當輸入隊列滿的時候再輸入字元會丟失，同時系統會響鈴警報。終端可以配置成回顯（Echo）<a id="id2891302" class="indexterm"></a>模式，在這種模式下，輸入隊列中的每個字元既送給用戶程序也送給輸出隊列，因此我們在命令行鍵入字元時，該字元不僅可以被程序讀取，我們也可以同時在屏幕上看到該字元的回顯。</p><p>現在我們來看終端登錄的過程：</p><p>1、系統啟動時，<code class="literal">init</code>進程根據配置檔案<code class="literal">/etc/inittab</code>確定需要打開哪些終端。例如配置檔案中有這樣一行：</p><pre class="programlisting">1:2345:respawn:/sbin/getty 9600 tty1</pre><p>和<code class="literal">/etc/passwd</code>類似，每個欄位用<code class="literal">:</code>號隔開。開頭的1是這一行配置的id，通常要和<code class="literal">tty</code>的尾碼一致，配置<code class="literal">tty2</code>的那一行id就應該是2。第二個欄位2345表示運行級別2~5都執行這個配置。最後一個欄位<code class="literal">/sbin/getty 9600 tty1</code>是<code class="literal">init</code>進程要<code class="literal">fork</code>/<code class="literal">exec</code>的命令，打開終端<code class="literal">/dev/tty1</code>，波特率是9600（波特率只對串口和Modem終端有意義），然後提示用戶輸入帳號。中間的<code class="literal">respawn</code>欄位表示<code class="literal">init</code>進程會監視<code class="literal">getty</code>進程的運行狀態，一旦該進程終止，<code class="literal">init</code>會再次<code class="literal">fork</code>/<code class="literal">exec</code>這個命令，所以我們從終端退出登錄後會再次提示輸入帳號。</p><p>有些新的Linux發行版已經不用<code class="literal">/etc/inittab</code>這個配置檔案了，例如Ubuntu用<code class="literal">/etc/event.d</code>目錄下的配置檔案來配置<code class="literal">init</code>。</p><p>2、<code class="literal">getty</code>根據命令行參數打開終端設備作為它的控制終端，把檔案描述符0、1、2都指向控制終端，然後提示用戶輸入帳號。用戶輸入帳號之後，<code class="literal">getty</code>的任務就完成了，它再執行<code class="literal">login</code>程序：</p><pre class="programlisting">execle("/bin/login", "login", "-p", username, NULL, envp);</pre><p>3、<code class="literal">login</code>程序提示用戶輸入密碼（輸入密碼期間關閉終端的回顯），然後驗證帳號密碼的正確性。如果密碼不正確，<code class="literal">login</code>進程終止，<code class="literal">init</code>會重新<code class="literal">fork</code>/<code class="literal">exec</code>一個<code class="literal">getty</code>進程。如果密碼正確，<code class="literal">login</code>程序設置一些環境變數，設置當前工作目錄為該用戶的主目錄，然後執行Shell：</p><pre class="programlisting">execl("/bin/bash", "-bash", NULL);</pre><p>注意<code class="literal">argv[0]</code>參數的程序名前面加了一個<code class="literal">-</code>，這樣<code class="literal">bash</code>就知道自己是作為登錄Shell啟動的，執行登錄Shell的啟動腳本。從<code class="literal">getty</code>開始<code class="literal">exec</code>到<code class="literal">login</code>，再<code class="literal">exec</code>到<code class="literal">bash</code>，其實都是同一個進程，因此控制終端沒變，檔案描述符0、1、2也仍然指向控制終端。由於<code class="literal">fork</code>會複製PCB信息，所以由Shell啟動的其它進程也都是如此。</p></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2891618"></a>1.3. 網絡登錄過程</h3></div></div></div><p>虛擬終端或串口終端的數目是有限的，虛擬終端一般就是<code class="literal">/dev/tty1</code>~<code class="literal">/dev/tty6</code>六個，串口終端的數目也不超過串口的數目。然而網絡終端或圖形終端窗口的數目卻是不受限制的，這是通過偽終端（Pseudo TTY）<a id="id2891644" class="indexterm"></a>實現的。一套偽終端由一個主設備（PTY Master）<a id="id2891652" class="indexterm"></a>和一個從設備（PTY Slave）<a id="id2891659" class="indexterm"></a>組成。主設備在概念上相當於鍵盤和顯示器，只不過它不是真正的硬件而是一個內核模組，操作它的也不是用戶而是另外一個進程。從設備和上面介紹的<code class="literal">/dev/tty1</code>這樣的終端設備模組類似，只不過它的底層驅動程式不是訪問硬件而是訪問主設備。通過<a class="xref" href="ch34s01.html#jobs.ttyname">例 34.1 “查看終端對應的設備檔案名”</a>的實驗結果可以看到，網絡終端或圖形終端窗口的Shell進程以及它啟動的其它進程都會認為自己的控制終端是偽終端從設備，例如<code class="literal">/dev/pts/0</code>、<code class="literal">/dev/pts/1</code>等。下面以<code class="literal">telnet</code>為例說明網絡登錄和使用偽終端的過程。</p><div class="figure"><a id="id2891707"></a><p class="title"><b>圖 34.3. 偽終端</b></p><div class="figure-contents"><div><img src="images/jobs.pseudotty.png" alt="偽終端" /></div></div></div><br class="figure-break" /><div class="orderedlist"><ol type="1"><li><p>用戶通過<code class="literal">telnet</code>客戶端連接伺服器。如果伺服器配置為獨立（Standalone）<a id="id2891738" class="indexterm"></a>模式，則在伺服器監聽連接請求是一個<code class="literal">telnetd</code>進程，它<code class="literal">fork</code>出一個<code class="literal">telnetd</code>子進程來服務客戶端，父進程仍監聽其它連接請求。</p><p>另外一種可能是伺服器端由系統服務程序<code class="literal">inetd</code>或<code class="literal">xinetd</code>監聽連接請求，<code class="literal">inetd</code>稱為Internet Super-Server<a id="id2891790" class="indexterm"></a>，它監聽系統中的多個網絡服務連接埠，如果連接請求的連接埠號和<code class="literal">telnet</code>服務連接埠號一致，則<code class="literal">fork</code>/<code class="literal">exec</code>一個<code class="literal">telnetd</code>子進程來服務客戶端。<code class="literal">xinetd</code>是<code class="literal">inetd</code>的升級版本，配置更為靈活。</p></li><li><p><code class="literal">telnetd</code>子進程打開一個偽終端設備，然後再經過<code class="literal">fork</code>一分為二：父進程操作偽終端主設備，子進程將偽終端從設備作為它的控制終端，並且將檔案描述符0、1、2指向控制終端，二者通過偽終端通信，父進程還負責和<code class="literal">telnet</code>客戶端通信，而子進程負責用戶的登錄過程，提示輸入帳號，然後調用<code class="literal">exec</code>變成<code class="literal">login</code>進程，提示輸入密碼，然後調用<code class="literal">exec</code>變成Shell進程。這個Shell進程認為自己的控制終端是偽終端從設備，偽終端主設備可以看作鍵盤顯示器等硬件，而操作這個偽終端的“<span class="quote">用戶</span>”就是父進程<code class="literal">telnetd</code>。</p></li><li><p>當用戶輸入命令時，<code class="literal">telnet</code>客戶端將用戶輸入的字元通過網絡發給<code class="literal">telnetd</code>伺服器，由<code class="literal">telnetd</code>伺服器代表用戶將這些字元輸入偽終端。Shell進程並不知道自己連接的是偽終端而不是真正的鍵盤顯示器，也不知道操作終端的“<span class="quote">用戶</span>”其實是<code class="literal">telnetd</code>伺服器而不是真正的用戶。Shell仍然解釋執行命令，將標準輸出和標准錯誤輸出寫到終端設備，這些數據最終由<code class="literal">telnetd</code>伺服器發回給<code class="literal">telnet</code>客戶端，然後顯示給用戶看。</p></li></ol></div><p>如果<code class="literal">telnet</code>客戶端和伺服器之間的網絡延遲較大，我們會觀察到按下一個鍵之後要過幾秒鐘才能回顯到屏幕上。這說明我們每按一個鍵<code class="literal">telnet</code>客戶端都會立刻把該字元發送給伺服器，然後這個字元經過偽終端主設備和從設備之後被Shell進程讀取，同時回顯到偽終端從設備，回顯的字元再經過偽終端主設備、<code class="literal">telnetd</code>伺服器和網絡發回給<code class="literal">telnet</code>客戶端，顯示給用戶看。也許你會覺得吃驚，但真的是這樣：每按一個鍵都要在網絡上走個來回！</p><p>BSD系列的UNIX在<code class="literal">/dev</code>目錄下創建很多<code class="literal">ptyXX</code>和<code class="literal">ttyXX</code>設備檔案，<code class="literal">XX</code>由字母和數字組成，<code class="literal">ptyXX</code>是主設備，相對應的<code class="literal">ttyXX</code>是從設備，偽終端的數目取決於內核配置。而在SYS V系列的UNIX上，偽終端主設備是<code class="literal">/dev/ptmx</code>，“<span class="quote">mx</span>”表示Multiplex<a id="id2892033" class="indexterm"></a>，意思是多個主設備復用同一個設備檔案，每打開一次<code class="literal">/dev/ptmx</code>，內核就分配一個主設備，同時在<code class="literal">/dev/pts</code>目錄下創建一個從設備檔案，當終端關閉時就從<code class="literal">/dev/pts</code>目錄下刪除相應的從設備檔案。Linux同時支持上述兩種偽終端，目前的標準傾向于SYS V的偽終端。</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch34.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch34.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch34s02.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">第 34 章 終端、作業控制與守護進程 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 2. 作業控制</td></tr></table></div></body></html>
