<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>3. 變數</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch22.html" title="第 22 章 Makefile基礎" /><link rel="prev" href="ch22s02.html" title="2. 隱含規則和模式規則" /><link rel="next" href="ch22s04.html" title="4. 自動處理標頭檔的依賴關係" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. 變數</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch22s02.html">上一頁</a> </td><th width="60%" align="center">第 22 章 Makefile基礎</th><td width="20%" align="right"> <a accesskey="n" href="ch22s04.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2804672"></a>3. 變數</h2></div></div></div><p>這一節我們詳細看看Makefile中關於變數的語法規則。先看一個簡單的例子：</p><pre class="programlisting">foo = $(bar) 
bar = Huh? 

all: 
	@echo $(foo)</pre><p>我們執行<code class="literal">make</code>將會打出<code class="literal">Huh?</code>。當<code class="literal">make</code>讀到<code class="literal">foo = $(bar)</code>時，確定<code class="literal">foo</code>的值是<code class="literal">$(bar)</code>，但並不立即展開<code class="literal">$(bar)</code>，然後讀到<code class="literal">bar = Huh?</code>，確定<code class="literal">bar</code>的值是<code class="literal">Huh?</code>，然後在執行規則<code class="literal">all:</code>的命令列表時才需要展開<code class="literal">$(foo)</code>，得到<code class="literal">$(bar)</code>，再展開<code class="literal">$(bar)</code>，得到<code class="literal">Huh?</code>。因此，雖然<code class="literal">bar</code>的定義寫在<code class="literal">foo</code>之後，<code class="literal">$(foo)</code>展開還是能夠取到<code class="literal">$(bar)</code>的值。</p><p>這種特性有好處也有壞處。好處是我們可以把變數的值推遲到後面定義，例如：</p><pre class="programlisting">main.o: main.c
	$(CC) $(CFLAGS) $(CPPFLAGS) -c $&lt;

CC = gcc
CFLAGS = -O -g
CPPFLAGS = -Iinclude</pre><p>編譯命令可以展開成<code class="literal">gcc -O -g -Iinclude -c main.c</code>。通常把<code class="literal">CFLAGS</code>定義成一些編譯選項，例如<code class="literal">-O</code>、<code class="literal">-g</code>等，而把<code class="literal">CPPFLAGS</code>定義成一些預處理選項，例如<code class="literal">-D</code>、<code class="literal">-I</code>等。用<code class="literal">=</code>號定義變數的延遲展開特性也有壞處，就是有可能寫出無窮遞歸的定義，例如<code class="literal">CFLAGS = $(CFLAGS) -O</code>，或者：</p><pre class="programlisting">A = $(B)
B = $(A)</pre><p>當然，<code class="literal">make</code>有能力檢測出這樣的錯誤而不會陷入死循環。有時候我們希望<code class="literal">make</code>在遇到變數定義時立即展開，可以用<code class="literal">:=</code>運算符，例如：</p><pre class="programlisting">x := foo
y := $(x) bar

all: 
	@echo "-$(y)-"</pre><p>當<code class="literal">make</code>讀到<code class="literal">y := $(x) bar</code>定義時，立即把<code class="literal">$(x)</code>展開，使變數<code class="literal">y</code>的取值是<code class="literal">foo bar</code>，如果把這兩行顛倒過來：</p><pre class="programlisting">y := $(x) bar
x := foo</pre><p>那麼當<code class="literal">make</code>讀到<code class="literal">y := $(x) bar</code>時，<code class="literal">x</code>還沒有定義，展開為空值，所以<code class="literal">y</code>的取值是<code class="literal">␣bar</code>，注意<code class="literal">bar</code>前面有個空格。一個變數的定義從<code class="literal">=</code>後面的第一個非空白字元開始（從<code class="literal">$(x)</code>的<code class="literal">$</code>開始），包括後面的所有字元，直到註釋或換行之前結束。如果要定義一個變數的值是一個空格，可以這樣：</p><pre class="programlisting">nullstring := 
space := $(nullstring) # end of the line</pre><p><code class="literal">nullstring</code>的值為空，<code class="literal">space</code>的值是一個空格，後面寫個註釋是為了增加可讀性，如果不寫註釋就換行，則很難看出<code class="literal">$(nullstring)</code>後面有個空格。</p><p>還有一個比較有用的賦值運算符是<code class="literal">?=</code>，例如<code class="literal">foo ?= $(bar)</code>的意思是：如果<code class="literal">foo</code>沒有定義過，那麼<code class="literal">?=</code>相當於<code class="literal">=</code>，定義<code class="literal">foo</code>的值是<code class="literal">$(bar)</code>，但不立即展開；如果先前已經定義了<code class="literal">foo</code>，則什麼也不做，不會給<code class="literal">foo</code>重新賦值。</p><p><code class="literal">+=</code>運算符可以給變數追加值，例如：</p><pre class="programlisting">objects = main.o
objects += $(foo)
foo = foo.o bar.o</pre><p><code class="literal">object</code>是用<code class="literal">=</code>定義的，<code class="literal">+=</code>仍然保持<code class="literal">=</code>的特性，<code class="literal">objects</code>的值是<code class="literal">main.o $(foo)</code>（注意<code class="literal">$(foo)</code>前面自動添一個空格），但不立即展開，等到後面需要展開<code class="literal">$(objects)</code>時會展開成<code class="literal">main.o foo.o bar.o</code>。</p><p>再比如：</p><pre class="programlisting">objects := main.o
objects += $(foo)
foo = foo.o bar.o</pre><p><code class="literal">object</code>是用<code class="literal">:=</code>定義的，<code class="literal">+=</code>保持<code class="literal">:=</code>的特性，<code class="literal">objects</code>的值是<code class="literal">main.o $(foo)</code>，立即展開得到<code class="literal">main.o </code>（這時<code class="literal">foo</code>還沒定義），注意<code class="literal">main.o</code>後面的空格仍保留。</p><p>如果變數還沒有定義過就直接用<code class="literal">+=</code>賦值，那麼<code class="literal">+=</code>相當於<code class="literal">=</code>。</p><p>上一節我們用到了特殊變數<code class="literal">$@</code>和<code class="literal">$&lt;</code>，這兩個變數的特點是不需要給它們賦值，在不同的上下文中它們自動取不同的值。常用的特殊變數有：</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">$@</code>，表示規則中的目標。</p></li><li><p><code class="literal">$&lt;</code>，表示規則中的第一個條件。</p></li><li><p><code class="literal">$?</code>，表示規則中所有比目標新的條件，組成一個列表，以空格分隔。</p></li><li><p><code class="literal">$^</code>，表示規則中的所有條件，組成一個列表，以空格分隔。</p></li></ul></div><p>例如前面寫過的這條規則：</p><pre class="programlisting">main: main.o stack.o maze.o
	gcc main.o stack.o maze.o -o main</pre><p>可以改寫成：</p><pre class="programlisting">main: main.o stack.o maze.o
	gcc $^ -o $@</pre><p>這樣即使以後又往條件裡添加了新的目標檔案，編譯命令也不需要修改，減少了出錯的可能。</p><p><code class="literal">$?</code>變數也很有用，有時候希望只對更新過的條件進行操作，例如有一個庫檔案<code class="literal">libsome.a</code>依賴于幾個目標檔案：</p><pre class="programlisting">libsome.a: foo.o bar.o lose.o win.o 
	ar r libsome.a $?
	ranlib libsome.a</pre><p>這樣，只有更新過的目標檔案才需要重新打包到<code class="literal">libsome.a</code>中，沒更新過的目標檔案原本已經在<code class="literal">libsome.a</code>中了，不必重新打包。</p><p>在上一節我們看到<code class="literal">make</code>的隱含規則資料庫中用到了很多變數，有些變數沒有定義（例如<code class="literal">CFLAGS</code>），有些變數定義了預設值（例如<code class="literal">CC</code>），我們寫Makefile時可以重新定義這些變數的值，也可以在預設值的基礎上追加。以下列舉一些常用的變數，請讀者體會其中的規律。</p><div class="variablelist"><dl><dt><span class="term"><code class="literal">AR</code></span></dt><dd><p>靜態庫打包命令的名字，預設值是<code class="literal">ar</code>。</p></dd><dt><span class="term"><code class="literal">ARFLAGS</code></span></dt><dd><p>靜態庫打包命令的選項，預設值是<code class="literal">rv</code>。</p></dd><dt><span class="term"><code class="literal">AS</code></span></dt><dd><p>彙編器的名字，預設值是<code class="literal">as</code>。</p></dd><dt><span class="term"><code class="literal">ASFLAGS</code></span></dt><dd><p>彙編器的選項，沒有定義。</p></dd><dt><span class="term">CC</span></dt><dd><p>C編譯器的名字，預設值是<code class="literal">cc</code>。</p></dd><dt><span class="term">CFLAGS</span></dt><dd><p>C編譯器的選項，沒有定義。</p></dd><dt><span class="term">CXX</span></dt><dd><p>C++編譯器的名字，預設值是<code class="literal">g++</code>。</p></dd><dt><span class="term">CXXFLAGS</span></dt><dd><p>C++編譯器的選項，沒有定義。</p></dd><dt><span class="term">CPP</span></dt><dd><p>C預處理器的名字，預設值是<code class="literal">$(CC) -E</code>。</p></dd><dt><span class="term">CPPFLAGS</span></dt><dd><p>C預處理器的選項，沒有定義。</p></dd><dt><span class="term">LD</span></dt><dd><p>連結器的名字，預設值是<code class="literal">ld</code>。</p></dd><dt><span class="term">LDFLAGS</span></dt><dd><p>連結器的選項，沒有定義。</p></dd><dt><span class="term">TARGET_ARCH</span></dt><dd><p>和目標平台相關的命令行選項，沒有定義。</p></dd><dt><span class="term">OUTPUT_OPTION</span></dt><dd><p>輸出的命令行選項，預設值是<code class="literal">-o $@</code>。</p></dd><dt><span class="term">LINK.o</span></dt><dd><p>把<code class="literal">.o</code>檔案連結在一起的命令行，預設值是<code class="literal">$(CC) $(LDFLAGS) $(TARGET_ARCH)</code>。</p></dd><dt><span class="term">LINK.c</span></dt><dd><p>把<code class="literal">.c</code>檔案連結在一起的命令行，預設值是<code class="literal">$(CC) $(CFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)</code>。</p></dd><dt><span class="term">LINK.cc</span></dt><dd><p>把<code class="literal">.cc</code>檔案（C++源檔案）連結在一起的命令行，預設值是<code class="literal">$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(LDFLAGS) $(TARGET_ARCH)</code>。</p></dd><dt><span class="term">COMPILE.c</span></dt><dd><p>編譯<code class="literal">.c</code>檔案的命令行，預設值是<code class="literal">$(CC) $(CFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c</code>。</p></dd><dt><span class="term">COMPILE.cc</span></dt><dd><p>編譯<code class="literal">.cc</code>檔案的命令行，預設值是<code class="literal">$(CXX) $(CXXFLAGS) $(CPPFLAGS) $(TARGET_ARCH) -c</code>。</p></dd><dt><span class="term">RM</span></dt><dd><p>刪除命令的名字，預設值是<code class="literal">rm -f</code>。</p></dd></dl></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch22s02.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch22.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch22s04.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">2. 隱含規則和模式規則 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 4. 自動處理標頭檔的依賴關係</td></tr></table></div></body></html>
