字元編碼
==========

ASCII碼
------------

ASCII碼的取值範圍是0~127，可以用7個bit表示。C語言規定 ``char`` 型占一個位元組，如果存放ASCII碼則只用到低7位，高位為0。以下是ASCII碼表：

.. _app-encoding.asciitable:

.. table:: ASCII碼表

   === == === ============================ === == === ======= === == === ==== === == === ====
   Dec Hx Oct Char                         Dec Hx Oct Char    Dec Hx Oct Char Dec Hx Oct Char
   === == === ============================ === == === ======= === == === ==== === == === ====
   0   0  0   NUL (null)                   32  20 40  (blank) 64  40 100 @    96  60 140 \`
   1   1  1   SOH (start of heading)       33  21 41  !       65  41 101 A    97  61 141 a
   2   2  2   STX (start of text)          34  22 42  "       66  42 102 B    98  62 142 b
   3   3  3   ETX (end of text)            35  23 43  #       67  43 103 C    99  63 143 c
   4   4  4   EOT (end of transmission)    36  24 44  $       68  44 104 D    100 64 144 d
   5   5  5   ENQ (enquiry)                37  25 45  %       69  45 105 E    101 65 145 e
   6   6  6   ACK (acknowledge)            38  26 46  &       70  46 106 F    102 66 146 f
   7   7  7   BEL (bell)                   39  27 47  '       71  47 107 G    103 67 147 g
   8   8  10  BS  (backspace)              40  28 50  (       72  48 110 H    104 68 150 h
   9   9  11  TAB (horizontal tab)         41  29 51  )       73  49 111 I    105 69 151 i
   10  a  12  LF  (NL line feed, new line) 42  2a 52  \*      74  4a 112 J    106 6a 152 j
   11  b  13  VT  (vertical tab)           43  2b 53  \+      75  4b 113 K    107 6b 153 k
   12  c  14  FF  (NP form feed, new page) 44  2c 54  ,       76  4c 114 L    108 6c 154 l
   13  d  15  CR  (carriage return)        45  2d 55  \-      77  4d 115 M    109 6d 155 m
   14  e  16  SO  (shift out)              46  2e 56  .       78  4e 116 N    110 6e 156 n
   15  f  17  SI  (shift in)               47  2f 57  /       79  4f 117 O    111 6f 157 o
   16  10 20  DLE (data link escape)       48  30 60  0       80  50 120 P    112 70 160 p
   17  11 21  DC1 (device control 1)       49  31 61  1       81  51 121 Q    113 71 161 q
   18  12 22  DC2 (device control 2)       50  32 62  2       82  52 122 R    114 72 162 r
   19  13 23  DC3 (device control 3)       51  33 63  3       83  53 123 S    115 73 163 s
   20  14 24  DC4 (device control 4)       52  34 64  4       84  54 124 T    116 74 164 t
   21  15 25  NAK (negative acknowledge)   53  35 65  5       85  55 125 U    117 75 165 u
   22  16 26  SYN (synchronous idle)       54  36 66  6       86  56 126 V    118 76 166 v
   23  17 27  ETB (end of trans. block)    55  37 67  7       87  57 127 W    119 77 167 w
   24  18 30  CAN (cancel)                 56  38 70  8       88  58 130 X    120 78 170 x
   25  19 31  EM  (end of medium)          57  39 71  9       89  59 131 Y    121 79 171 y
   26  1a 32  SUB (substitute)             58  3a 72  :       90  5a 132 Z    122 7a 172 z
   27  1b 33  ESC (escape)                 59  3b 73  ;       91  5b 133 [    123 7b 173 {
   28  1c 34  FS  (file separator)         60  3c 74  <       92  5c 134 \\   124 7c 174 \|
   29  1d 35  GS  (group separator)        61  3d 75  =       93  5d 135 ]    125 7d 175 }
   30  1e 36  RS  (recored separator)      62  3e 76  >       94  5e 136 ^    126 7e 176 ~
   31  1f 37  US  (unit separator)         63  3f 77  ?       95  5f 137 _    127 7f 177 DEL
   === == === ============================ === == === ======= === == === ==== === == === ====

.. index:: k擴展ASCII碼, Extended ASCII

絶大多數計算機的一個位元組是8位，取值範圍是0~255，而ASCII碼並沒有規定編號為128~255的字元，為了能用一個位元組表示更多的字元，各廠商制定了很多種ASCII碼的擴展規範。注意，雖然通常把這些規範稱為擴展ASCII碼（Extended ASCII），但其實它們並不屬於ASCII碼標準。例如下面這種擴展ASCII碼由IBM制定，在字元終端下被廣泛採用，其中包含了很多表格邊線字元用來畫界面。

.. figure:: ../images/app-encoding.extascii.png

   IBM的擴展ASCII碼表

.. index:: ISO-8859-1, Latin-1

在圖形界面下最廣泛使用的擴展ASCII碼是ISO-8859-1，也稱為Latin-1，其中包含歐洲各國語言中最常用的非英文字母，但畢竟只擴展了128個字元，一些不常用的字母就沒有包含進來。如下表所示。

.. table:: ISO-8859-1

   === = === = === = === = === = === =
   160   176 ° 192 À 208 Ð 224 à 240 ð 
   161 ¡ 177 ± 193 Á 209 Ñ 225 á 241 ñ 
   162 ¢ 178 ² 194 Â 210 Ò 226 â 242 ò 
   163 £ 179 ³ 195 Ã 211 Ó 227 ã 243 ó 
   164 ¤ 180 ´ 196 Ä 212 Ô 228 ä 244 ô 
   165 ¥ 181 µ 197 Å 213 Õ 229 å 245 õ 
   166 ¦ 182 ¶ 198 Æ 214 Ö 230 æ 246 ö 
   167 § 183 · 199 Ç 215 × 231 ç 247 ÷ 
   168 ¨ 184 ¸ 200 È 216 Ø 232 è 248 ø 
   169 © 185 ¹ 201 É 217 Ù 233 é 249 ù 
   170 ª 186 º 202 Ê 218 Ú 234 ê 250 ú 
   171 « 187 » 203 Ë 219 Û 235 ë 251 û 
   172 ¬ 188 ¼ 204 Ì 220 Ü 236 ì 252 ü 
   173 ­ 189 ½ 205 Í 221 Ý 237 í 253 ý 
   174 ® 190 ¾ 206 Î 222 Þ 238 î 254 þ 
   175 ¯ 191 ¿ 207 Ï 223 ß 239 ï 255 ÿ 
   === = === = === = === = === = === =

編號128~159的是一些控制字元，在上表中沒有列出。

Unicode和UTF-8
------------------------

.. index:: ISO 10646, UCS, Universal Character Set, p平面, Plane, BMP, Basic Multilingual Plane, Plane 0, Unicode

為了在一套編碼中涵蓋全世界各國語言文字和專業領域符號（例如數學符號、樂譜符號），ISO制定了ISO 10646標準，也稱為UCS（Universal Character Set）。UCS編碼的長度是31位，可以表示2\ :sup:`31` 個字元。如果兩個字元編碼的高位相同，只有低16位不同，則它們屬於同一個平面（Plane），所以一個平面由2\ :sup:`16` 個字元組成。目前絶大多數常用字元都位於第一個平面（編碼範圍是0x0000~0xFFFF），稱為BMP（Basic Multilingual Plane）或Plane 0，為了向後兼容，其中編號為0~256的字元和ASCII碼以及Latin-1相同。UCS編碼通常用U-xxxxxxxx這種形式表示，而BMP的編碼通常用U+xxxx這種形式表示，其中x是十六進制數字。在ISO制定UCS的同時，另一個廠商聯合組織也在着手制定這樣的編碼，稱為Unicode，後來兩家聯手制定統一的編碼，但各自發佈各自的標準文檔，所以UCS編碼和Unicode碼是相同的。

.. index:: UCS-4, UTF-32, UTF, Unicode Transformation Format, UCS-2, UTF-16, Surrogate Pair

有了字元編碼，另一個問題就是這樣的編碼在計算機中怎麼表示。現在已經不可能用一個位元組表示一個字元了，最直接的想法就是用四個位元組表示一個字元，這種表示方法稱為UCS-4或UTF-32，UTF是Unicode Transformation Format的縮寫。這樣表示顯然比較浪費存儲空間，如果表示BMP字元，4個位元組中的兩個高位位元組都是0，如果表示ASCII或Latin-1字元，4個位元組中的3個高位位元組都是0，而我們常用的絶大多數字元都在BMP、ASCII或Latin-1字符集中。另一種比較節省存儲空間的辦法是用兩個位元組表示一個字元，稱為UCS-2或UTF-16，這樣只能表示BMP中的字元，但BMP中有一些控制字元用於擴展，可以用兩個這樣的控制字元表示其他平面的字元，稱為Surrogate Pair。

無論是UTF-32還是UTF-16都有一個更嚴重的問題就是和C語言不兼容，在C語言中位元組0表示字元串結尾，庫函數 ``strlen`` 、 ``strcpy`` 等等都依賴于這一點，如果字元串用UTF-32或UTF-16存儲，其中有很多位元組0並不表示字元串結尾，那就亂套了。

.. index:: UTF-8

UNIX之父Ken Thompson提出的UTF-8編碼很好地解決了這個問題，因此得到廣泛應用。和UTF-16、UTF-32不同的是，UTF-8編碼的長度不固定，每個字元用1~6個位元組表示。UTF-8編碼具有以下性質：

*  編碼為U+0000~U+007F的字元只占一個位元組，就是0x00~0x7F，和ASCII碼兼容。
*  編碼大於U+007F的字元用2~6個位元組表示，每個位元組的最高位都是1，而所有ASCII碼的最高位都是0，因此非ASCII碼字元的UTF-8編碼中不會出現ASCII碼的位元組（也不會出現位元組0）。
*  在非ASCII碼字元的多位元組編碼中，第一個位元組的取值範圍是0xC0~0xFD，根據第一個位元組可以判斷後面還有幾個位元組也屬於當前字元的編碼，後面每個位元組的取值範圍都是0x80~0xBF，詳見下面的編碼格式。
*  所有Unicode字元（共231個）都可以用UTF-8編碼表示出來。
*  UTF-8編碼最長6個位元組，BMP字元的UTF-8編碼最長三個位元組。
*  0xFE和0xFF這兩個位元組在UTF-8編碼中不會出現。

具體來說，UTF-8編碼有以下幾種格式::

   U-00000000 – U-0000007F: 0xxxxxxx
   U-00000080 – U-000007FF: 110xxxxx 10xxxxxx
   U-00000800 – U-0000FFFF: 1110xxxx 10xxxxxx 10xxxxxx
   U-00010000 – U-001FFFFF: 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
   U-00200000 – U-03FFFFFF: 111110xx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx
   U-04000000 – U-7FFFFFFF: 1111110x 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx 10xxxxxx

*  ASCII碼字元的UTF-8編碼只有一個位元組（就是ASCII碼本身），最高位是0。
*  非ASCII碼字元的第一個位元組最高位是1，並且後面至少還要跟一個1，最高位後面跟幾個1就表示後面還有幾個位元組也屬於當前字元的編碼，例如111110xx，最高位後面跟4個1，表示後面還有4個位元組也屬於當前字元的編碼。
*  後面每個位元組的最高兩位都是10，而第一個位元組的最高兩位要麼是0x，要麼是11，因此可以和後面的位元組區分開。這樣的設計有利於誤碼同步，例如在網絡傳輸過程中丟失了幾個位元組，很容易判斷當前字元是不完整的，也很容易找到下一個字元應該從哪開始，頂多丟掉一兩個字元就可以同步了，而不會導致後面的解碼過程全部錯亂。
*  上面的格式中標為x的位就是字元的Unicode碼，最後一種6位元組的格式中x位有31個，可以表示31位的Unicode碼。UTF-8編碼就像一列火車，第一個位元組是車頭，後面每個位元組是車廂，其中承載的貨物是Unicode碼。UTF-8規定承載的Unicode碼以大端表示，就是說第一個位元組中的x位是Unicode碼的高位，後面位元組中的x位是Unicode碼的低位。
*  UTF-8規定每個字元必須用儘可能少的位元組來編碼，換句話說，在符合編碼格式的前提下，Unicode碼從最高位開始的0位要儘可能少。

舉例來說，U+00A9（©字元）的二進制是10101001，編碼成UTF-8是11000010 10101001（0xC2 0xA9），但不能編碼成11100000 10000010 10101001。

在Linux C編程中使用Unicode和UTF-8
--------------------------------------

目前各種Linux發行版都支持UTF-8編碼，在磁碟上保存一個含有非ASCII字元的文本檔案，預設是以UTF-8編碼的。當前系統的字元編碼設置可以用 :command:`locale` 命令查看::

   $ locale
   LANG=en_US.UTF-8
   LANGUAGE=
   LC_CTYPE="en_US.UTF-8"
   LC_NUMERIC="en_US.UTF-8"
   LC_TIME="en_US.UTF-8"
   LC_COLLATE="en_US.UTF-8"
   LC_MONETARY="en_US.UTF-8"
   LC_MESSAGES="en_US.UTF-8"
   LC_PAPER="en_US.UTF-8"
   LC_NAME="en_US.UTF-8"
   LC_ADDRESS="en_US.UTF-8"
   LC_TELEPHONE="en_US.UTF-8"
   LC_MEASUREMENT="en_US.UTF-8"
   LC_IDENTIFICATION="en_US.UTF-8"
   LC_ALL=

.. index:: Locale

Locale定義了語言、字元編碼、日期時間格式、數字格式、貨幣格式等參數，詳見 :manpage:`locale(1)` 、 :manpage:`locale(5)` 、 :manpage:`locale(7)` 。 :command:`locale` 命令列出的這些參數每一個都可以用環境變數單獨設置，但通常這些參數的取值是一致的。在我的系統中只設置了環境變數 ``LANG`` ，其他參數沒有設置，用 :command:`locale` 命令可以看到其他Locale參數也繼承了環境變數 ``LANG`` 的值。

常用漢字都位於BMP中，所以一個漢字的UTF-8編碼通常是3個位元組。例如編輯一個C程序：

.. code-block:: c
   :linenos:

   #include <stdio.h>

   int main(void)
   {
           printf("你好\n");
           return 0;
   }

源檔案是以UTF-8編碼存儲的::

   $ hexdump -C nihao.c 
   00000000  23 69 6e 63 6c 75 64 65  20 3c 73 74 64 69 6f 2e  |#include <stdio.|
   00000010  68 3e 0a 0a 69 6e 74 20  6d 61 69 6e 28 76 6f 69  |h>..int main(voi|
   00000020  64 29 0a 7b 0a 09 70 72  69 6e 74 66 28 22 e4 bd  |d).{..printf("..|
   00000030  a0 e5 a5 bd 5c 6e 22 29  3b 0a 09 72 65 74 75 72  |....\n");..retur|
   00000040  6e 20 30 3b 0a 7d 0a                              |n 0;.}.|
   00000047

.. index:: Multibyte Character

其中 ``e4 bd a0`` 這三個位元組就是“你”的UTF-8編碼， ``e5 a5 bd`` 這三個位元組就是“好”的UTF-8編碼。把它編譯成目標檔案，"你好\n"這個字元串就成了這樣一串位元組： ``e4 bd a0 e5 a5 bd 0a 00`` ，轉義序列由兩個位元組變成一個位元組，字元串末尾添了一個位元組0，而漢字仍然占3個位元組，在C標準中多位元組編碼的字元稱為Multibyte Character。運行這個程序會把這一串位元組輸出到當前終端設備，如果當前終端能夠識別UTF-8編碼（比如圖形界面的終端窗口）就能打印出漢字，如果不能識別UTF-8編碼（比如一般的字元終端）就打印不出漢字。也就是說，在這個程序中識別漢字的工作既不是由C編譯器做的也不是由 ``printf`` 函數做的，C編譯器原封不動地把源檔案中的UTF-8編碼複製到目標檔案中， ``printf`` 函數再把這一串位元組當作以Null結尾的字元串原封不動地輸出到終端設備，識別漢字的工作是由終端設備做的。

.. index:: Wide Character

僅有這種程度的漢字支持是不夠的，有時候我們需要在C程序中操作字元串裡的字元，比如求字元串"你好\n"中有幾個漢字或字元，用 ``strlen`` 就不靈了，因為 ``strlen`` 求的是位元組數而不是字元數。為了在程序中操作Unicode字元，C標準定義了寬字元（Wide Character）類型 ``wchar_t`` （使用這個類型名需包含標頭檔 :file:`wchar.h` ）。在字元常量或字元串字面值前面加一個 ``L`` 就表示寬字元常量或寬字元串，例如定義 ``wchar_t c = L'你';`` ，變數 ``c`` 的值就是漢字“你”的31位Unicode碼，而 ``L"你好\n"`` 就相當於數組 ``wchar_t str[] = { L'你', L'好', L'\n', 0 };`` 。C標準還定義了一些操作寬字元串的庫函數，例如 ``wcslen`` 函數可以取寬字元串中的字元個數。

注意Wide Character和Multibyte Character這兩個概念的區別：

#. C標準沒有規定Wide Character和Multibyte Character應該採用什麼編碼，但目前各種Linux發行版的Wide Character都採用Unicode碼，Multibyte Character都採用UTF-8編碼。
#. 每個Wide Character有固定的長度，用 ``wchar_t`` 類型來表示。而每個Multibyte Character的長度不固定，沒有規定一種類型來表示Multibyte Character。
#. Wide Character中可能包含位元組0，所以不能保存在普通的以Null結尾的字元串中，而必須保存在寬字元串中。而Multibyte Character中除了Null字元外不允許出現位元組0，因此可以保存在以Null結尾的字元串中。
#. Wide Character適合做字元運算，比如統計字元數，而Multibyte Character適合做存儲和傳輸，存儲時比較節省空間，傳輸時有較好的容錯性。

看下面的例子：

.. code-block:: c
   :linenos:

   #include <stdio.h>
   #include <locale.h>

   int main(void)
   {
           if (!setlocale(LC_CTYPE, "")) {
                   fprintf(stderr, "Can't set the specified locale! "
                           "Check LC_ALL, LC_CTYPE, LANG.\n");
                   return 1;
           }
           printf("%ls", L"你好\n");
           return 0;
   }

寬字元串 ``L"你好\n"`` 在原始碼中當然還是UTF-8編碼，但編譯器會把它轉換成4個Unicode碼 ``0x00004f60 0x0000597d 0x0000000a 0x00000000`` 保存到目標檔案中，按小端存儲就是 ``60 4f 00 00 7d 59 00 00 0a 00 00 00 00 00 00 00`` ，用 ``hexdump`` 命令查看目標檔案可以找到這些位元組。

``printf`` 的轉換說明 ``%ls`` 表示把後面的參數按寬字元串解釋，不是見到位元組0就結束，而是見到Null字元的Unicode碼（4個位元組0）才結束，但輸出到終端仍然要以Multibyte Character編碼輸出，這樣終端設備才能識別，所以 ``printf`` 函數先把寬字元串轉換成UTF-8編碼的Multibyte Character字元串再輸出到終端。我們把輸出重定向到檔案會看得更清楚::

   $ gcc main.c
   $ ./a.out > foo
   $ hexdump -C foo
   00000000  e4 bd a0 e5 a5 bd 0a                              |.......|
   00000007

最後解釋一下 :manpage:`setlocale(3)` 函數：

#. 雖然當前系統的Locale設置是 ``"en_US.UTF-8"`` ，但C程序在啟動時各種Locale參數都設置成預設值 ``"C"`` ，並不繼承當前系統的Locale設置。這樣規定是為了代碼的可移植性，如果一個C程序不調用 ``setlocale`` 函數，那麼它不管在什麼系統上運行，其各種Locale參數都是 ``"C"`` ，其中 ``LC_CTYPE`` 參數是 ``"C"`` 表示採用ASCII字符集。
#. 我們調用 ``setlocale`` 傳的第一個參數是 ``LC_CTYPE`` ，它在C語言中被定義成一個整數常量，第二個參數是設置給它的值。如果第二個參數是空字元串 ``""`` ，則表示採用當前系統的Locale設置， ``setlocale`` 函數依次查找環境變數 ``LC_ALL`` 、 ``LC_CTYPE`` 和 ``LANG`` ，找到第一個有定義的環境變數就用它的值來設置 ``LC_CTYPE`` 。因此，調用 ``setlocale`` 函數後 ``LC_CTYPE`` 參數的值變成了 ``"en_US.UTF-8"`` 。
#. ``LC_CTYPE`` 參數影響C語言對寬字元和寬字元串的處理，正因為我們通過這個參數設置了UTF-8編碼， ``printf`` 函數才會把寬字元串轉換成UTF-8編碼的Multibyte Character字元串再輸出到終端。上面的程序如果去掉 ``setlocale`` 調用， ``LC_CTYPE`` 參數的值預設是 ``"C"`` （採用ASCII字符集），則無法打印出“你好”，因為這兩個字元不屬於ASCII字符集。

關於Unicode和UTF-8本節只介紹了最基本的概念，部分內容出自 [UnicodeFAQ]_ ，讀者可進一步參考這篇文章。
