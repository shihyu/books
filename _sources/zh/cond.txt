分支語句
==================

.. _cond.if:

if語句
-----------

目前我們寫的簡單函數中可以有多條語句，但這些語句總是從前到後順序執行的。除了順序執行之外，有時候我們需要檢查一個條件，然後根據檢查的結果執行不同的後續代碼，在C語言中可以用分支語句實現，比如：

.. code-block:: c
   :linenos:

   if (x != 0) {
           printf("x is nonzero.\n");
   }

.. index:: k控製表達式, Controlling Expressoin, k控制流程, f分支, Branch

其中 ``x != 0`` 表示“x不等於0”的條件，這個表達式稱為控製表達式（Controlling Expression），如果條件成立，則{}中的語句被執行，否則{}中的語句不執行，直接跳到}後面。 ``if`` 和控製表達式改變了程序的控制流程（Control Flow），不再是從前到後順序執行，而是根據不同的條件執行不同的語句，這種控制流程稱為分支（Branch）。上例中的 ``!=`` 運算符表示“不等於”，像這樣的運算符有：

.. table:: 關係運算符和相等性運算符

   =========    ===========
   運算符        含義
   =========    ===========
   ==           等於
   !=           不等於
   >            大於
   <            小於
   >=           大於或等於
   <=           小於或等於
   =========    ===========

注意以下幾點：

.. index:: z真, True, j假, False, x相等性運算符, Equality Operator, g關係運算符, Relational Operator

#. 這裡的 ``==`` 表示數學中的相等關係，相當於數學中的=號，初學者常犯的錯誤是在控製表達式中把 ``==`` 寫成 ``=`` ，在C語言中=號是賦值運算符，兩者的含義完全不同。
#. 如果表達式所表示的比較關係成立則值為真（True），否則為假（False），在C語言中分別用 ``int`` 型的1和0表示。如果變數 ``x`` 的值是-1，那麼 ``x > 0`` 這個表達式的值為0， ``x > -2`` 這個表達式的值為1。
#. 在數學中a<b<c表示b既大於a又小於c，但作為C語言表達式卻不是這樣。以上幾種運算符都是左結合的，請讀者想一下這個表達式在C語言中的求值步驟是怎樣的。
#. 這些運算符的兩個操作數應該是相同類型的，兩邊都是整型或者都是浮點型可以做比較，但兩個字元串不能做比較，在 :ref:`stdlib.comparestring` 我們會介紹比較字元串的方法。
#. ``==`` 和 ``!=`` 稱為相等性運算符（Equality Operator），其餘四個稱為關係運算符（Relational Operator），相等性運算符的優先順序低於關係運算符。

總結一下， ``if (x != 0) { ... }`` 這個語句的計算順序是：首先求 ``x != 0`` 這個表達式的值，如果值為0，就跳過{}中的語句直接執行後面的語句，如果值為1，就先執行{}中的語句，然後再執行後面的語句。事實上控製表達式取任何非0值都表示真值，因此 ``if (x) { ... }`` 和 ``if (x != 0) { ... }`` 是等價的：假設 ``x`` 的值是2，則 ``x != 0`` 的值是1，但對於 ``if`` 來說不管控製表達式的值是2還是1都表示真值。

和if語句相關的語法規則如下::

   語句 → if (控製表達式) 語句
   語句 → { 語句列表 }
   語句 → ;

.. index:: y語句塊, Statement Block, k空語句, Null Statement

在C語言中，任何允許出現語句的地方既可以是由;號結尾的一條語句，也可以是由{}括起來的若干條語句或聲明組成的語句塊（Statement Block），語句塊和上一章介紹的函數體的語法相同。注意語句塊的}後面不需要加;號。如果}後面加了;號，則這個;號本身又是一條新的語句了，在C語言中一個單獨的;號表示一條空語句（Null Statement）。上例的語句塊中只有一條語句，其實沒必要寫成語句塊，可以簡單地寫成：

.. code-block:: c
   :linenos:

   if (x != 0)
           printf("x is nonzero.\n");

``if`` 語句不一定要包含語句塊，而語句塊也不一定非得用在 ``if`` 語句中。語句塊可以用在任何允許出現語句的地方，單獨使用語句塊通常是為了定義一些比函數的局部變數更“局部”的變數。例如：

.. code-block:: c
   :linenos:

   void foo(void)
   {
           int i = 0;
           {
                   int i = 1;
                   int j = 2;
                   printf("i=%d, j=%d\n", i, j);
           }
           printf("i=%d\n", i); /* cannot access j here */
   }

和函數的局部變數同樣道理，每次進入語句塊時為變數 ``j`` 分配存儲空間，每次退出語句塊時釋放變數 ``j`` 的存儲空間。語句塊也構成一個作用域，類似 :ref:`func.scope` 分析一下可以得到如下結論：

#. 如果整個源檔案是一張大紙， ``foo`` 函數是蓋在上面的一張小紙，則函數中的語句塊是蓋在小紙上面的一張更小的紙。
#. 語句塊中的變數 ``i`` 和函數的局部變數 ``i`` 是兩個不同的變數，因此兩次打印的 ``i`` 值是不同的。
#. 語句塊中的變數 ``j`` 在退出語句塊之後就沒有了，因此最後一行的 ``printf`` 不能打印變數 ``j`` ，否則編譯器會報錯。

.. rubric:: 習題

#. 以下程序段編譯能通過，執行也不出錯，但是執行結果不正確（根據 :ref:`intro.debug` 的定義，這是一個語義錯誤），請分析一下哪裡錯了。還有，既然錯了為什麼編譯能通過呢？

   .. code-block:: c
      :linenos:

      int x = -1;
      if (x > 0);
              printf("x is positive\n");

.. _cond.ifelse:

if/else語句
-------------------

.. index:: z子句, Clause

``if`` 語句還可以帶一個 ``else`` 子句（Clause），例如：

.. code-block:: c
   :linenos:

   if (x % 2 == 0)
           printf("x is even\n");
   else
           printf("x is odd\n");

.. index:: q取模, Modulo, y餘數, Remainder

這裡的%是取模（Modulo）運算符， ``x%2`` 表示 ``x`` 除以2所得的餘數（Remainder），C語言規定%運算符的兩個操作數必須是整型的。兩個正數相除取餘數很好理解，如果操作數中有負數，結果應該是正是負呢？C99規定：如果 ``a`` 和 ``b`` 是整型， ``b`` 不等於0，則表達式 ``(a/b)*b+a%b`` 的值總是等於 ``a`` 。再結合 :ref:`expr.expression` 講過的整數除法運算要Truncate towards Zero，可以得到一個結論： **%運算符的結果總是與被除數同號** （讀者可以自己推導一下）。其他編程語言對取模運算的規定各不相同，也有規定結果和除數同號的，也有不做明確規定的。

取模運算在程序非常有用，例如上面的例子判斷 ``x`` 的奇偶性，看 ``x`` 除以2的餘數是不是0，如果是0則打印 ``x is even`` ，如果不是0則打印 ``x is odd`` 。讀者應該能看出 ``else`` 在這裡的作用了：假如從上面的例子中去掉 ``else`` ，則不管 ``x`` 是奇是偶， ``printf("x is odd\n");`` 這條語句總是被執行。

為了讓這個判斷和打印操作更有用，可以把它封裝成一個函數：

.. code-block:: c
   :linenos:

   void print_even_or_odd(int x)
   {
           if (x % 2 == 0)
                   printf("x is even\n");
           else
                   printf("x is odd\n");
   }

**把語句封裝成函數的基本步驟是：把語句放到函數體中，把變數改成函數的參數。** 這樣，以後要檢查一個數的奇偶性只需調一下函數即可，不必重複寫這個 ``if/else`` 語句了，例如：

.. code-block:: c
   :linenos:

   print_even_or_odd(17);
   print_even_or_odd(18);

``if/else`` 語句的語法規則如下::

   語句 → if (控製表達式) 語句 else 語句

右邊的“語句”既可以是一條語句，也可以是由{}括起來的語句塊。一條 ``if`` 語句中包含一條子語句，一條 ``if/else`` 語句中包含兩條子語句，子語句可以是任何語句或語句塊，當然也可以是另外一條 ``if`` 或 ``if/else`` 語句。根據組合規則， ``if`` 或 ``if/else`` 可以嵌套使用。例如可以這樣：

.. code-block:: c
   :linenos:

   if (x > 0) {
           printf("x is positive\n");
   } else {
           if (x < 0)
                   printf("x is negative\n");
           else
                   printf("x is zero\n");
   }

等價于下面這種不用語句塊的寫法：

.. code-block:: c
   :linenos:

   if (x > 0)
           printf("x is positive\n");
   else if (x < 0)
           printf("x is negative\n");
   else
           printf("x is zero\n");

現在問題來了：如果不用語句塊，那麼類似 ``if (A) if (B) C; else D;`` 形式的語句該怎麼理解呢？可以理解成

.. code-block:: c
   :linenos:

   if (A)
           if (B)
                   C;
   else
           D;

也可以理解成

.. code-block:: c
   :linenos:

   if (A)
           if (B)
                   C;
           else
                   D;

.. index:: Dangling-else

在 :ref:`expr.helloworld` 講過，C代碼的縮進只是為了程序員看起來方便，實際上對編譯器不起任何作用，你的代碼不管寫成上面哪一種縮進格式，在編譯器看起來都是一樣的。那麼編譯器到底按哪種方式理解呢？換句話說，編譯器認為 ``else`` 到底是和 ``if (A)`` 配對還是和 ``if (B)`` 配對？很多編程語言的語法都有這個問題，稱為Dangling-else問題。C語言規定， **else總是和它前面最近的一個if配對** ，因此應該理解成 ``else`` 和 ``if (B)`` 配對，也就是按第二種方式理解。如果你寫成上面第一種縮進的格式就很危險了：你看到的是這樣，而編譯器理解的卻是那樣。如果你希望編譯器按第一種方式理解，應該明確加上{}：

.. code-block:: c
   :linenos:

   if (A) {
           if (B)
                   C;
   } else
           D;

.. rubric:: 習題

#. 寫兩個表達式，分別取整型變數 ``x`` 的個位和十位。
#. 寫一個函數，參數是整型變數 ``x`` ，功能是打印 ``x`` 的個位和十位。

.. _cond.bool:

布爾代數
------------------

在 :ref:`cond.if` 講過，在數學上a<b<c表示b既大於a又小於c，但在C語言中不能這麼寫，那如果想表示這個含義該怎麼寫呢？可以這樣：

.. code-block:: c
   :linenos:

   if (a < b) {
           if (b < c) {
                   printf("b is between a and c\n");
           }
   }

.. index:: l邏輯與, Logical AND, &, Ampersand

我們也可以用邏輯與（Logical AND）運算符來表示“兩個條件同時成立”。邏輯與運算符在C語言中用兩個&（Ampersand）表示，上面的語句可以改寫為：

.. code-block:: c
   :linenos:

   if (a < b && b < c) {
           printf("b is between a and c\n");
   }

對於 ``a < b && b < c`` 這個控製表達式，只有“ ``a < b`` 的值非0”和“ ``b < c`` 的值非0”這兩個條件同時成立，整個表達式的值才為1，否則整個表達式的值為0。換句話說，只有兩個條件都為真，它們做邏輯與運算的結果才為真，只要有一個條件為假，邏輯與運算的結果就為假，如下表所示：

.. table:: AND的真值表

   = = =======
   A B A AND B
   = = =======
   0 0 0
   0 1 0
   1 0 0
   1 1 1
   = = =======

.. index:: z真值表, Truth Table, l邏輯或, Logical OR, |綫, Pipe Sign, l邏輯非, Logical NOT, !號, Exclamation Mark

這種表稱為真值表（Truth Table）。注意邏輯與運算的操作數以非0表示真以0表示假，而運算結果（類型是 ``int``）以1表示真以0表示假，我們忽略這些細微的差別，在表中全部以1表示真以0表示假。C語言還提供了邏輯或（Logical OR）運算符，用兩個|綫（Pipe Sign）表示，還有邏輯非（Logical NOT）運算符，用一個!號（Exclamation Mark）表示，它們的真值表如下：

.. table:: OR的真值表

   = = ======
   A B A OR B
   = = ======
   0 0 0
   0 1 1
   1 0 1
   1 1 1
   = = ======

.. table:: NOT的真值表

   = =====
   A NOT A
   = =====
   0 1
   1 0
   = =====

.. index:: d單目運算符, Unary Operator, s雙目運算符, Binary Operator

邏輯或表示兩個條件只要有一個為真，它們做邏輯或運算的結果就為真，只有兩個條件都為假，邏輯或運算的結果才為假。邏輯非的作用是對原來的邏輯值取反，原來是真的就是假，原來是假的就是真。例如 ``!(x > 1)`` ，如果表達式 ``x > 1`` 的值非零，則 ``!(x > 1)`` 的值為0。邏輯非運算符只有一個操作數，稱為單目運算符（Unary Operator），以前講過的加減乘除、賦值、相等性、關係、邏輯與、邏輯或運算符都有兩個操作數，稱為雙目運算符（Binary Operator）。

.. index:: b布爾代數, Boolean Algebra

關於邏輯運算的數學體系稱為布爾代數（Boolean Algebra），以它的創始人布爾命名。在編程語言中表示真和假的數據類型叫做布爾類型，在C語言中通常用 ``int`` 型來表示，非0表示真，0表示假 [#]_ 。布爾邏輯是寫程序的基本功之一，程序中的很多錯誤都可以歸因于邏輯錯誤。以下是一些布爾代數的基本定理，為了簡潔易讀，真和假用1和0表示，AND用*號表示，OR用+號表示（從真值表可以看出AND和OR運算確實有點像乘法和加法運算），NOT用¬表示，變數x、y、z的值可能是0也可能是1，無論x、y、z怎麼取值，以下等式都成立。

.. [#] C99也定義了專門的布爾類型 ``_Bool`` ，但目前沒有被廣泛使用。

::

   ¬¬x=x

   x*0=0
   x+1=1

   x*1=x
   x+0=x

   x*x=x
   x+x=x

   x*¬x=0
   x+¬x=1

   x*y=y*x
   x+y=y+x

   x*(y*z)=(x*y)*z
   x+(y+z)=(x+y)+z

   x*(y+z)=x*y+x*z
   x+y*z=(x+y)*(x+z)

   x+x*y=x
   x*(x+y)=x

   x*y+x*¬y=x
   (x+y)*(x+¬y)=x

   ¬(x*y)=¬x+¬y
   ¬(x+y)=¬x*¬y

   x+¬x*y=x+y
   x*(¬x+y)=x*y

   x*y+¬x*z+y*z=x*y+¬x*z
   (x+y)*(¬x+z)*(y+z)=(x+y)*(¬x+z)

除了第一個公式之外，這些公式都是每兩個一組的，每組的兩個公式就像對聯一樣：把其中一個公式中的*換成+、+換成*、0換成1、1換成0，就變成了與它對稱的另一個公式。這些定理都可以用真值表來證明，更多細節可參考有關數字邏輯的教材，例如 [數字邏輯基礎]_ 。我們將在本節的練習題中強化訓練對這些定理的理解。

目前為止介紹的這些運算符按優先順序從高到低的順序依次是：

*  !
*  \* / %
*  \+ \-
*  > < >= <=
*  == !=
*  &&
*  ||
*  =

寫一個表達式往往會用到好幾種運算符，如果記不清楚運算符的優先順序一定要多套括號。我們將在 :ref:`op.op` 總結C語言所有運算符的優先順序和結合性。

最後要注意一點，浮點型的精度有限，不適合用 ``==`` 運算符做精確比較。以下代碼可以說明問題：

.. code-block:: c
   :linenos:

   double a = 0.3 - 0.2;
   double b = 0.2 - 0.1;
   if (a == b)
           printf("Equal\n");
   else
           printf("Unequal\n");

程序的執行結果非常意外，居然是Unequal。雖然理論上 ``a`` 和 ``b`` 的值都應該是0.1， 但浮點型無法精確表示0.1這個值，實際上可能會存在一點偏差，由於 ``a`` 和 ``b`` 的值的計算過程不同，存在的偏差也不一樣，最後兩者做精確比較的結果是不相等。等學習了 :ref:`number.float` 你就知道為什麼浮點型的精度有限了。如果你需要判斷兩個符點數是否近似相等，可以這樣比較： ``if (a > b - 0.001 && a < b + 0.001) ...`` 。

.. rubric:: 習題

#. 把代碼段

   .. code-block:: c
      :linenos:

      if (x > 0 && x < 10);
      else
              printf("x is out of range.\n");

   改寫成下面這種形式：

   .. code-block:: c
      :linenos:

      if (____ || ____)
              printf("x is out of range.\n");

   ____應該怎麼填？

#. 把代碼段：

   .. code-block:: c
      :linenos:

      if (x > 0)
              printf("Test OK!\n");
      else if (x <= 0 && y > 0)
              printf("Test OK!\n");
      else
              printf("Test failed!\n");

   改寫成下面這種形式：

   .. code-block:: c
      :linenos:

      if (____ && ____)
              printf("Test failed!\n");
      else
              printf("Test OK!\n");

   ____應該怎麼填？

#. 有這樣一段代碼：

   .. code-block:: c
      :linenos:

      if (x > 1 && y != 1) {
              ...
      } else if (x < 1 && y != 1) {
              ...
      } else {
              ...
      }

   要進入最後一個else，x和y需要滿足條件____ || ____。這裡應該怎麼填？

#. 以下哪一個 ``if`` 判斷條件是多餘的可以去掉？這裡所謂的“多餘”是指：在 ``x`` 和 ``y`` 取值的任何一種可能的情況下，如果本來應該打印 ``Test OK`` ，去掉這個多餘條件後仍然打印 ``Test OK`` ，如果本來應該打印 ``Test failed`` ，去掉這個多餘條件後仍然打印 ``Test failed`` 。

   .. code-block:: c
      :linenos:

      if (x<3 && y>3)
              printf("Test OK\n");
      else if (x>=3 && y>=3)
              printf("Test OK\n");
      else if (z>3 && x>=3)
              printf("Test OK\n");
      else if (z<=3 && y>=3)
              printf("Test OK\n");
      else
              printf("Test failed\n");

#. 以下兩段代碼是否等價？

   .. code-block:: c
      :linenos:

      if (A && B)
              statement1;
      else
              statement2;

   .. code-block:: c
      :linenos:

      if (A) {
              if (B)
                      statement1;
      } else
              statement2;

.. _cond.switch:

switch語句
------------------

``switch`` 語句可以產生具有多個分支的控制流程。它的格式是::

   switch (控製表達式) {
   case 整型常量表達式： 零或多條語句
   case 整型常量表達式： 零或多條語句
   ...
   default： 零或多條語句
   }

例如以下程序根據傳入的參數1~7分別打印Monday~Sunday：

.. _cond.switch1:

.. figure:: ../images/cond.switch1.png

   switch語句

如果傳入的參數是2，則從 ``case 2`` 分支開始執行，先是打印相應的信息，然後遇到 ``break`` 語句，它的作用是跳出整個 ``switch`` 語句塊。C語言規定各 ``case`` 分支的常量表達式必須互不相同，如果控製表達式不等於任何一個常量表達式，則從 ``default`` 分支開始執行，通常的習慣是把 ``default`` 分支寫在最後。

使用 ``switch`` 語句要注意幾點：

.. index:: Fall Through

#. ``case`` 後面跟的表達式必須是常量表達式，它的值和全局變數的初始值一樣必須能在編譯時計算出來。
#. 在上一節講過浮點型不適合做精確比較，所以C語言規定case後面跟的必須是整型常量表達式。
#. 進入 ``case`` 後如果沒有遇到 ``break`` 語句就會一直往下執行（這稱為Fall Through），後面其他 ``case`` 或 ``default`` 分支的語句也會被執行到，直到遇到 ``break`` ，或者執行到整個 ``switch`` 語句塊的末尾。通常每個 ``case`` 後面都要加上 ``break`` 語句，但有時會故意不加 ``break`` ，例如：

.. _cond.switch2:

.. figure:: ../images/cond.switch2.png

   缺break的switch語句

``switch`` 語句不是必不可缺的，顯然可以用一組 ``if ... else if ... else if ... else ...`` 代替，但還是推薦寫程序時多用 ``switch`` ：一方面用 ``switch`` 語句會使代碼更清晰，另一方面，有時候編譯器會對 ``switch`` 語句做整體優化，使它比等價的 ``if/else`` 語句所生成的指令執行效率更高。
