結構體
============

.. _struct.struct:

復合類型與結構體
---------------------

.. index:: j基本類型, Primitive Type, f復合類型, Compound Type

在編程語言中，最基本的、不可再分的數據類型稱為基本類型（Primitive Type），例如整型、浮點型；根據語法規則由基本類型組合而成的類型稱為復合類型（Compound Type），例如字元串是由很多字元組成的。有些場合下要把復合類型當作一個整體來用，而另外一些場合下需要分解組成這個復合類型的各種基本類型，復合類型的這種兩面性為數據抽象（Data Abstraction）奠定了基礎。 [SICP]_ 的1.1節指出，在學習一門編程語言時要特別注意以下三個方面：

.. index:: s數據抽象, Data Abstraction, g過程抽象, Procedure Abstraction

#. 這門語言提供了哪些Primitive，比如基本類型，比如基本運算符、表達式和語句。
#. 這門語言提供了哪些組合規則，比如基本類型如何組成復合類型，比如簡單的表達式和語句如何組成複雜的表達式和語句。
#. 這門語言提供了哪些抽象機制，包括數據抽象和過程抽象（Procedure Abstraction）。

本章以結構體為例講解數據類型的組合和數據抽象。至于過程抽象，我們在 :ref:`cond.ifelse` 已經見過最簡單的形式，就是把一組語句用一個函數名封裝起來，當作一個整體使用，本章將介紹更複雜的過程抽象。

現在我們用C語言表示一個複數。從直角坐標系來看，複數由實部和虛部組成，從極坐標系來看，複數由模和輻角組成，兩種坐標系可以相互轉換，如下圖所示：

.. figure:: ../images/struct.complex.png

   複數

如果用實部和虛部表示一個複數，我們可以定義一種由兩個 ``double`` 型組成的結構體類型來表示覆數的類型：

.. code-block:: c
   :linenos:

   struct complex_struct {
           double x, y;
   };

需要說明幾點：

.. index:: Tag

#. 這一句定義了標識符 ``complex_struct`` （同樣要遵循標識符的命名規則），這種標識符在C語言中稱為Tag。
#. 這一句就像變數聲明一樣，以;號結尾卻不是個語句，事實上它是個類型聲明（或者叫類型定義）。由於語句塊和函數體的}後面不需要寫;號，初學者在寫結構體的類型定義時常犯的一個錯誤是忘了寫}後面的;號，這一點要注意。
#. 在這句定義之後， ``struct complex_struct`` 就像 ``int`` 或 ``double`` 一樣可以當類型名使用了 [#]_ 。唯一的區別是， ``int`` 或 ``double`` 是基本類型，而 ``struct complex_struct`` 是一種結構體類型，是由基本類型組合而成的復合類型。

.. [#] 其實C99已經定義了複數類型 ``_Complex`` 。如果包含C標準庫的標頭檔 :file:`complex.h` ，也可以用 ``complex`` 做類型名。當然，只要不包含標頭檔 :file:`complex.h` 就可以自己定義標識符 ``complex`` ，但為了儘量減少混淆，本章的示例代碼都用 ``complex_struct`` 做標識符而不用 ``complex`` 。

我們也可以在一條聲明中既定義結構體類型又定義這種類型的變數：

.. code-block:: c
   :linenos:

   struct complex_struct {
           double x, y;
   } z1, z2;

在這句定義之後， ``z1`` 和 ``z2`` 就可以當變數名來訪問了，而 ``struct complex_struct`` 也可以當類型名來使用了，接下來可以用 ``struct complex_struct`` 這個類型名再定義兩個複數變數：

.. code-block:: c
   :linenos:

   struct complex_struct z3, z4;

如果要在定義結構體類型的同時定義變數，也可以不寫Tag，例如：

.. code-block:: c
   :linenos:

   struct {
           double x, y;
   } z1, z2;

在這句定義之後，就只能訪問變數 ``z1`` 和 ``z2`` ，而沒法用這個結構體類型再定義其他變數了，因為這個結構體類型沒有名字。

.. index:: c成員, Memeber, .號, Period

我們定義的每個複數變數都有兩個成員（Member） ``x`` 和 ``y`` ，可以用.尾碼運算符來訪問，.號（Period）和成員名是變數名的尾碼，比如表達式 ``z1.x`` 的值是複數變數 ``z1`` 的x坐標。下面是一個完整的例子：

.. code-block:: c
   :linenos:

   #include <stdio.h>

   int main(void)
   {
           struct complex_struct { double x, y; } z;
           double x = 3.0;	
           z.x = x;
           z.y = 4.0;
           if (z.y < 0)
                   printf("z=%f%fi\n", z.x, z.y);
           else
                   printf("z=%f+%fi\n", z.x, z.y);

           return 0;
   }


注意上例中變數 ``x`` 和變數 ``z`` 的成員 ``x`` 的名字並不衝突，因為變數 ``z`` 的成員 ``x`` 只能通過表達式 ``z.x`` 來訪問，編譯器可以從語法上區分哪個 ``x`` 是變數 ``x`` ，哪個 ``x`` 是變數 ``z`` 的成員 ``x`` ，在 :ref:`asmc.storage` 會講到這兩個標識符 ``x`` 屬於不同的命名空間。

結構體類型也可以定義在全局作用域中，例如：

.. code-block:: c
   :linenos:

   struct complex_struct { double x, y; };

   int main(void)
   {
           struct complex_struct z;
           ...
   }

結構體變數也可以在定義時初始化，例如：

.. code-block:: c
   :linenos:

   struct complex_struct z = { 3.0, 4.0 };

Initializer中的數據依次賦給結構體的各成員。如果Initializer中的數據比結構體的成員多，編譯器會報錯，但如果只是末尾多個逗號則不算錯。如果Initializer中的數據比結構體的成員少，未指定的成員將用0來初始化（就像未初始化的全局變數一樣）。以下幾種形式的初始化都是合法的：

.. code-block:: c
   :linenos:

   double x = 3.0;
   struct complex_struct z1 = { x, 4.0, }; /* z1.x=3.0, z1.y=4.0 */
   struct complex_struct z2 = { 3.0, }; /* z2.x=3.0, z2.y=0.0 */
   struct complex_struct z3 = { 0 }; /* z3.x=0.0, z3.y=0.0 */

注意， ``z1`` 必須是局部變數才能用另一個變數 ``x`` 的值來初始化它的成員，如果是全局變數就只能用常量表達式來初始化。這也是C99的新特性，C89隻允許在{}中使用常量表達式來初始化，無論是初始化全局變數還是局部變數。

注意結構體的Initializer不能用於結構體的賦值，例如這樣是錯誤的：

.. code-block:: c
   :linenos:

   struct complex_struct z1;
   z1 = { 3.0, 4.0 };

以前我們初始化基本類型的變數所使用的Initializer都是表達式，表達式當然也可以用來賦值，但現在這種由{}括起來的Initializer並不是表達式，所以不能用來賦值 [#]_ 。Initializer的語法總結如下::

   Initializer → 表達式
   Initializer → { 初始化列表 } 
   初始化列表 → Designated-Initializer, Designated-Initializer, ...
   （最後一個Designated-Initializer末尾可以有一個多餘的,號）
   Designated-Initializer → Initializer
   Designated-Initializer → .標識符 = Initializer
   Designated-Initializer → [常量表達式] = Initializer

.. index:: Compound Literal

.. [#] C99引入一種新的表達式語法Compound Literal可以用來賦值，例如 ``z1 = (struct complex_struct){ 3.0, 4.0 };`` ，本書不使用這種新語法。

.. index:: Designated Initializer, x稀疏, Sparse, Memberwise Initialization

Designated Initializer是C99引入的新特性，用於初始化稀疏（Sparse）結構體和稀疏數組很方便。有些時候結構體或數組中只有某一個或某幾個成員需要初始化，其他成員都用0初始化即可，用Designated Initializer語法可以針對每個成員做初始化（Memberwise Initialization），很方便。例如：

.. code-block:: c
   :linenos:

   struct complex_struct z1 = { .y = 4.0 }; /* z1.x=0.0, z1.y=4.0 */

數組的Memberwise Initialization語法將在下一章介紹。

.. index:: s算術類型, Arithmetic Type, b標量類型, Scalar Type

結構體類型用在表達式中有很多限制，不像基本類型那麼自由，比如+ - * /等算術運算符和&& || !等邏輯運算符的操作數都不能是結構體類型， ``if`` 語句、 ``while`` 語句中的控製表達式的值也不能是結構體類型。嚴格來說，可以做算術運算的類型稱為算術類型（Arithmetic Type），算術類型包括整型和浮點型。可以表示零和非零、可以參與邏輯與、或、非運算或者做控製表達式的類型稱為標量類型（Scalar Type），標量類型包括算術類型和以後要講的指針類型，詳見 :ref:`pointer.type` 。

結構體變數之間使用賦值運算符是允許的，用一個結構體變數初始化另一個結構體變數也是允許的，例如：

.. code-block:: c
   :linenos:

   struct complex_struct z1 = { 3.0, 4.0 };
   struct complex_struct z2 = z1;
   z1 = z2;

注意 ``z2`` 必須是局部變數才能用變數 ``z1`` 來初始化。既然結構體變數之間可以相互賦值和初始化，也就可以當作函數的參數和返回值來傳遞：

.. code-block:: c
   :linenos:

   struct complex_struct add_complex(struct complex_struct z1, struct complex_struct z2)
   {
           z1.x = z1.x + z2.x;
           z1.y = z1.y + z2.y;
           return z1;
   }

這個函數實現了兩個複數相加，如果在main函數中這樣調用：

.. code-block:: c
   :linenos:

   struct complex_struct z = { 3.0, 4.0 };
   z = add_complex(z, z);

那麼調用傳參的過程如下圖所示：

.. figure:: ../images/struct.parameter.png

   結構體傳參

從上圖可以看出，一個結構體變數的各成員的存儲空間總是相鄰的 [#]_ ，合在一起組成結構體變數的存儲空間。變數 ``z`` 在 ``main`` 函數的棧幀上，參數 ``z1`` 和 ``z2`` 在 ``add_complex`` 函數的棧幀上， ``z`` 的值分別賦給 ``z1`` 和 ``z2`` 。在 ``add_complex`` 函數裡， ``z2`` 的實部和虛部被累加到 ``z1`` 中，然後 ``return z1;`` 可以看成是：

#. 用 ``z1`` 初始化一個臨時變數。
#. 函數返回並釋放棧幀。
#. 把臨時變數的值賦給變數 ``z`` ，釋放臨時變數。

.. [#] 我們在 :ref:`asmc.structunion` 會看到，結構體成員之間也可能有若干個填充位元組。

由.尾碼運算符組成的表達式能不能做左值取決於.尾碼運算符左邊的操作數能不能做左值。在上面的例子中， ``z`` 是一個變數，可以做左值，因此表達式 ``z.x`` 也可以做左值，但表達式 ``add_complex(z, z).x`` 只能做右值而不能做左值，因為 ``add_complex(z, z)`` 的返回值是個臨時變數，不能做左值。

.. _struct.dataabstraction:

數據抽象
--------------------

現在我們來實現一個完整的複數運算程序。在上一節我們已經定義了複數的結構體類型，現在需要圍繞它定義一些函數。複數可以用直角坐標或極坐標表示，直角坐標做加減法比較方便，極坐標做乘除法比較方便。如果我們定義的複數結構體是直角坐標的，那麼應該提供極坐標的轉換函數，以便在需要的時候可以方便地取它的模和輻角：

.. code-block:: c
   :linenos:

   #include <math.h>

   struct complex_struct {
           double x, y;
   };

   double real_part(struct complex_struct z)
   {
           return z.x;
   }

   double img_part(struct complex_struct z)
   {
           return z.y;
   }

   double magnitude(struct complex_struct z)
   {
           return sqrt(z.x * z.x + z.y * z.y);
   }

   double angle(struct complex_struct z)
   {
           return atan2(z.y, z.x);
   }

此外，我們還提供兩個函數用來構造複數變數，參數既可以是直角坐標也可以是極坐標，在函數中自動做相應的轉換然後返回構造的複數變數：

.. code-block:: c
   :linenos:

   struct complex_struct make_from_real_img(double x, double y)
   {
           struct complex_struct z;
           z.x = x;
           z.y = y;
           return z;
   }

   struct complex_struct make_from_mag_ang(double r, double A)
   {
           struct complex_struct z;
           z.x = r * cos(A);
           z.y = r * sin(A);
           return z;
   }

在此基礎上就可以實現複數的加減乘除運算了：

.. code-block:: c
   :linenos:

   struct complex_struct add_complex(struct complex_struct z1, struct complex_struct z2)
   {
           return make_from_real_img(real_part(z1) + real_part(z2),
                                     img_part(z1) + img_part(z2));
   }

   struct complex_struct sub_complex(struct complex_struct z1, struct complex_struct z2)
   {
           return make_from_real_img(real_part(z1) - real_part(z2),
                                     img_part(z1) - img_part(z2));
   }

   struct complex_struct mul_complex(struct complex_struct z1, struct complex_struct z2)
   {
           return make_from_mag_ang(magnitude(z1) * magnitude(z2),
                                    angle(z1) + angle(z2));
   }

   struct complex_struct div_complex(struct complex_struct z1, struct complex_struct z2)
   {
           return make_from_mag_ang(magnitude(z1) / magnitude(z2),
                                    angle(z1) - angle(z2));
   }

可以看出，複數加減乘除運算的實現並沒有直接訪問結構體 ``struct complex_struct`` 的成員 ``x`` 和 ``y`` ，而是把它看成一個整體，通過調用相關函數來取它的直角坐標和極坐標。這樣就可以非常方便地替換掉結構體 ``struct complex_struct`` 的存儲表示，例如改為用極坐標來存儲：

.. code-block:: c
   :linenos:

   #include <math.h>

   struct complex_struct {
           double r, A;
   };

   double real_part(struct complex_struct z)
   {
           return z.r * cos(z.A);
   }

   double img_part(struct complex_struct z)
   {
           return z.r * sin(z.A);
   }

   double magnitude(struct complex_struct z)
   {
           return z.r;
   }

   double angle(struct complex_struct z)
   {
           return z.A;
   }

   struct complex_struct make_from_real_img(double x, double y)
   {
           struct complex_struct z;
           z.A = atan2(y, x);
           z.r = sqrt(x * x + y * y);
           return z;
   }

   struct complex_struct make_from_mag_ang(double r, double A)
   {
           struct complex_struct z;
           z.r = r;
           z.A = A;
           return z;
   }

雖然結構體 ``complex_struct`` 的存儲表示做了這樣的改動， ``add_complex`` 、 ``sub_complex`` 、 ``mul_complex`` 、 ``div_complex`` 這幾個複數運算的函數卻不需要做任何改動，仍然可以用，原因在於這幾個函數只把結構體 ``complex_struct`` 當作一個整體來使用，而沒有直接訪問它的成員，因此也不依賴于它有哪些成員。我們結合下圖具體分析一下。

.. figure:: ../images/struct.abstraction.png

   數據抽象

這是一種抽象的思想。其實“抽象”這個概念並沒有那麼抽象，簡單地說就是“提取公因式”：ab+ac=a(b+c)。如果a變了，ab和ac這兩項都需要改，但如果寫成a(b+c)的形式，只需要改一個地方就夠了。

在我們的複數運算程序中，複數有可能用直角坐標或極坐標來表示，我們把這個有可能變動的因素提取出來組成複數存儲表示層： ``real_part`` 、 ``img_part`` 、 ``magnitude`` 、 ``angle`` 、 ``make_from_real_img`` 、 ``make_from_mag_ang`` 。這一層看到的數據是結構體的兩個成員 ``x`` 和 ``y`` ，或者 ``r`` 和 ``A`` ，如果改變了結構體的實現就要改變這一層函數的實現，但函數介面不改變，因此調用這一層函數介面的複數運算層不需要改變。複數運算層看到的數據只是一個抽象的“複數”的概念，知道它有直角坐標和極坐標，可以調用複數存儲表示層的函數得到這些坐標。再往上看，其他使用複數運算的程序看到的數據是一個更為抽象的“複數”的概念，只知道它是一個數，像整數、小數一樣可以加減乘除，甚至連它有直角坐標和極坐標也不需要知道。

.. index:: c抽象層, Abstraction Layer

這裡的複數存儲表示層和複數運算層稱為抽象層（Abstraction Layer），從底層往上層來看，複數越來越抽象了，把所有這些層組合在一起就是一個完整的系統。 **組合使得系統可以任意複雜，而抽象使得系統的複雜性是可以控制的，任何改動都只侷限在某一層，而不會波及整個系統。** 著名的計算機科學家Butler Lampson說過：“All problems in computer science can be solved by another level of indirection.”這裡的indirection其實就是abstraction的意思。

.. rubric:: 習題

#. 在本節的基礎上實現一個打印複數的函數，打印的格式是x+yi，如果實部或虛部為0則省略，例如： ``1.0`` 、 ``-2.0i`` 、 ``-1.0+2.0i`` 、 ``1.0-2.0i`` 。最後編寫一個 ``main`` 函數測試本節的所有代碼。想一想這個打印函數應該屬於上圖中的哪一層？

#. 實現一個用分子分母的格式來表示有理數的結構體類型 ``struct rational`` 以及相關的函數， ``struct rational`` 結構體類型之間可以做加減乘除運算，運算的結果仍然是 ``struct rational`` 類型。測試代碼如下：

   .. code-block:: c
      :linenos:

      int main(void)
      {
              struct rational a = make_rational(1, 8); /* a=1/8 */
              struct rational b = make_rational(-1, 8); /* b=-1/8 */
              print_rational(add_rational(a, b));
              print_rational(sub_rational(a, b));
              print_rational(mul_rational(a, b));
              print_rational(div_rational(a, b));

              return 0;
      }

   注意要約分為最簡分數，例如1/8和-1/8相減的打印結果應該是1/4而不是2/8，可以利用 :ref:`func2.recurse` 練習題中的Euclid算法來約分。在動手編程之前先思考一下這個問題實現了什麼樣的數據抽象，抽象層應該由哪些函數組成。

.. _struct.typetag:

數據類型標誌
---------------

.. index:: s適配, Adapt

在上一節中，我們通過一個複數存儲表示抽象層把 ``struct complex_struct`` 結構體的存儲格式和上層的複數運算函數隔離開， ``struct complex_struct`` 結構體既可以採用直角坐標也可以採用極坐標存儲。但有時候需要同時支持兩種存儲格式，比如先前已經採集了一些數據存在計算機中，有些數據是以極坐標存儲的，有些數據是以直角坐標存儲的，如果要把這些數據都存到 ``struct complex_struct`` 結構體中怎麼辦？一種辦法是規定 `` struct complex_struct`` 結構體採用直角坐標格式，直角坐標的數據可以直接存入 `` struct complex_struct`` 結構體，而極坐標的數據先轉成直角坐標再存，但由於浮點數的精度有限，轉換總是會損失精度的。這裡介紹另一種辦法， ``struct complex_struct`` 結構體由一個數據類型標誌和兩個浮點數組成，如果數據類型標誌為0，那麼兩個浮點數就表示直角坐標，如果數據類型標誌為1，那麼兩個浮點數就表示極坐標。這樣，直角坐標和極坐標的數據都可以適配（Adapt）到 ``struct complex_struct`` 結構體中，無需轉換和損失精度：

.. code-block:: c
   :linenos:

   enum coordinate_type { RECTANGULAR, POLAR };
   struct complex_struct {
           enum coordinate_type t;
           double a, b;
   };

.. index:: m枚舉, Enumeration

``enum`` 關鍵字的作用和 ``struct`` 關鍵字類似，把 ``coordinate_type`` 這個標識符定義為一個Tag， ``struct complex_struct`` 表示一個結構體類型，而 ``enum coordinate_type`` 表示一個枚舉（Enumeration）類型。枚舉類型的成員是常量，它們的值由編譯器自動分配，例如定義了上面的枚舉類型之後， ``RECTANGULAR`` 就表示常量0， ``POLAR`` 表示常量1。如果不希望從0開始分配，可以這樣定義：

.. code-block:: c
   :linenos:

   enum coordinate_type { RECTANGULAR = 1, POLAR };

這樣， ``RECTANGULAR`` 就表示常量1，而 ``POLAR`` 表示常量2。枚舉常量也是一種整型，其值在編譯時確定，因此也可以出現在常量表達式中，可以用於初始化全局變數或者作為case分支的判斷條件。

有一點需要注意，雖然結構體的成員名和變數名不在同一命名空間中，但枚舉的成員名卻和變數名在同一命名空間中，所以會出現命名衝突。例如這樣是不合法的：

.. code-block:: c
   :linenos:

   int main(void)
   {
           enum coordinate_type { RECTANGULAR = 1, POLAR };
           int RECTANGULAR;
           printf("%d %d\n", RECTANGULAR, POLAR);
           return 0;
   }

``struct complex_struct`` 結構體的格式變了，就需要修改複數存儲表示層的函數，但只要保持函數介面不變就不會影響到上層函數。例如：

.. code-block:: c
   :linenos:

   struct complex_struct make_from_real_img(double x, double y)
   {
           struct complex_struct z;
           z.t = RECTANGULAR;
           z.a = x;
           z.b = y;
           return z;
   }

   struct complex_struct make_from_mag_ang(double r, double A)
   {
           struct complex_struct z;
           z.t = POLAR;
           z.a = r;
           z.b = A;
           return z;
   }

習題

#. 本節只給出了 ``make_from_real_img`` 和 ``make_from_mag_ang`` 函數的實現，請讀者自己實現 ``real_part`` 、 ``img_part`` 、 ``magnitude`` 、 ``angle`` 這些函數。

#. 編譯運行下面這段程序：

   .. code-block:: c
      :linenos:

      #include <stdio.h>

      enum coordinate_type { RECTANGULAR = 1, POLAR };

      int main(void)
      {
              int RECTANGULAR;
              printf("%d %d\n", RECTANGULAR, POLAR);
              return 0;
      }

結果是什麼？並解釋一下為什麼是這樣的結果。

嵌套結構體
------------------

結構體也是一種遞歸定義：結構體的成員具有某種數據類型，而結構體本身也是一種數據類型。換句話說，結構體的成員可以是另一個結構體，即結構體可以嵌套定義。例如我們在複數的基礎上定義復平面上的線段：

.. code-block:: c
   :linenos:

   struct segment {
           struct complex_struct start;
           struct complex_struct end;
   };

從 :ref:`struct.struct` 講的Initializer的語法可以看出，Initializer也可以嵌套，因此嵌套結構體可以嵌套地初始化，例如：

.. code-block:: c
   :linenos:

   struct segment s = {{ 1.0, 2.0 }, { 4.0, 6.0 }};

.. index:: p平坦, Flat

也可以平坦（Flat）地初始化。例如：

.. code-block:: c
   :linenos:

   struct segment s = { 1.0, 2.0, 4.0, 6.0 };

甚至可以把兩種方式混合使用（這樣可讀性很差，應該避免）：

.. code-block:: c
   :linenos:

   struct segment s = {{ 1.0, 2.0 }, 4.0, 6.0 };

利用C99的新特性也可以做Memberwise Initialization，例如 [#]_ ：

.. [#] 為了便於理解， :ref:`struct.struct` 講的Initializer語法並沒有描述這種複雜的用法。

.. code-block:: c
   :linenos:

   struct segment s = { .start.x = 1.0, .end.x = 2.0 };

訪問嵌套結構體的成員要用到多個.尾碼運算符，例如：

.. code-block:: c
   :linenos:

   s.start.t = RECTANGULAR;
   s.start.a = 1.0;
   s.start.b = 2.0;
