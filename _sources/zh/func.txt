函數入門
===========

.. _func.mathfunc:

數學函數
-----------

在數學中我們用過sin和ln這樣的函數，例如sin(π/2)=1，ln1=0等等，在C語言中也可以使用這些函數（數學函數sin在C標準庫中就是 ``sin`` 函數，而數學函數ln在C標準庫中對應的是 ``log`` 函數）：

.. code-block:: c
   :linenos:

   #include <math.h>
   #include <stdio.h>

   int main(void)
   {
           double pi = 3.1416;
           printf("sin(pi/2)=%f\nln1=%f\n", sin(pi/2), log(1.0));
           return 0;
   }


編譯運行這個程序，結果如下::

   $ gcc main.c -lm
   $ ./a.out
   sin(pi/2)=1.000000
   ln1=0.000000

.. index:: h函數, Function, h函數調用, Function Call, h尾碼運算符, Postfix Operator, h函數名, Function Designator, h函數類型, Function Type, f返回值, Return Value

在數學中寫一個函數有時候可以省略括號，而C語言要求一定要加上括號，例如 ``log(1.0)`` 。在C語言的術語中， ``1.0`` 是參數， ``log`` 是函數（Function）， ``log(1.0)`` 是函數調用（Function Call）。 ``sin(pi/2)`` 和 ``log(1.0)`` 這兩個函數調用在我們的 ``printf`` 語句中處于什麼位置呢？在上一章講過，這應該是寫表達式的位置，因此函數調用也是一種表達式。 ``log(1.0)`` 這個表達式由操作數 ``log`` 、函數調用運算符()括號及其中的參數組成，函數調用運算符是一種尾碼運算符（Postfix Operator），()括號及其中的參數是操作數 ``log`` 的尾碼。操作數 ``log`` 是一個函數名（Function Designator），這個操作數的類型是一種函數類型（Function Type）。對1.0取自然對數運算的結果就是 ``log(1.0)`` 這個表達式的值，類型是 ``double`` 型，在C語言中函數調用表達式的值稱為函數的返回值（Return Value）。

總結一下我們新學的語法規則::

   表達式 → 函數名
   表達式 → 表達式(參數列表)
   參數列表 → 表達式, 表達式, ...

現在我們可以完全理解 ``printf`` 語句了：原來 ``printf`` 也是一個函數，上例中的 ``printf("sin(pi/2)=%f\nln1=%f\n", sin(pi/2), log(1.0))`` 是帶三個參數的函數調用，而函數調用也是一種表達式，因此 ``printf`` 語句也是表達式語句的一種。

.. index:: f副作用, Side Effect

但是 ``printf`` 感覺不像一個數學函數，為什麼呢？因為像 ``log`` 這種函數，我們傳進去一個參數會得到一個返回值，我們調用 ``log`` 函數就是為了得到它的返回值，至于 ``printf`` ，通常我們並不關心它的返回值（事實上它也有返回值，表示實際打印的字元數），我們調用 ``printf`` 不是為了得到它的返回值，而是為了利用它所產生的副作用（Side Effect）－－打印。 **C語言的函數可以有Side Effect，這一點是它和數學函數在概念上的根本區別。**

Side Effect這個概念也適用於運算符組成的表達式。比如 ``a + b`` 這個表達式也可以看成一個函數調用，把運算符+看作函數，它的兩個參數是 ``a`` 和 ``b`` ，返回值是兩個參數的和：傳入兩個參數，得到一個返回值，並沒有產生任何Side Effect。再比如把 ``a = b`` 這個表達式看成函數調用，把賦值運算符看作函數，它的兩個參數還是 ``a`` 和 ``b`` ，返回值就是所賦的值，既是 ``b`` 的值也是 ``a`` 被賦予的值，但除了計算出一個返回值之外還產生了Side Effect－－變數 ``a`` 被改變了，改變計算機存儲單元裡的數據或者做輸入輸出操作都算Side Effect。

.. index:: f泛化, Generalize

回想一下我們的學習過程：一開始我們說賦值是一種語句，後來學了表達式，我們說賦值語句是表達式語句的一種；一開始我們說 ``printf`` 是一種語句，現在學了函數，我們又說 ``printf`` 也是表達式語句的一種。隨着我們一步步的學習，把原來看似不同類型的語句統一成一種語句了。學習的過程總是這樣，初學者一開始接觸的很多概念從嚴格意義上說是錯的，但是很容易理解，隨着一步步學習，在理解原有概念的基礎上不斷糾正，不斷泛化（Generalize）。就像一年級老師說小數不能減大數，其實這個概念是錯的，後來引入了負數就可以減了，再後來引入了分數，原來的正數和負數的概念就泛化為整數，上初中學了無理數，原來的整數和分數的概念就泛化為有理數，再上高中學了複數，有理數和無理數的概念就泛化為實數。坦白說，到目前為止本書的很多說法都是不完全正確的，但這是學習理解的必經階段，到後面的章節都會逐步糾正的。

.. index:: #號, Pound Sign, Number Sign, Hash Sigh, t標頭檔, Header File, <>括號, Angle Bracket, y預處理指示, Preprocessing Directive

現在可以解釋一下為什麼每個程序開頭要寫#號（Pound Sign，Number Sign或Hash Sign）和 ``include`` 了，這是一種預處理指示（Preprocessing Directive），表示包含一個標頭檔（Header File），後面<>括號（Angle Bracket）中就是檔案名（這些標頭檔通常位於 :file:`/usr/include` 目錄下）。標頭檔中聲明了我們程序中使用的庫函數，根據先聲明後使用的原則，要使用 ``printf`` 函數必須先包含 ``stdio.h`` ，要使用數學函數必須先包含 ``math.h`` ，如果什麼庫函數都不使用就不必包含任何標頭檔，例如寫一個程序 ``int main(void){int a;a=2;return 0;}`` ，不需要包含標頭檔就可以編譯通過，當然這個程序什麼也做不了。

使用 ``math.h`` 中聲明的庫函數還有一點特殊之處， :command:`gcc` 命令行必須加 :option:`-lm` 選項，因為數學函數位於 :file:`libm.so` 庫檔案中（這些庫檔案通常位於 :file:`/lib` 目錄下）， :option:`-lm` 選項告訴編譯器我們程序中用到的數學函數要到 :file:`libm.so` 這個庫檔案裡找。注意庫檔案名是 ``libm`` ，但使用 :option:`-l` 選項指定庫檔案時省略 ``lib`` ，只寫成 :option:`-lm` 。本書用到的大部分庫函數（例如 ``printf`` ）位於 :file:`libc.so` 庫檔案中，使用 :file:`libc.so` 中的庫函數在編譯時不需要加 :option:`-lc` 選項，因為這個選項是 :command:`gcc` 的預設選項（當然加了也不算錯）。關於標頭檔和庫函數目前理解這麼多就可以了，到 :doc:`link` 再詳細解釋。

.. note:: C標準庫和glibc

   C標準主要由兩部分組成，一部分描述C的語法，另一部分描述C標準庫。C標準庫定義了一組標準標頭檔，每個標頭檔中包含一些相關的函數、變數、類型聲明和宏定義。要在一個平台上支持C語言，不僅要實現C編譯器，還要實現C標準庫，這樣的實現才算符合C標準。不符合C標準的實現也是存在的，例如很多單片機的C語言開發工具中只有C編譯器而沒有完整的C標準庫。

   在Linux平台上最廣泛使用的C函式館是glibc，其中包括C標準庫的實現，也包括很多Linux系統函數，几乎所有C程序都要調用glibc的庫函數，所以glibc是Linux平台C程序運行的基礎。glibc提供一組標頭檔和一組庫檔案，最基本、最常用的C標準庫函數和系統函數在 :file:`libc.so` 庫檔案中，几乎所有C程序的運行都依賴于 :file:`libc.so` ，有些做數學計算的C程序除了依賴 :file:`libc.so` 之外還依賴 :file:`libm.so` ，還有很多C程序依賴glibc的其他庫檔案。以後我說libc時專指 :file:`libc.so` 這個庫檔案，而說glibc時指的是glibc提供的所有庫檔案。

   glibc並不是Linux平台基礎C函式館的唯一一種實現，比如有人開發了uClibc，實現了glibc的大部分函數介面，但實現方式很不同，更適合于需要節省存儲空間的嵌入式系統。

.. _func.deffunction:

定義自己的函數
---------------

我們不僅可以調用C標準庫提供的函數，也可以定義自己的函數，事實上我們已經這麼做了：我們定義了 ``main`` 函數。例如：

.. code-block:: c
   :linenos:

   int main(void)
   {
           int hour = 11;
           int minute = 59;
           printf("%d and %d hours\n", hour, minute / 60);
           return 0;
   }

``main`` 函數的特殊之處在於執行程序時它自動被操作系統調用，操作系統就認準了 ``main`` 這個名字，除了名字特殊之外， ``main`` 函數和別的函數沒有區別。我們對照着 ``main`` 函數的定義來看語法規則::

   函數定義 → 返回值類型 函數名(參數列表) 函數體
   函數體 → { 語句列表 }
   語句列表 → 語句列表項 語句列表項 ...
   語句列表項 → 語句
   語句列表項 → 變數聲明、類型聲明或非定義的函數聲明
   非定義的函數聲明 → 返回值類型 函數名(參數列表);

關於“函數定義”和“非定義的函數聲明”之間的區別可以回頭看看 :ref:`聲明和定義 <expr.declaration>` 。給函數命名也要遵循 :ref:`expr.variable` 講過的標識符命名規則。

.. index:: t退出狀態, Exit Status

由於我們定義的 ``main`` 函數不帶任何參數，參數列表應寫成 ``void`` 。函數體可以由若干條語句和聲明組成，C89要求所有聲明寫在所有語句之前（本書的示例代碼都遵循這一規定），而C99的新特性允許語句和聲明按任意順序排列，只要每個標識符都遵循先聲明後使用的原則就行。 ``main`` 函數的返回值是 ``int`` 型的， ``return 0;`` 這個語句表示返回值是0， ``main`` 函數的返回值是返回給操作系統看的，因為 ``main`` 函數是被操作系統調用的，通常程序執行成功就返回0，在執行過程中出錯就返回一個非零值。比如我們將 ``main`` 函數中的 ``return`` 語句改為 ``return 4;`` 再執行它，執行結束後可以在Shell中看到它的退出狀態（Exit Status）::

   $ ./a.out
   11 and 0 hours
   $ echo $?
   4

``$?`` 是Shell中的一個特殊變數，表示上一條命令的退出狀態。

關於 ``main`` 函數需要注意兩點：

#. [K&R]_ 書上的 ``main`` 函數定義寫成 ``main(){...}`` 的形式，不寫返回值類型也不寫參數列表，這是Old Style C的風格。Old Style C規定不寫返回值類型就表示返回 ``int`` 型，不寫參數列表就表示參數類型和個數沒有明確指出。這種寬鬆的規定使編譯器無法檢查程序中可能存在的Bug，增加了調試難度，不幸的是現在的C標準為了兼容舊的代碼仍然保留了這種語法，但讀者絶不應該繼續使用這種語法。
#. 其實操作系統在調用 ``main`` 函數時是傳參數的， ``main`` 函數最標準的形式應該是 ``int main(int argc, char *argv[])`` ，在 :ref:`pointer.pointertopointer` 詳細介紹。C標準也允許 ``int main(void)`` 這種寫法，如果不使用系統傳進來的兩個參數也可以寫成這種形式。但除了這兩種形式之外，定義 ``main`` 函數的其他寫法都是錯誤的或不可移植的。

關於返回值和 ``return`` 語句我們將在 :ref:`func2.return` 詳細討論，我們先從既不帶參數也沒有返回值的函數開始學習定義和使用函數：

.. code-block:: c
   :linenos:

   #include <stdio.h>

   void newline(void)
   {
           printf("\n");
   }

   int main(void)
   {
           printf("First Line.\n");
           newline();
           printf("Second Line.\n");
           return 0;
   }

執行結果是::

   First Line.

   Second Line.

我們定義了一個 ``newline`` 函數給 ``main`` 函數調用，它的作用是打印一個換行，所以執行結果中間多了一個空行。 ``newline`` 函數不僅不帶參數，也沒有返回值（返回值類型為 ``void`` 表示沒有返回值 [#]_ ），這說明我們調用這個函數完全是為了利用它的Side Effect。如果我們想要多次插入空行就可以多次調用 ``newline`` 函數：

.. index:: g過程, Procedure

.. [#] 敏鋭的讀者可能會發現一個矛盾：如果函數 ``newline`` 沒有返回值，那麼表達式 ``newline()`` 不就沒有值了嗎？然而上一章講過任何表達式都有值和類型兩個基本屬性。其實這正是設計 ``void`` 這麼一個關鍵字的原因：首先從語法上規定沒有返回值的函數調用表達式是 ``void`` 類型的，有一個 ``void`` 類型的值，這樣任何表達式都有值，不必考慮特殊情況，編譯器的語法解析比較容易實現；然後從語義上規定 ``void`` 類型的表達式不能參與運算，因此 ``newline() + 1`` 這樣的表達式不能通過語義檢查，從而兼顧了語法上的一致和語義上的不矛盾。在C語言中這個問題通過語義檢查來解決，而在別的編程語言中又有不同的解決辦法，比如Pascal語言從語法上區分有返回值和沒有返回值的函數，有返回值的稱為函數，沒有返回值的稱為過程（Procedure），在本書中函數和過程表示相同的含義。

.. code-block:: c
   :linenos:

   int main(void)
   {
           printf("First Line.\n");
           newline();
           newline();
           newline();
           printf("Second Line.\n");
           return 0;
   }

如果我們總需要三個三個地插入空行，我們可以再定義一個 ``threelines`` 函數每次插入三個空行：

.. code-block:: c
   :linenos:

   #include <stdio.h>

   void newline(void)
   {
           printf("\n");
   }

   void threelines(void)
   {
           newline();
           newline();
           newline();
   }

   int main(void)
   {
           printf("Three lines:\n");
           threelines();
           printf("Another three lines.\n");
           threelines();
           return 0;
   }


通過這個簡單的例子可以體會到：

#. 同一個函數可以被多次調用。
#. 可以用一個函數調用另一個函數，後者再去調第三個函數。
#. 通過自定義函數可以給一組複雜的操作起一個簡單的名字，例如 ``threelines`` 。對於 ``main`` 函數來說，只需要通過 ``threelines`` 這個簡單的名字來調用就行了，不必知道打印三個空行具體怎麼做，所有的複雜操作都被隱藏在 ``threelines`` 這個名字後面。
#. 使用自定義函數可以使代碼更簡潔， ``main`` 函數在任何地方想打印三個空行只需調用一個簡單的 ``threelines()`` ，而不必每次都寫三個 ``printf("\n")`` 。

讀代碼和讀文章不一樣，按從上到下從左到右的順序讀代碼未必是最好的。比如上面的例子，按源檔案的順序應該是先看 ``newline`` 再看 ``threelines`` 再看 ``main`` 。如果你換一個角度，按代碼的執行順序來讀也許會更好：首先執行的是 ``main`` 函數中的語句，在一條 ``printf`` 之後調用了 ``threelines`` ，這時再去看 ``threelines`` 的定義，其中又調用了 ``newline`` ，這時再去看 ``newline`` 的定義， ``newline`` 裡面有一條 ``printf`` ，執行完成後返回 ``threelines`` ，這裡還剩下兩次 ``newline`` 調用，效果也都一樣，執行完之後返回 ``main`` ，接下來又是一條 ``printf`` 和一條 ``threelines`` 。如下圖所示：

.. figure:: ../images/func.funccall.png

   函數調用的執行順序

讀代碼的過程就是模仿計算機執行程序的過程，我們不僅要記住當前讀到了哪一行代碼，還要記住現在讀的代碼是被哪個函數調用的，這段代碼返回後應該從上一個函數的什麼地方接着往下讀。

.. index:: h函數原型, Prototype

現在澄清一下函數聲明、函數定義、函數原型（Prototype）這幾個概念。比如 ``void threelines(void)`` 這一行，其中包含了函數的名字、參數類型和個數、返回值類型，這三要素齊全就可以叫做函數原型。在代碼中可以單獨寫一個函數原型，後面加;號結束，而不寫函數體，例如：

.. code-block:: c
   :linenos:

   void threelines(void);

我們知道，這種寫法只能叫函數聲明而不能叫函數定義，只有帶函數體的聲明才叫定義。那麼這種函數聲明有什麼用呢？它為編譯器提供了有用的信息，編譯器見到函數原型（不管帶不帶函數體）就明確了這個函數的名字、參數類型和個數、返回值類型，之後編譯器碰到函數調用代碼就知道該生成什麼樣的指令來實現函數調用了，所以函數原型必須出現在函數調用之前，這也是遵循“先聲明後使用”的原則。

在上面的例子中， ``main`` 調用 ``threelines`` ， ``threelines`` 再調用 ``newline`` ，要保證每個函數的原型出現在調用之前，就只能按先 ``newline`` 再 ``threelines`` 再 ``main`` 的順序定義了。如果使用不帶函數體的聲明，則可以這樣寫：

.. code-block:: c
   :linenos:

   #include <stdio.h>

   void newline(void);
   void threelines(void);

   int main(void)
   {
           ...
           threelines();
           ...
   }

   void threelines(void)
   {
           ...
           newline();
           ...
   }

   void newline(void)
   {
           ...
   }

由於 ``newline`` 和 ``threelines`` 的原型都在程序開頭聲明了，它們的定義按什麼順序寫都無所謂了，都不會違背“先聲明後使用”的原則。

由於有Old Style C語法的存在，並非所有函數聲明都包含完整的函數原型，例如 ``void threelines();`` 這個聲明並沒有明確指出參數類型和個數，所以不算函數原型，這個聲明提供給編譯器的信息只有函數名和返回值類型。如果在這樣的聲明之後調用函數，編譯器不知道參數的類型和個數，就不會做語法檢查，所以很容易引入Bug。讀者需要瞭解這個知識點以便維護別人用Old Style C風格寫的代碼，但絶不應該按這種風格寫新的代碼。

如果在調用函數之前沒有聲明會怎麼樣呢？有的讀者也許碰到過這種情況，我可以解釋一下，但絶不推薦這種寫法。比如按上面的順序定義這三個函數，但是把開頭的兩行聲明去掉：

.. code-block:: c
   :linenos:

   #include <stdio.h>

   int main(void)
   {
           printf("Three lines:\n");
           threelines();
           printf("Another three lines.\n");
           threelines();
           return 0;
   }

   void threelines(void)
   {
           newline();
           newline();
           newline();
   }

   void newline(void)
   {
           printf("\n");
   }

編譯時會報警告::

   $ gcc main.c
   main.c:12:6: warning: conflicting types for ‘threelines’ [enabled by default]
   main.c:6:9: note: previous implicit declaration of ‘threelines’ was here
   main.c:19:6: warning: conflicting types for ‘newline’ [enabled by default]
   main.c:14:9: note: previous implicit declaration of ‘newline’ was here

.. index:: y隱式聲明, Implicit Declaration

但仍然能編譯通過，運行結果也對。這裡涉及到的規則稱為函數的隱式聲明（Implicit Declaration）：

#. 由於在 ``main`` 函數中調用 ``threelines()`` 之前並沒有聲明它，編譯器只能根據函數調用來猜測它的原型，比如根據調用 ``foo(2.1, 3.3)`` 可以猜測 ``foo`` 函數有兩個 ``double`` 型的參數，而我們調用 ``threelines()`` 沒有傳任何參數，所以編譯器認為 ``threelines`` 函數的參數類型是 ``void`` ，另外，編譯器認為所有隱式聲明的返回值類型都是 ``int`` ，所以 ``threelines`` 函數的隱式聲明是 ``int threelines(void);`` ，這樣參數和返回值類型都確定下來了，編譯器可以根據這些信息為 ``threelines()`` 調用生成相應的指令。
#. 然後編譯器接着往下看，看到 ``threelines`` 函數的原型是 ``void threelines(void)`` ，與先前建立的隱式聲明不一致（返回值類型不同），所以報警告。好在我們也沒用到這個函數的返回值，執行結果仍然正確。假如我們在 ``main`` 函數中寫 ``int i = threelines();`` 就要出錯了，雖然編譯也能通過（給出同樣的警告信息），在運行時變數 ``i`` 也確實會被一個值初始化，但這個值並不真的是 ``threelines()`` 調用的返回值，而是由於編譯器生成了錯誤的指令而得到的一個無意義的值。
#. 同理我們也能理解編譯器關於 ``newline`` 函數的警告信息。

注意區分這兩個概念：

*  如果調用函數時參數列表為空，並且缺少函數原型，則編譯器根據隱式聲明規則認為參數類型是 ``void`` 。
*  如果聲明函數時參數列表為空，則這個聲明屬於Old Style C語法，不算函數原型，編譯器認為參數類型和個數沒有明確指出。

.. _func.parameter:

形參和實參
--------------

下面我們定義一個帶參數的函數，我們需要在函數定義中指明參數的個數和每個參數的類型，定義參數就像定義變數一樣，需要為每個參數指明類型，參數的命名也要遵循標識符命名規則。例如：

.. code-block:: c
   :linenos:

   #include <stdio.h>

   void print_time(int hour, int minute)
   {
           printf("%d:%d\n", hour, minute);
   }

   int main(void)
   {
           print_time(23, 59);
           return 0;
   }

如果寫一個非定義的函數聲明，可以只寫參數類型而不寫參數名，例如：

.. code-block:: c
   :linenos:

   void print_time(int, int);

這樣的聲明仍然包含了函數名、參數類型和個數、返回值類型這三要素，所以也算函數原型。注意，定義變數時可以把相同類型的變數列在一起，而定義參數卻不可以，例如下面這樣的定義是錯的：

.. code-block:: c
   :linenos:

   void print_time(int hour, minute)
   {
           printf("%d:%d\n", hour, minute);
   }

.. index:: Rule of Least Surprise

在學編程語言的時候大家肯定都樂意看到這句話：“變數是這樣定義的，參數也是這樣定義的，一模一樣”，這意味着不用專門去記住參數應該怎麼定義了。誰也不願意看到這句話：“定義變數可以這樣寫，而定義參數卻不可以”。C語言的設計者也不希望自己設計的語法規則裡到處都是例外，一個容易被用戶接受的設計應該遵循最少例外原則（Rule of Least Surprise）。

其實這條規定也不算十分例外，也是可以理解的，我們看參數列表的語法規則::

   參數列表 → 列表項, 列表項, ...
   列表項 → 類型 標識符

.. index:: 逗號, Comma

參數列表中的逗號（Comma）是列表項之間的分隔符，如果允許寫 ``void foo(int hour, minute, char c)`` 這樣的聲明，那就是允許一部分列表項有類型一部分列表項沒有類型，還要規定沒有類型的列表項和前一列表項的類型相同，那編譯器實現起來就複雜了。

另外一個問題是，如果仿照變數聲明把參數列表的語法規則改成下面這樣不是很好嗎？

::

   參數列表 → 列表項; 列表項; ...
   列表項 → 類型 標識符, 標識符, ...

按照這樣的語法規則，函數聲明就可以寫成 ``void foo(int hour, minute; char c)`` ，但為什麼C語言沒有這樣規定呢？這也是從Old Style C繼承下來的，Old Style C是這樣聲明參數的：

.. code-block:: c
   :linenos:

   void foo(x, y, z)
   int x;
   char z;
   {
           ...
   }

現在的C編譯器仍然支持這種語法（按Old Style C的語法，上例中未聲明類型的參數 ``y`` 預設是 ``int`` 型）。

.. index:: Rationale

學習編程語言不要死記各種語法規定，如果能夠想清楚設計者這麼規定的原因（Rationale），不僅有助于記憶，而且會有更多收穫。本書在必要的地方會解釋一些Rationale，或者啟發讀者自己去思考，例如上一節在腳註中解釋了 ``void`` 關鍵字的Rationale。 [C99Rationale]_ 是隨C99標準一起發佈的，值得參考。

總的來說，C語言的設計是非常優美的，只要理解了少數基本概念和基本原則就可以根據組合規則寫出任意複雜的程序，很少有例外的規定說這樣組合是不允許的，或者那樣類推是錯誤的。相反，C++的設計就非常複雜，充滿了例外，全世界沒幾個人能把C++的所有規則都牢記於心，因而C++的設計一直飽受爭議，這個觀點在 [UNIX編程藝術]_ 中有詳細闡述。

在本書中，凡是提醒讀者注意的地方都是多少有些Surprise的地方，初學者如果按常理來想很可能要想錯，所以需要特別提醒一下。而初學者容易犯的另外一些錯誤，完全是因為沒有掌握好基本概念和基本原理，或者根本無視組合規則而全憑自己主觀臆斷所致，對這一類問題本書不會做特別的提醒。假設有個初學者看完 :doc:`expr` 之後想這樣打印π的值：

.. code-block:: c
   :linenos:

   double pi=3.1416;
   printf("pi\n");

之所以會犯這種錯誤，一是不理解Literal的含義，二是自己想當然地把變數名組合到字元串裡去，而事實上根本沒有這條語法規則。一段代碼正確的寫法往往只有一種，錯誤的寫法卻有無數種可能，書上有限的篇幅無法覆蓋每一種錯誤的可能性，就好比要提醒小孩吃飯一定要吃到嘴裡，不要吃到鼻子裡，更不要吃到耳朵裡，也不要吃到手裡……根本不可能覆蓋所有犯錯的可能性。

.. index:: x形參, Parameter, s實參, Argument

回到正題。當我們調用 ``print_time(23, 59)`` 時，函數 ``print_time`` 中參數 ``hour`` 的值就是 ``23`` ，參數 ``minute`` 的值就是 ``59`` 。確切地說，當我們討論函數中的 ``hour`` 這個參數時，我們所說的“參數”是指形參（Parameter），當我們討論傳一個參數 ``23`` 給函數時，我們所說的“參數”是指實參（Argument），但我習慣都叫參數而不習慣總把形參、實參這兩個文縐縐的詞掛在嘴邊（事實上大多數人都不習慣），讀者可以根據上下文判斷我說的到底是形參還是實參。記住這條基本原理： **形參相當於函數中定義的變數，調用函數傳遞參數的過程相當於定義形參變數並且用實參的值來初始化。** 例如這樣調用：

.. code-block:: c
   :linenos:

   void print_time(int hour, int minute)
   {
           printf("%d:%d\n", hour, minute);
   }

   int main(void)
   {
           int h = 23, m = 59;
           print_time(h, m);
           return 0;
   }

相當於在函數 ``print_time`` 中執行了這樣一些語句：

.. code-block:: c
   :linenos:

   int hour = h;
   int minute = m;
   printf("%d:%d\n", hour, minute);

.. index:: Call by Value

在調用 ``print_time`` 函數時， ``main`` 函數的變數 ``h`` 和 ``print_time`` 函數的參數 ``hour`` 是兩個不同的變數，但變數 ``h`` 的值傳給了參數 ``hour`` ，因此這兩個變數的存儲空間中都保存了相同的值23。同理，變數 ``m`` 的值傳給了參數 ``minute`` 。C語言的這種傳遞參數的方式稱為Call by Value。

在調用函數時，每個參數都需要得到一個值，函數定義中有幾個形參，在調用時就要傳幾個實參，不能多也不能少，每個參數的類型也必須對應上。肯定有讀者注意到了，為什麼我們調用 ``printf`` 時傳的實參個數經常會不一樣呢？因為C語言規定了一種特殊的參數列表格式，用命令 :command:`man 3 printf` 可以查看到 ``printf`` 函數的原型：

.. code-block:: c
   :linenos:

   int printf(const char *format, ...);

.. index:: k可變參數, Variable Argument, j介面, Interface

第一個參數是 ``const char *`` 類型的，後面的 ``...`` 可以代表0個或任意多個參數，而且這些參數的類型也是不確定的，這種參數稱為可變參數（Variable Argument），我們將在 :ref:`interface.va` 詳細討論帶可變參數的函數。總之，每個函數的原型都明確規定了返回值類型以及參數的類型和個數，即使像 ``printf`` 這樣規定為“不確定”也是一種明確的規定，調用函數時要嚴格遵守這些規定，有時候我們把函數叫做介面（Interface），調用函數就是使用這個介面，使用介面的前提是必須和介面保持一致。

.. index:: Man Page, Section, FHS, Filesystem Hierarchy Standard

.. note:: Man Page

   Man Page是Linux開發最常用的參考手冊，由很多頁面組成，每個頁面描述一個主題，這些頁面被組織成若干個Section。FHS（Filesystem Hierarchy Standard）標準規定了Man Page各Section的含義如下：

   .. table:: Man Page的Section

      =======  ===================================================================================
      Section  描述
      =======  ===================================================================================
      1        用戶命令，例如 :manpage:`ls(1)`
      2        系統調用，例如 :manpage:`_exit(2)`
      3        庫函數，例如 :manpage:`printf(3)`
      4        特殊檔案，例如 :manpage:`null(4)` 描述了設備檔案 :file:`/dev/null` 和 :file:`/dev/zero` 的作用，這個頁面也叫 :manpage:`zero(4)`
      5        系統配置檔案的格式，例如 :manpage:`passwd(5)` 描述了系統配置檔案 :file:`/etc/passwd` 的格式
      6        遊戲
      7        其他雜項，例如 :manpage:`bash-builtins(7)` 描述了 :command:`bash` 的各種內建命令
      8        系統管理命令，例如 :manpage:`ifconfig(8)`
      =======  ===================================================================================

   注意區分用戶命令和系統管理命令，用戶命令通常位於 :file:`/bin` 和 :file:`/usr/bin` 目錄，系統管理命令通常位於 :file:`/sbin` 和 :file:`/usr/sbin` 目錄，一般用戶可以執行用戶命令，而執行系統管理命令經常需要 ``root`` 權限。系統調用和庫函數的區別將在 :ref:`asmc.main` 說明。

   Man Page中有些頁面有重名，比如敲 :command:`man printf` 命令看到的並不是C函數 ``printf`` ，而是位於第1個Section的命令 ``printf`` ，要查看位於第3個Section的 ``printf`` 函數應該敲 :command:`man 3 printf` ，也可以敲 :command:`man -k printf` 命令搜索哪些頁面的主題包含 ``printf`` 關鍵字。本書會經常出現類似 :manpage:`printf(3)` 這樣的寫法，括號中的3表示Man Page的第3個Section，或者表示“我這裡想說的是 ``printf`` 庫函數而不是 ``printf`` 命令”。

習題

#. 定義一個函數 ``increment`` ，它的作用是把傳進來的參數加1。例如：

   .. code-block:: c
      :linenos:

      void increment(int x)
      {
              x = x + 1;
      }

      int main(void)
      {
              int i = 1, j = 2;
              increment(i); /* i now becomes 2 */
              increment(j); /* j now becomes 3 */
              return 0;
      }

   我們在 ``main`` 函數中調用 ``increment`` 增加變數 ``i`` 和 ``j`` 的值，這樣能奏效嗎？為什麼？

#. 如果在一個程序中調用了 ``printf`` 函數卻不包含標頭檔，例如 ``int main(void) { printf("\n"); }`` ，編譯時會報警告： ``warning: incompatible implicit declaration of built-in function ‘printf’`` ，這個警告信息說明了什麼？

#. 說出以下代碼哪些屬於函數聲明，哪些屬於函數定義，哪些屬於函數原型。

   *   main() {}
   *   int foo();
   *   int bar(void) {}
   *   void baz(int i, int);

全局變數、局部變數和作用域
---------------------------

.. index:: j局部變數, Local Variable

我們把函數中定義的變數稱為局部變數（Local Variable），由於形參相當於函數中定義的變數，所以形參也是一種局部變數。在這裡“局部”有兩層含義：

#. 一個函數中定義的變數不能被另一個函數使用。例如 ``print_time`` 中的 ``hour`` 和 ``minute`` 在 ``main`` 函數中沒有定義，不能使用，同樣 ``main`` 函數中的局部變數也不能被 ``print_time`` 函數使用。如果把上一節的代碼改成這樣：

   .. code-block:: c
      :linenos:

      void print_time(int hour, int minute)
      {
              printf("%d:%d\n", hour, minute);
      }

      int main(void)
      {
              int hour = 23, minute = 59;
              print_time(hour, minute);
              return 0;
      }

   在 ``main`` 函數中定義了局部變數 ``hour`` ， ``print_time`` 函數中也有參數 ``hour`` ，雖然它們名稱相同，但仍然是兩個不同的變數，代表不同的存儲單元。 ``main`` 函數的局部變數 ``minute`` 和 ``print_time`` 函數的參數 ``minute`` 也是如此。

#. 每次調用函數時局部變數都表示不同的存儲空間。局部變數在每次函數調用時分配存儲空間，在每次函數返回時釋放存儲空間，例如調用 ``print_time(23, 59)`` 時分配 ``hour`` 和 ``minute`` 兩個變數的存儲空間，在裡面分別存上 ``23`` 和 ``59`` ，函數返回時釋放它們的存儲空間，下次再調用 ``print_time(12, 20)`` 時又分配 ``hour`` 和 ``minute`` 的存儲空間，在裡面分別存上 ``12`` 和 ``20`` 。

.. index:: q全局變數, Global Variable

與局部變數的概念相對的是全局變數（Global Variable），全局變數定義在所有的函數體之外，它們在程序開始運行時分配存儲空間，在程序結束時釋放存儲空間，在任何函數中都可以訪問全局變數，例如：

.. code-block:: c
   :linenos:

   #include <stdio.h>

   int hour = 23, minute = 59;

   void print_time(void)
   {
           printf("%d:%d in print_time\n", hour, minute);
   }

   int main(void)
   {
           print_time();
           printf("%d:%d in main\n", hour, minute);
           return 0;
   }

正因為全局變數在任何函數中都可以訪問，所以在程序運行過程中全局變數被讀寫的順序從原始碼中是看不出來的，原始碼的書寫順序並不能反映函數的調用順序，程序出現了Bug往往就是因為在某個不起眼的地方對全局變數的讀寫順序不正確，如果代碼規模很大，這種錯誤是很難找到的。而對局部變數的訪問不僅侷限在一個函數內部，而且侷限在一次函數調用之中，從函數的原始碼很容易看出訪問的先後順序是怎樣的，所以比較容易找到Bug。因此， **雖然全局變數用起來很方便，但一定要慎用，能用函數傳參代替的就不要用全局變數** 。

如果全局變數和局部變數重名了會怎麼樣呢？如果上面的例子改為：

.. _func.scope:

.. figure:: ../images/func.scope.png

   作用域

則第一次調用 ``print_time`` 打印的是全局變數的值，第二次直接調用 ``printf`` 打印的則是 ``main`` 函數局部變數的值。在C語言中每個標識符都有特定的作用域，全局變數是定義在所有函數體之外的標識符，它的作用域從定義的位置開始直到源檔案結束，而 ``main`` 函數局部變數的作用域僅限于 ``main`` 函數之中。如上圖所示，設想整個源檔案是一張大紙（即全局變數的作用域），而 ``main`` 函數是蓋在這張大紙上的一張小紙（即 ``main`` 函數局部變數的作用域）。在小紙上用到標識符 ``hour`` 和 ``minute`` 時應該參考小紙上的定義，因為大紙（全局變數的作用域）被蓋住了，如果在小紙上用到某個標識符卻沒有找到它的定義（例如上圖中的變數 ``x`` ），那麼再去看下面的大紙上有沒有它的定義。

.. index:: c常量表達式, Constant Expression

到目前為止我們在初始化變數時都是用一個常量或變數做Initializer，其實也可以用組合而成的表達式做Initializer，但要注意一點： **局部變數可以用類型相符的任意表達式來初始化，而全局變數只能用常量表達式（Constant Expression）來初始化。** 例如，全局變數 ``pi`` 這樣初始化是合法的：

.. code-block:: c
   :linenos:

   double pi = 3.14 + 0.0016;

但這樣初始化是不合法的：

.. code-block:: c
   :linenos:

   double pi = acos(-1.0);

然而局部變數這樣初始化卻是合法的。

為什麼要這樣規定呢？因為在程序運行一開始（在還沒有執行 ``main`` 函數中的任何語句之前）就要用初始值來初始化全局變數，這樣 ``main`` 函數的第一條語句就可以取到全局變數的初始值來做計算。要做到這一點，全局變數的初始值必須保存在編譯生成的執行檔中，因此要求初始值必須在 **編譯時** 就能計算出來。上面第一種Initializer（ ``3.14 + 0.0016`` ）的值可以由編譯器直接計算出來並保存在執行檔中，而上面第二種Initializer（ ``acos(-1.0)`` ）的值編譯器是計算不了的，必須在程序 **運行時** 調用 ``acos`` 函數才能計算出來，所以不能用來初始化全局變數。請注意區分編譯時和運行時這兩個概念。

再看下面這個例子定義並初始化 ``minute`` 和 ``hour`` 兩個全局變數：

.. code-block:: c
   :linenos:

   int minute = 360 - 10;
   int hour = minute / 60;

#. 把 ``minute`` 初始化成 ``360 - 10`` 是合法的。編譯器可以算出 ``360 - 10`` 的計算結果是350，並把350保存到執行檔中，程序運行一開始，執行檔中的350這個數據就被加載到變數 ``minute`` 的存儲空間。
#. 把 ``hour`` 初始化成 ``minute / 60`` 是不合法的。雖然在編譯時計算出 ``hour`` 的初始值理論上是可行的（先算出 ``minute`` 的初始值再據此算出 ``hour`` 的初始值），但為了簡化編譯器的實現，C語言從語法上規定全局變數只能用常量表達式來初始化， ``minute / 60`` 不是常量表達式，不符合語法規定，編譯器直接報錯退出而不去算這個初始值。

如果全局變數在定義時不初始化則初始值是0，如果局部變數在定義時不初始化則初始值是不確定的。所以， **局部變數在使用之前一定要先賦值** ，如果基于一個不確定的值做後續計算肯定會引入Bug。

如何證明“局部變數的存儲空間在每次函數調用時分配，在函數返回時釋放”？當我們想要確認某些語法規則時，可以查教材，也可以查C99，但最快捷的辦法就是編個小程序驗證一下：

.. _func.verifylocals:

.. code-block:: c
   :linenos:

   #include <stdio.h>

   void foo(void)
   {
           int i;
           printf("%d\n", i);
           i = 777;
   }

   int main(void)
   {
           foo();
           foo();
           return 0;
   }

第一次調用 ``foo`` 函數，分配變數 ``i`` 的存儲空間，然後打印 ``i`` 的值，由於 ``i`` 未初始化，打印的應該是一個不確定的值，然後把 ``i`` 賦值為 ``777`` ，函數返回，釋放 ``i`` 的存儲空間。第二次調用 ``foo`` 函數，分配變數 ``i`` 的存儲空間，然後打印 ``i`` 的值，由於 ``i`` 未初始化，打印的應該又是一個不確定的值，如果確實如此，就證明了“局部變數的存儲空間在每次函數調用時分配，在函數返回時釋放”。分析完了，我們運行程序看看是不是像我們分析的這樣::

   $ ./a.out
   7991861
   777
   $ ./a.out
   3641909
   777

結果出乎意料，第一次調用打印的 ``i`` 值確實是個不確定值，第二次調用打印的 ``i`` 值正是第一次調用末尾賦給 ``i`` 的值 ``777`` 。

如何分析這個結果呢？有一種初學者是這樣，原本就沒有把這條語法規則記牢，或者對自己的記憶力沒信心，看到這個結果就會想：哦那肯定是我記錯了，改過來記吧，應該是“函數中的局部變數具有一直存在的固定的存儲空間，每次函數調用時使用它，返回時也不釋放，再次調用函數時它應該還能保持上次的值”。還有一種初學者是懷疑論者或不可知論者，看到這個結果就會想：教材上明明說“局部變數的存儲空間在每次函數調用時分配，在函數返回時釋放”，那一定是教材寫錯了，教材也是人寫的，是人寫的就難免出錯，哦，連C99也這麼寫的啊，C99也是人寫的，也難免出錯，或者C99也許沒錯，但是反正運行結果就是錯了，計算機這東西真靠不住，太容易受電磁干擾和宇宙射線影響了，我的程序寫得再正確也有可能被幹擾得不能正確運行。

這是初學者最常見的兩種心態。不從客觀事實和邏輯推理出發分析問題的真正原因，而僅憑主觀臆斷胡亂給問題定性，“說你有罪你就有罪”。先不要胡亂懷疑，我們再做一次實驗，在兩次 ``foo`` 函數調用之間插一個別的函數調用，結果就大不相同了 [#]_ ：

.. [#] 如果你編譯運行這個程序的環境和我的環境（Ubuntu 12.04 LTS 32位x86）不同，也許在你的機器上跑不出這個結果，你只要理解這個例子要說明的基本原理就行了。

.. code-block:: c
   :linenos:

   int main(void)
   {
           foo();
           printf("hello\n");
           foo();
           return 0;
   }

結果是::

   $ ./a.out
   134513793
   hello
   16699380
   $ ./a.out
   134513793
   hello
   13459444

這一回，兩次調用 ``foo`` 打印的 ``i`` 值看起來都挺亂，但似乎第一次調用打印的 ``i`` 值總是不變，那它到底是個確定值還是不確定值呢？

關鍵的一點：我說“未初始化的局部變數的初值是不確定值”，並沒有說每次運行程序時這個不確定值不能相同，也沒有說這個不確定值不能是上次調用函數時賦給該局部變數的值。在這裡“不確定”的準確含義是： **每次調用這個函數時該局部變數的初值可能不一樣，運行環境不同，函數的調用次序不同，都會影響到局部變數的初值。**

.. index:: b必要條件, Necessary Condition, c充分條件, Sufficient Condition

在運用邏輯推理時一定要注意， **不要把必要條件（Necessary Condition）當充分條件（Sufficient Condition）** ，這一點在調試時尤其重要，看到錯誤現象不要輕易斷定原因是什麼，一定要考慮再三，找出它的真正原因。例如，不要看到第二次調用打印777就下結論“函數中的局部變數具有一直存在的固定的存儲空間，每次函數調用時使用它，返回時也不釋放，再次調用函數時它應該還能保持上次的值”，這個結論倒是能推出777這個結果，但反過來由777這個結果卻不能推出這樣的結論。所以說777這個結果是該結論的必要條件，但不是充分條件。至于為什麼這個不確定值有時剛好是777，有時又不是，等學到 :ref:`asmc.funccall` 就能解釋這些現象了。

從 :ref:`func.deffunction` 介紹的語法規則可以看出，非定義的函數聲明也可以寫在局部作用域中，例如：

.. code-block:: c
   :linenos:

   int main(void)
   {
           void print_time(int, int);
           print_time(23, 59);
           return 0;
   }

這樣聲明的標識符 ``print_time`` 具有局部作用域，只在 ``main`` 函數中是有效的函數名，出了 ``main`` 函數就不存在 ``print_time`` 這個標識符了。注意，雖然在一個函數體中可以聲明另一個函數，但不能定義另一個函數，C語言不允許嵌套定義函數 [#]_ 。

.. [#] 但 :command:`gcc` 的擴展特性允許嵌套定義函數，本書不做詳細討論。
