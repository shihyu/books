gdb
========

程序中除了一目瞭然的Bug之外都需要一定的調試手段來分析到底錯在哪。到目前為止我們的調試手段只有一種：根據程序執行時的出錯現象假設錯誤原因，然後在代碼中適當的位置插入 ``printf`` ，執行程序並分析打印結果，如果結果和預期的一樣，就基本上證明了自己假設的錯誤原因，就可以動手修Bug了，如果結果和預期的不一樣，就根據結果做進一步的假設和分析。

本章我們介紹一種很強大的調試工具 :command:`gdb` ，可以完全操控程序的運行，使得程序就像你手裡的玩具一樣，叫它走就走，叫它停就停，並且隨時可以查看程序中所有的內部狀態，比如各變數的值、傳給函數的參數、當前執行的代碼行等。掌握了 :command:`gdb` 的用法之後，調試手段就更加豐富了。但要注意，即使調試手段豐富了，調試的基本思想仍然是“分析現象→假設錯誤原因→產生新的現象去驗證假設”這樣一個循環，根據現象如何假設錯誤原因，以及如何設計新的現象去驗證假設，這都需要非常嚴密的分析和思考，如果因為手裡有了強大的工具就濫用而忽略了分析過程，往往會治標不治本地修正Bug，導致一個錯誤現象消失了但Bug仍然存在，甚至是把程序越改越錯。本章通過初學者易犯的幾個錯誤實例來講解如何使用 :command:`gdb` 調試程序，在每個實例後面總結一部分常用的 :command:`gdb` 命令。

單步執行和跟蹤函數調用
---------------------------

看下面的程序：

.. code-block:: c
   :linenos:

   #include <stdio.h>

   int add_range(int low, int high)
   {
           int i, sum;
           for (i = low; i <= high; i++)
                   sum = sum + i;
           return sum;
   }

   int main(void)
   {
           int result[1000];
           result[0] = add_range(1, 10);
           result[1] = add_range(1, 100);
           printf("result[0]=%d\nresult[1]=%d\n", result[0], result[1]);
           return 0;
   }


``add_range`` 函數從 ``low`` 加到 ``high`` ，在 ``main`` 函數中首先從1加到10，把結果保存下來，然後從1加到100，再把結果保存下來，最後打印的兩個結果是::

   result[0]=55
   result[1]=5105

第一個結果正確，第二個結果顯然不正確 [#]_ ，在小學我們就聽說過高斯小時候的故事，從1加到100應該是5050。一段代碼，第一次運行結果是對的，第二次運行卻不對，這是很常見的一類錯誤現象，這種情況一方面要懷疑代碼，另一方面更要懷疑數據：第一次和第二次運行的都是同一段代碼，如果代碼是錯的，那第一次的結果為什麼能對呢？所以很可能是第二次運行時相關的狀態和數據錯了，錯誤的數據導致了錯誤的結果。在動手調試之前，讀者先試試只看代碼能不能看出錯誤原因，只要前面幾章學得紮實就應該能看出來。

.. [#] 如果你編譯運行這個程序的環境和我的環境（Ubuntu 12.04 LTS 32位x86）不同，也許在你的機器上跑不出這個結果，那也沒關係，重要的是學會本章介紹的思想方法。另外你也可以嘗試修改程序，總有辦法得到類似的結果，上例中故意定義了一個很大的數組 ``result[1000]`` ，修改數組的大小就會改變各局部變數的存儲空間的位置，運行結果就可能會不同。

在編譯時要加上 :option:`-g` 選項，生成的執行檔才能用 :command:`gdb` 進行源碼級調試::

   $ gcc -g main.c -o main
   $ gdb main
   GNU gdb (Ubuntu/Linaro 7.4-2012.02-0ubuntu2) 7.4-2012.02
   Copyright (C) 2012 Free Software Foundation, Inc.
   License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
   This is free software: you are free to change and redistribute it.
   There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
   and "show warranty" for details.
   This GDB was configured as "i686-linux-gnu".
   For bug reporting instructions, please see:
   <http://bugs.launchpad.net/gdb-linaro/>...
   Reading symbols from /home/akaedu/main...done.
   (gdb) 

:option:`-g` 選項的作用是在執行檔中加入源檔案的信息，即執行檔 :file:`main` 中的第幾條機器指令對應源檔案 :file:`main.c` 的第幾行，但並不是把整個源檔案嵌入到執行檔中，所以在調試時必須保證 :command:`gdb` 能找到源檔案 :file:`main.c` 。 :command:`gdb` 提供一個類似Shell的命令行環境，上面的 ``(gdb)`` 就是提示符，在這個提示符下輸入 ``help`` 可以查看命令的類別::

   (gdb) help
   List of classes of commands:

   aliases -- Aliases of other commands
   breakpoints -- Making program stop at certain points
   data -- Examining data
   files -- Specifying and examining files
   internals -- Maintenance commands
   obscure -- Obscure features
   running -- Running the program
   stack -- Examining the stack
   status -- Status inquiries
   support -- Support facilities
   tracepoints -- Tracing of program execution without stopping the program
   user-defined -- User-defined commands

   Type "help" followed by a class name for a list of commands in that class.
   Type "help all" for the list of all commands.
   Type "help" followed by command name for full documentation.
   Type "apropos word" to search for commands related to "word".
   Command name abbreviations are allowed if unambiguous.

也可以進一步查看某一類別中有哪些命令，例如查看 ``files`` 類別下有哪些命令可用::

   (gdb) help files
   Specifying and examining files.

   List of commands:

   add-symbol-file -- Load symbols from FILE
   add-symbol-file-from-memory -- Load the symbols out of memory from a dynamically loaded object file
   cd -- Set working directory to DIR for debugger and program being debugged
   core-file -- Use FILE as core dump for examining memory and registers
   directory -- Add directory DIR to beginning of search path for source files
   edit -- Edit specified file or function
   exec-file -- Use FILE as program for getting contents of pure memory
   file -- Use FILE as program to be debugged
   forward-search -- Search for regular expression (see regex(3)) from last line listed
   generate-core-file -- Save a core file with the current state of the debugged process
   list -- List specified function or line
   ...

現在試試用 ``list`` 命令從第一行開始列出原始碼::

   (gdb) list 1
   1	#include <stdio.h>
   2	
   3	int add_range(int low, int high)
   4	{
   5		int i, sum;
   6		for (i = low; i <= high; i++)
   7			sum = sum + i;
   8		return sum;
   9	}
   10  

一次只列10行，如果要從第11行開始繼續列原始碼可以再輸入一次::

   (gdb) list

也可以什麼都不輸直接敲回車， :command:`gdb` 提供了一個很方便的功能，在提示符下直接敲回車表示重複上一條命令::

   (gdb) （直接回車）
   11	int main(void)
   12	{
   13		int result[1000];
   14		result[0] = add_range(1, 10);
   15		result[1] = add_range(1, 100);
   16		printf("result[0]=%d\nresult[1]=%d\n", result[0], result[1]);
   17		return 0;
   18	}

:command:`gdb` 的很多常用命令有簡寫形式，例如 ``list`` 命令可以寫成 ``l`` ，要列一個函數的原始碼也可以用函數名做參數::

   (gdb) l add_range
   1	#include <stdio.h>
   2	
   3	int add_range(int low, int high)
   4	{
   5		int i, sum;
   6		for (i = low; i <= high; i++)
   7			sum = sum + i;
   8		return sum;
   9	}
   10	

現在退出 :command:`gdb` 的環境::

   (gdb) quit

我們做一個實驗，把原始碼改名或移到別處再用 :command:`gdb` 調試，這樣就列不出原始碼了::

   $ mv main.c mian.c
   $ gdb main
   ...
   (gdb) l
   5	main.c: No such file or directory.

可見 :command:`gcc` 的 :option:`-g` 選項並不是把原始碼嵌入到執行檔中，在調試時也需要源檔案。現在把原始碼恢復原樣，我們繼續調試。首先用 ``start`` 命令開始執行程序::

   $ gdb main
   ...
   (gdb) start
   Temporary breakpoint 1 at 0x8048415: file main.c, line 14.
   Starting program: /home/akaedu/main 

   Temporary breakpoint 1, main () at main.c:14
   14		result[0] = add_range(1, 10);
   (gdb) 

:command:`gdb` 停在 ``main`` 函數中變數定義之後的第一條語句處等待我們發命令（ :command:`gdb` 在提示符之前最後列出的語句總是“即將執行的下一條語句”）。我們可以用 ``next`` 命令（簡寫為 ``n`` ）控制這些語句一條一條地執行::

   (gdb) n
   15		result[1] = add_range(1, 100);
   (gdb) （直接回車）
   16		printf("result[0]=%d\nresult[1]=%d\n", result[0], result[1]);
   (gdb) （直接回車）
   result[0]=55
   result[1]=5105
   17		return 0;

用 ``n`` 命令依次執行兩行賦值語句和一行打印語句，在執行打印語句時結果立刻打出來了，然後停在 ``return`` 語句之前等待我們發命令。雖然我們完全控制了程序的執行，但仍然看不出哪裡錯了，因為錯誤不在 ``main`` 函數中而在 ``add_range`` 函數中，現在用 ``start`` 命令重新來過，這次用 ``step`` 命令（簡寫為 ``s`` ）鑽進 ``add_range`` 函數中去跟蹤執行::

   (gdb) start
   The program being debugged has been started already.
   Start it from the beginning? (y or n) y
   Temporary breakpoint 2 at 0x8048415: file main.c, line 14.
   Starting program: /home/akaedu/main 

   Temporary breakpoint 2, main () at main.c:14
   14		result[0] = add_range(1, 10);
   (gdb) s
   add_range (low=1, high=10) at main.c:6
   6		for (i = low; i <= high; i++)

這次停在了 ``add_range`` 函數中變數定義之後的第一條語句處。在函數中有幾種查看狀態的辦法， ``backtrace`` 命令（簡寫為 ``bt`` ）可以查看函數調用的棧幀：

(gdb) bt
#0  add_range (low=1, high=10) at main.c:6
#1  0x08048429 in main () at main.c:14

可見當前的 ``add_range`` 函數是被 ``main`` 函數調用的， ``main`` 傳進來的參數是 ``low=1, high=10`` 。 ``main`` 函數的棧幀編號為1， ``add_range`` 的棧幀編號為0。現在可以用 ``info`` 命令（簡寫為 ``i`` ）查看 ``add_range`` 函數局部變數的值::

   (gdb) i locals
   i = 0
   sum = 0

如果想查看 ``main`` 函數當前局部變數的值也可以做到，先用 ``frame`` 命令（簡寫為 ``f`` ）選擇1號棧幀然後再查看局部變數::

   (gdb) f 1
   #1  0x08048429 in main () at main.c:14
   14		result[0] = add_range(1, 10);
   (gdb) i locals 
   result = {0 <repeats 471 times>, 1184572, 0 <repeats 11 times>, -1207961512, -1073746088, 1249268, -1073745624, 1142336, 
   ...

注意到 ``result`` 數組中很多元素的值是雜亂無章的，我們知道未經初始化的局部變數具有不確定的值，到目前為止一切正常。用 ``s`` 或 ``n`` 往下走幾步，然後用 ``print`` 命令（簡寫為 ``p`` ）打印出變數 ``sum`` 的值::

   (gdb) s
   7			sum = sum + i;
   (gdb) （直接回車）
   6		for (i = low; i <= high; i++)
   (gdb) （直接回車）
   7			sum = sum + i;
   (gdb) （直接回車）
   6		for (i = low; i <= high; i++)
   (gdb) p sum
   $1 = 3

第一次循環 ``i`` 是1，第二次循環 ``i`` 是2，加起來是3，沒錯。這裡的 ``$1`` 表示 :command:`gdb` 保存着這些中間結果，$後面的編號會自動增長，在命令中可以用 ``$1`` 、 ``$2`` 、 ``$3`` 等編號代替相應的值。由於我們本來就知道第一次調用的結果是正確的，再往下跟也沒意義了，可以用 ``finish`` 命令讓程序一直運行到從當前函數返回為止::

   (gdb) finish
   Run till exit from #0  add_range (low=1, high=10) at main.c:6
   0x08048429 in main () at main.c:14
   14		result[0] = add_range(1, 10);
   Value returned is $2 = 55

返回值是55，當前正準備執行賦值操作，用 ``n`` 命令執行賦值操作後查看 ``result`` 數組::

   (gdb) n
   15		result[1] = add_range(1, 100);
   (gdb) p result
   $3 = {55, 0 <repeats 470 times>, 1184572, 0 <repeats 11 times>, -1207961512, -1073746088, 1249268, -1073745624, 1142336, 
   ...

第一個值55確實賦給了 ``result`` 數組的第0個元素。下面用 ``s`` 命令進入第二次 ``add_range`` 調用，進入之後首先查看參數和局部變數::

   (gdb) s
   add_range (low=1, high=100) at main.c:6
   6		for (i = low; i <= high; i++)
   (gdb) bt
   #0  add_range (low=1, high=100) at main.c:6
   #1  0x08048441 in main () at main.c:15
   (gdb) i locals 
   i = 11
   sum = 55

由於局部變數 ``i`` 和 ``sum`` 沒初始化，所以具有不確定的值，又由於兩次調用是挨着的， ``i`` 和 ``sum`` 正好取了上次調用時的值，回顧一下我們講過的 :ref:`驗證局部變數存儲空間的分配和釋放 <func.verifylocals>` 那個例子，其實和現在這個例子是一樣的道理，只不過我這次舉的例子設法讓局部變數 ``sum`` 在第一次調用時初值為0而第二次調用時初值不為0。 ``i`` 的初值不確定倒沒關係，在 ``for`` 循環中首先會把 ``i`` 賦值為 ``low`` ，但 ``sum`` 如果初值不是0，累加得到的結果就錯了。好了，我們已經找到錯誤原因，可以退出 :command:`gdb` 修改原始碼了。如果我們不想浪費這次調試機會，可以在 :command:`gdb` 中馬上把 ``sum`` 的初值改為0繼續運行，看看這一處改了之後還有沒有別的Bug::

   (gdb) set var sum=0
   (gdb) finish
   Run till exit from #0  add_range (low=1, high=100) at main.c:6
   0x08048441 in main () at main.c:15
   15		result[1] = add_range(1, 100);
   Value returned is $4 = 5050
   (gdb) n
   16		printf("result[0]=%d\nresult[1]=%d\n", result[0], result[1]);
   (gdb) （直接回車）
   result[0]=55
   result[1]=5050
   17		return 0;

這樣結果就對了。修改變數的值除了用 ``set`` 命令之外也可以用 ``print`` 命令，因為 ``print`` 命令後面跟的是表達式，而我們知道賦值和函數調用也都是表達式，所以也可以用 ``print`` 命令修改變數的值或者調用函數::

   (gdb) p result[2]=33
   $5 = 33
   (gdb) p printf("result[2]=%d\n", result[2])
   result[2]=33
   $6 = 13

我們講過， ``printf`` 的返回值表示實際打印的字元數，所以 ``$6`` 的結果是13。最後總結一下本節用到的 :command:`gdb` 命令：

.. table:: gdb基本命令1

   ======================   =================================================
   命令                      描述
   ======================   =================================================
   backtrace（或bt）         查看各級函數調用及參數
   finish                    連續運行到當前函數返回為止，然後停下來等待命令
   frame（或f） 幀編號        選擇棧幀
   info（或i） locals        查看當前棧幀局部變數的值
   list（或l）               列出原始碼，接着上次的位置往下列，每次列10行
   list 行號                 列出從第幾行開始的原始碼
   list 函數名               列出某個函數的原始碼
   next（或n）               執行下一行語句
   print（或p）              打印表達式的值，通過表達式可以修改變數的值或者調用函數
   quit（或q）               退出 :command:`gdb` 調試環境
   set var                   修改變數的值
   start                     開始執行程序，停在 ``main`` 函數第一行語句前面等待命令
   step（或s）               執行下一行語句，如果有函數調用則進入到函數中
   ======================   =================================================

.. rubric:: 習題

#. 用 :command:`gdb` 一步一步跟蹤 :ref:`func2.recurse` 講的 ``factorial`` 函數，對照着 :ref:`func2.factorial` 查看各層棧幀的變化情況，練習本節所學的各種 :command:`gdb` 命令。

.. _gdb.breakpoint:

斷點
----------

看以下程序：

.. code-block:: c
   :linenos:

   #include <stdio.h>

   int main(void)
   {
           int sum = 0, i = 0;
           char input[5];

           while (1) {
                   scanf("%s", input);
                   for (i = 0; input[i] != '\0'; i++)
                           sum = sum*10 + input[i] - '0';
                   printf("input=%d\n", sum);
           }
           return 0;
   }


這個程序的作用是：首先從鍵盤讀入一串數字存到字元數組 ``input`` 中，然後轉換成整型存到 ``sum`` 中，然後打印出來，一直這樣循環下去。 ``scanf("%s", input);`` 這個調用的功能是等待用戶輸入一個字元串並回車， ``scanf`` 把其中第一段非空白（非空格、Tab、換行）的字元串保存到 ``input`` 數組中，並自動在末尾添加 ``'\0'`` 。接下來的循環從左到右掃瞄字元串並把每個數字累加到結果中，例如輸入是 ``"2345"`` ，則循環累加的過程是(((0×10+2)×10+3)×10+4)×10+5=2345。注意字元型的 ``'2'`` 要減去 ``'0'`` 的ASCII碼才能轉換成整數值2。下面編譯運行程序看看有什麼問題::

   $ gcc main.c -g -o main
   $ ./main 
   123
   input=123
   234
   input=123234
   ^C（按Ctrl-C退出程序）
   $

又是這種現象，第一次是對的，第二次就不對。可是這個程序我們並沒有忘了賦初值，不僅 ``sum`` 賦了初值，連不必賦初值的 ``i`` 都賦了初值。讀者先試試只看代碼能不能看出錯誤原因。下面來調試::

   $ gdb main
   ...
   (gdb) start
   Temporary breakpoint 1 at 0x804843d: file main.c, line 4.
   Starting program: /home/akaedu/main 

   Temporary breakpoint 1, main () at main.c:4
   4	{
   (gdb) n
   5	        int sum = 0, i = 0;

有了上一次的經驗， ``sum`` 被列為重點懷疑對象，我們可以用 ``display`` 命令使得每次停下來的時候都顯示當前 ``sum`` 的值，然後繼續往下走::

   (gdb) display sum
   1: sum = 1466933
   (gdb) n
   9	                scanf("%s", input);
   1: sum = 0
   (gdb) 
   123
   10	                for (i = 0; input[i] != '\0'; i++)
   1: sum = 0

.. index:: d斷點, Breakpoint

``undisplay`` 命令可以取消跟蹤顯示，變數 ``sum`` 的編號是1，可以用 ``undisplay 1`` 命令取消它的跟蹤顯示。這個循環應該沒有問題，因為上面第一次輸入時打印的結果是正確的。如果不想一步一步走這個循環，可以用 ``break`` 命令（簡寫為 ``b`` ）在第9行設一個斷點（Breakpoint）::

   (gdb) l
   5		int sum = 0, i = 0;
   6		char input[5];
   7	
   8		while (1) {
   9			scanf("%s", input);
   10			for (i = 0; input[i] != '\0'; i++)
   11				sum = sum*10 + input[i] - '0';
   12			printf("input=%d\n", sum);
   13		}
   14		return 0;
   (gdb) b 9
   Breakpoint 2 at 0x8048459: file main.c, line 9.

``break`` 命令的參數也可以是函數名，表示在某個函數開頭設斷點。現在用 ``continue`` 命令（簡寫為 ``c`` ）連續運行而非單步運行，程序到達斷點會自動停下來，這樣就可以停在下一次循環的開頭::

   (gdb) c
   Continuing.
   input=123

   Breakpoint 2, main () at main.c:9
   9	                scanf("%s", input);
   1: sum = 123

然後輸入新的字元串準備轉換::

   (gdb) n
   234
   10	                for (i = 0; input[i] != '\0'; i++)
   1: sum = 123

問題暴露出來了，新的轉換應該再次從0開始累加，而 ``sum`` 現在已經是123了，原因在於新的循環沒有把 ``sum`` 歸零。可見斷點有助于快速跳過沒有問題的代碼，然後在有問題的代碼上慢慢走慢慢分析，“斷點加單步”是使用調試器的基本方法。至于應該在哪裡設置斷點，怎麼知道哪些代碼可以跳過而哪些代碼要慢慢走，也要通過對錯誤現象的分析和假設來確定，以前我們用 ``printf`` 打印中間結果時也要分析應該在哪裡插入 ``printf`` ，打印哪些中間結果，調試的基本思路是一樣的。一次調試可以設置多個斷點，用 ``info`` 命令可以查看已經設置的斷點::

   (gdb) b 12
   Breakpoint 3 at 0x80484b2: file main.c, line 12.
   (gdb) i breakpoints 
   Num     Type           Disp Enb Address    What
   2       breakpoint     keep y   0x08048459 in main at main.c:9
           breakpoint already hit 1 time
   3       breakpoint     keep y   0x080484b2 in main at main.c:12

每個斷點都有一個編號，可以用編號指定刪除某個斷點::

   (gdb) delete breakpoints 2
   (gdb) i breakpoints 
   Num     Type           Disp Enb Address    What
   3       breakpoint     keep y   0x080484b2 in main at main.c:12

有時候一個斷點暫時不用可以禁用掉而不必刪除，這樣以後想用的時候可以直接啟用，而不必重新從代碼裡找應該在哪一行設斷點::

   (gdb) disable breakpoints 3
   (gdb) i breakpoints 
   Num     Type           Disp Enb Address    What
   3       breakpoint     keep n   0x080484b2 in main at main.c:12
   (gdb) enable 3
   (gdb) i breakpoints 
   Num     Type           Disp Enb Address    What
   3       breakpoint     keep y   0x080484b2 in main at main.c:12
   (gdb) delete  breakpoints 
   Delete all breakpoints? (y or n) y
   (gdb) i breakpoints 
   No breakpoints or watchpoints.

:command:`gdb` 的斷點功能非常靈活，還可以設置斷點在滿足某個條件時才激活，例如我們仍然在循環開頭設置斷點，但是僅當 ``sum`` 不等於0時才中斷，然後用 ``run`` 命令（簡寫為 ``r`` ）重新從程序開頭連續運行::

   (gdb) break 9 if sum != 0
   Breakpoint 4 at 0x8048459: file main.c, line 9.
   (gdb) i breakpoints 
   Num     Type           Disp Enb Address    What
   4       breakpoint     keep y   0x08048459 in main at main.c:9
           stop only if sum != 0
   (gdb) r
   The program being debugged has been started already.
   Start it from the beginning? (y or n) y
   Starting program: /home/akaedu/main 
   123
   input=123

   Breakpoint 4, main () at main.c:9
   9	                scanf("%s", input);
   1: sum = 123

結果是第一次執行 ``scanf`` 之前沒有中斷，第二次卻中斷了。總結一下本節用到的 :command:`gdb` 命令：

.. table:: gdb基本命令2

   ============================   ========================================
   命令	                          描述
   ============================   ========================================
   break（或b） 行號                在某一行設置斷點
   break 函數名                    在某個函數開頭設置斷點
   break ... if ...               設置條件斷點
   continue（或c）                 從當前位置開始連續運行程序
   delete breakpoints 斷點號       刪除斷點
   display 變數名                  跟蹤查看某個變數，每次停下來都顯示它的值
   disable breakpoints 斷點號      禁用斷點
   enable 斷點號                   啟用斷點
   info（或i） breakpoints         查看當前設置了哪些斷點
   run（或r）                      從頭開始連續運行程序
   undisplay 跟蹤顯示號             取消跟蹤顯示
   ============================   ========================================

.. rubric:: 習題

#. 看下面的程序：

   .. code-block:: c
      :linenos:

      #include <stdio.h>

      int main(void)
      {
              int i;
              char str[6] = "hello";
              char reverse_str[6] = "";

              printf("%s\n", str);
              for (i = 0; i < 5; i++)
                      reverse_str[5-i] = str[i];
              printf("%s\n", reverse_str);
              return 0;
      }

   首先用字元串 ``"hello"`` 初始化一個字元數組 ``str`` （算上 ``'\0'`` 共6個字元）。然後用空字元串 ``""`` 初始化一個同樣長的字元數組 ``reverse_str`` ，相當於所有元素用 ``'\0'`` 初始化。然後打印 ``str`` ，把 ``str`` 倒序存入 ``reverse_str`` ，再打印 ``reverse_str`` 。然而結果並不正確::

      $ ./main 
      hello

   我們本來希望 ``reverse_str`` 打印出來是 ``olleh`` ，結果打出來一個空行。重點懷疑對象肯定是循環，那麼簡單驗算一下， ``i=0`` 時， ``reverse_str[5]=str[0]`` ，也就是 ``'h'`` ， ``i=1`` 時， ``reverse_str[4]=str[1]`` ，也就是 ``'e'`` ，依此類推，i=0,1,2,3,4，共5次循環，正好把h,e,l,l,o五個字母給倒過來了，哪裡不對了？請用 :command:`gdb` 跟蹤循環，找出錯誤原因並改正。

觀察點
-----------

繼續修改上一節的程序。經過調試我們得出結論，對於這個程序來說， ``sum`` 賦不賦初值不重要，重要的是在 ``while (1)`` 循環體的開頭加上 ``sum = 0;`` ，這才能保證每次循環從0開始累加。我們把程序改成這樣：

.. code-block:: c
   :linenos:

   #include <stdio.h>

   int sum = 0, i;
   char input[5];

   int main(void)
   {
           while (1) {
                   sum = 0;
                   scanf("%s", input);
                   for (i = 0; input[i] != '\0'; i++)
                           sum = sum*10 + input[i] - '0';
                   printf("input=%d\n", sum);
           }
           return 0;
   }

在這裡我故意把 ``sum`` 、 ``i`` 、 ``input`` 定義成全局變數， ``sum`` 賦初值而 ``i`` 和 ``input`` 不賦初值，這是為了比較容易產生本節要講的錯誤現象。還是那句話，如果你的運行環境和我不同，在你機器上可能跑不出書上說的結果。你可以先看書，在理解了基本原理之後自己改改程序看能不能跑出類似的結果：變數定義在全局還是局部作用域，在定義時是否初賦了初值，這些都會影響變數所占的存儲空間的位置，從而影響本程序的運行結果。

使用 ``scanf`` 函數是非常凶險的，即使修正了上一節的Bug也還存在很多問題。如果輸入的字元串超長了會怎麼樣？我們知道數組訪問越界是不會被檢查的，所以 ``scanf`` 會把 ``input`` 數組寫越界。現象是這樣的::

   $ ./main 
   1234
   input=1234
   1234567
   input=1234567
   12345678
   input=123456740

輸入1234567其實已經訪問越界了，但程序還能給出正確結果。而輸入12345678時程序給出一個非常詭異的結果，下面我們用調試器看看這個詭異的結果是怎麼出來的::

   $ gdb main
   ...
   (gdb) start
   Temporary breakpoint 1 at 0x804843d: file main.c, line 9.
   Starting program: /home/akaedu/main 

   Temporary breakpoint 1, main () at main.c:9
   9	                sum = 0;
   (gdb) n
   10	                scanf("%s", input);
   (gdb) （直接回車）
   12345678
   11	                for (i = 0; input[i] != '\0'; i++)
   (gdb) p input
   $1 = "12345"

在這裡 :command:`gdb` 知道 ``input`` 數組的長度是5，所以用 ``p`` 命令查看時只顯示5個字元。我們換一種辦法查看就可以看到其實已經寫越界了::

   (gdb) p printf("%x %x %x %x %x %x %x %x %x\n", input[0], input[1], input[2], input[3], input[4], input[5], input[6], input[7], input[8])
   31 32 33 34 35 36 37 38 0
   $2 = 26

這條命令從 ``input`` 數組的第一個位元組開始連續打印9個位元組，打印的正是 ``'1'`` 到 ``'8'`` 的十六進制ASCII碼，還有一個 ``'\0'`` ，所以 ``scanf`` 實際上寫越界了四個字元：``'6'`` 、 ``'7'`` 、 ``'8'`` 、 ``'\0'`` 。 ``printf`` 的轉換說明 ``%x`` 表示按16進制打印。

根據運行結果“123456740”，用戶輸入的前7個字元轉成數字都沒錯，第8個錯了，也就是 ``i`` 從0到6的循環都沒錯，我們設一個條件斷點從 ``i`` 等於7開始單步調試::

   (gdb) l
   6	int main(void)
   7	{
   8	        while (1) {
   9	                sum = 0;
   10	                scanf("%s", input);
   11	                for (i = 0; input[i] != '\0'; i++)
   12	                        sum = sum*10 + input[i] - '0';
   13	                printf("input=%d\n", sum);
   14	        }
   15	        return 0;
   (gdb) b 12 if i == 7
   Breakpoint 2 at 0x8048468: file main.c, line 12.
   (gdb) c
   Continuing.

   Breakpoint 2, main () at main.c:12
   12	                        sum = sum*10 + input[i] - '0';
   (gdb) p sum
   $3 = 1234567

現在 ``sum`` 是1234567沒錯，我們推測即將進行的下一步計算肯定要出錯，調試的結果出乎意料，下一步計算並沒有出錯::

   (gdb) p input[i]
   $4 = 56 '8'
   (gdb) n
   11	                for (i = 0; input[i] != '\0'; i++)
   (gdb) p sum
   $5 = 12345678

``input[i]`` 是 ``'8'`` ，減去 ``'0'`` 等於8，把 ``sum`` 的當前值1234567乘以10再加上8，確實得到了12345678。那為什麼打印的結果卻不是這一步算出的12345678呢？只有一個解釋：這一步計算之後並沒有跳出循環去執行 ``printf`` ，而是繼續下一輪循環::

   (gdb) n
   12	                        sum = sum*10 + input[i] - '0';
   (gdb) p i
   $6 = 8
   (gdb) p input[i]
   $7 = 8 '\b'
   (gdb) n
   11	                for (i = 0; input[i] != '\0'; i++)
   (gdb) p sum
   $8 = 123456740
   (gdb) n
   13	                printf("input=%d\n", sum);
   (gdb) p i
   $9 = 9
   (gdb) p input[9]
   $10 = 0 '\000'

先前我們明明打印出 ``input[8]`` 是 ``'\0'`` ，什麼時候變成 ``'\b'`` 的呢？這一變，循環的控制條件 ``input[8] != '\0'`` 又得到滿足了，原本應該跳出循環的，現在又進循環了，把sum累加成了12345678*10 + '\b' - '0' = 123456740 （ ``'\b'`` 的ASCII碼是8， ``'0'`` 的ASCII碼是48）。然後 ``input[9]`` 確實是0，跳出循環，打印，終於得出了那個詭異的結果！

現在我們要弄清楚 ``input[8]`` 到底是什麼時候變的，可以用觀察點（Watchpoint）來跟蹤。我們知道斷點是當程序執行到某一代碼行時中斷，而觀察點是當程序訪問某個存儲單元時中斷。如果我們不知道某個存儲單元是被哪一行代碼改動的，觀察點就非常有用了。下面刪除原來設的斷點，從頭執行程序，重複上次的輸入，用 ``watch`` 命令設置觀察點，跟蹤 ``input[8]`` 的存儲單元::

   (gdb) delete breakpoints 
   Delete all breakpoints? (y or n) y
   (gdb) start
   The program being debugged has been started already.
   Start it from the beginning? (y or n) y
   Temporary breakpoint 3 at 0x804843d: file main.c, line 9.
   Starting program: /home/akaedu/main 

   Temporary breakpoint 3, main () at main.c:9
   9	                sum = 0;
   (gdb) n
   10	                scanf("%s", input);
   (gdb) （直接回車）
   12345678
   11	                for (i = 0; input[i] != '\0'; i++)
   (gdb) watch input[8]
   Hardware watchpoint 4: input[8]
   (gdb) i watchpoints 
   Num     Type           Disp Enb Address    What
   4       hw watchpoint  keep y              input[8]
   (gdb) c
   Continuing.
   Hardware watchpoint 4: input[8]

   Old value = 0 '\000'
   New value = 1 '\001'
   0x0804849f in main () at main.c:11
   11	                for (i = 0; input[i] != '\0'; i++)
   (gdb) c
   Continuing.
   Hardware watchpoint 4: input[8]

   Old value = 1 '\001'
   New value = 2 '\002'
   0x0804849f in main () at main.c:11
   11	                for (i = 0; input[i] != '\0'; i++)

已經很明顯了，每次都是回到 ``for`` 循環開頭的時候改變了 ``input[8]`` 的值，而且是每次加1－－這不就是循環變數 ``i`` 麼？原來循環變數 ``i`` 就位於 ``input[8]`` 的位置。 ``input[5]`` 、 ``input[6]`` 、 ``input[7]`` 雖然也是訪問越界，但還不算嚴重，反正也沒有別的變數占用這塊存儲空間，而 ``input[8]`` 這個訪問越界就嚴重了，直接訪問到變數 ``i`` 的頭上了。其實用 ``x`` 命令可以清楚地看到這一點，只不過為了防止“劇透”我一開始沒有這麼做::

   (gdb) x/12bx input
   0x804a024 <input>:	0x31	0x32	0x33	0x34	0x35	0x36	0x37	0x38
   0x804a02c <i>:	0x02	0x00	0x00	0x00

``x`` 命令打印指定的存儲單元裡保存的內容，尾碼 ``8bx`` 是打印格式，12表示打印12組，b表示每個位元組一組，x表示按十六進制格式打印 [#]_ ，我們可以看到在 ``input`` 的存儲單元的起始位置加8個位元組處正是變數 ``i`` 的存儲單元。

.. [#] 打印結果最左邊的一長串數字是內存地址，在 :ref:`arch.memaddr` 詳細解釋，目前可以無視。

修正這個Bug對初學者來說有一定難度。如果你發現了這個Bug卻沒想到數組訪問越界這一點，也許一時想不出原因，就會先去處理另外一個更容易修正的Bug：如果輸入的不是數字而是字母或別的符號也能算出結果來，這顯然是不對的，可以在循環中加上判斷條件檢查非法字元。

.. code-block:: c
   :linenos:

   while (1) {
           sum = 0;
           scanf("%s", input);
           for (i = 0; input[i] != '\0'; i++) {
                   if (input[i] < '0' || input[i] > '9') {
                           printf("Invalid input!\n");
                           sum = -1;
                           break;
                   }
                   sum = sum*10 + input[i] - '0';
           }
           printf("input=%d\n", sum);
   }

然後你會驚喜地發現，不僅輸入字母會報錯，輸入超長也會報錯::

   $ ./main
   123a
   Invalid input!
   input=-1
   dead
   Invalid input!
   input=-1
   1234578
   Invalid input!
   input=-1
   1234567890abcdef
   Invalid input!
   input=-1
   23
   input=23

似乎是兩個Bug一起解決掉了，但這是治標不治本的解決方法。看起來輸入超長的錯誤是不出現了，但只要沒有找到根本原因就不可能真的解決掉，等到條件一變，它可能又冒出來了，在下一節你會看到它又以一種新的形式冒出來了。現在請思考一下為什麼加上檢查非法字元的代碼之後輸入超長也會報錯。

最後總結一下本節用到的 :command:`gdb` 命令：

.. table:: gdb基本命令3

   ==========================   =============================================================================
   命令                          描述
   ==========================   =============================================================================
   watch                        設置觀察點
   info（或i） watchpoints       查看當前設置了哪些觀察點
   x                            從某個位置開始打印存儲單元的內容，全部當成位元組來看，而不區分哪個位元組屬於哪個變數
   ==========================   =============================================================================

.. _gdb.segfault:

程序崩潰
----------------

如果程序運行時出現段錯誤，用 :command:`gdb` 可以很容易定位到究竟是哪一行引發的段錯誤，例如這個小程序：

.. code-block:: c
   :linenos:

   #include <stdio.h>

   int main(void)
   {
           int man = 0;
           scanf("%d", man);
           return 0;
   }


調試過程如下::

   $ gdb main
   ...

   (gdb) r
   Starting program: /home/akaedu/main 
   123

   Program received signal SIGSEGV, Segmentation fault.
   0x00180a93 in _IO_vfscanf () from /lib/i386-linux-gnu/libc.so.6
   (gdb) bt
   #0  0x00180a93 in _IO_vfscanf () from /lib/i386-linux-gnu/libc.so.6
   #1  0x0018747b in __isoc99_scanf () from /lib/i386-linux-gnu/libc.so.6
   #2  0x0804842a in main () at main.c:6

在 :command:`gdb` 中運行，遇到段錯誤會自動停下來，這時可以用命令查看當前執行到哪一行代碼了。 :command:`gdb` 顯示段錯誤出現在 ``_IO_vfscanf`` 函數中，用 ``bt`` 命令可以看到這個函數是被 ``main.c`` 的第6行間接調用的，也就是 ``scanf`` 這行代碼引發的段錯誤。仔細觀察程序發現是 ``man`` 前面少了個&。

繼續調試上一節的程序，上一節最後提出修正Bug的方法是在循環中加上判斷條件，如果不是數字就報錯退出，結果是不僅輸入非法字元可以報錯退出，輸入超長的字元串也會報錯退出。表面上看這個程序無論怎麼運行都不出錯了，但假如我們把 ``while (1)`` 循環去掉，每次執行程序只轉換一個數：

.. code-block:: c
   :linenos:

   #include <stdio.h>

   int main(void)
   {
           int sum = 0, i = 0;
           char input[5];

           scanf("%s", input);
           for (i = 0; input[i] != '\0'; i++) {
                   if (input[i] < '0' || input[i] > '9') {
                           printf("Invalid input!\n");
                           sum = -1;
                           break;
                   }
                   sum = sum*10 + input[i] - '0';
           }
           printf("input=%d\n", sum);

           return 0;
   }


然後輸入一個超長的字元串，看看會發生什麼::

   $ ./main
   12345678
   input=12345678
   *** stack smashing detected ***: ./main terminated
   ======= Backtrace: =========
   /lib/i386-linux-gnu/libc.so.6(__fortify_fail+0x45)[0xf4cdd5]
   /lib/i386-linux-gnu/libc.so.6(+0xffd8a)[0xf4cd8a]
   ./main[0x8048592]
   /lib/i386-linux-gnu/libc.so.6(__libc_start_main+0xf3)[0xe664d3]
   ./main[0x8048421]
   ======= Memory map: ========
   00138000-00158000 r-xp 00000000 08:01 394133     /lib/i386-linux-gnu/ld-2.15.so
   00158000-00159000 r--p 0001f000 08:01 394133     /lib/i386-linux-gnu/ld-2.15.so
   00159000-0015a000 rw-p 00020000 08:01 394133     /lib/i386-linux-gnu/ld-2.15.so
   00c97000-00c98000 r-xp 00000000 00:00 0          [vdso]
   00e0f000-00e2b000 r-xp 00000000 08:01 394174     /lib/i386-linux-gnu/libgcc_s.so.1
   00e2b000-00e2c000 r--p 0001b000 08:01 394174     /lib/i386-linux-gnu/libgcc_s.so.1
   00e2c000-00e2d000 rw-p 0001c000 08:01 394174     /lib/i386-linux-gnu/libgcc_s.so.1
   00e4d000-00fec000 r-xp 00000000 08:01 394153     /lib/i386-linux-gnu/libc-2.15.so
   00fec000-00fee000 r--p 0019f000 08:01 394153     /lib/i386-linux-gnu/libc-2.15.so
   00fee000-00fef000 rw-p 001a1000 08:01 394153     /lib/i386-linux-gnu/libc-2.15.so
   00fef000-00ff2000 rw-p 00000000 00:00 0 
   08048000-08049000 r-xp 00000000 08:01 439349     /home/akaedu/main
   08049000-0804a000 r--p 00000000 08:01 439349     /home/akaedu/main
   0804a000-0804b000 rw-p 00001000 08:01 439349     /home/akaedu/main
   09c65000-09c86000 rw-p 00000000 00:00 0          [heap]
   b7780000-b7781000 rw-p 00000000 00:00 0 
   b778e000-b7793000 rw-p 00000000 00:00 0 
   bfb0c000-bfb2d000 rw-p 00000000 00:00 0          [stack]
   Aborted (core dumped)

我們輸入12345678，計算結果12345678都打印完了，卻在最後爆出整整一屏錯誤信息。準確地說這是另外一種形式的程序崩潰而不是段錯誤，不過我們可以按同樣的方法用 :command:`gdb` 調試看看::

   $ gdb main
   ...
   (gdb) r
   Starting program: /home/akaedu/main 
   12345678
   input=12345678
   *** stack smashing detected ***: /home/akaedu/main terminated
   ======= Backtrace: =========
   /lib/i386-linux-gnu/libc.so.6(__fortify_fail+0x45)[0x232dd5]
   /lib/i386-linux-gnu/libc.so.6(+0xffd8a)[0x232d8a]
   /home/akaedu/main[0x8048592]
   /lib/i386-linux-gnu/libc.so.6(__libc_start_main+0xf3)[0x14c4d3]
   /home/akaedu/main[0x8048421]
   ======= Memory map: ========
   00110000-00130000 r-xp 00000000 08:01 394133     /lib/i386-linux-gnu/ld-2.15.so
   00130000-00131000 r--p 0001f000 08:01 394133     /lib/i386-linux-gnu/ld-2.15.so
   00131000-00132000 rw-p 00020000 08:01 394133     /lib/i386-linux-gnu/ld-2.15.so
   00132000-00133000 r-xp 00000000 00:00 0          [vdso]
   00133000-002d2000 r-xp 00000000 08:01 394153     /lib/i386-linux-gnu/libc-2.15.so
   002d2000-002d4000 r--p 0019f000 08:01 394153     /lib/i386-linux-gnu/libc-2.15.so
   002d4000-002d5000 rw-p 001a1000 08:01 394153     /lib/i386-linux-gnu/libc-2.15.so
   002d5000-002d8000 rw-p 00000000 00:00 0 
   002d8000-002f4000 r-xp 00000000 08:01 394174     /lib/i386-linux-gnu/libgcc_s.so.1
   002f4000-002f5000 r--p 0001b000 08:01 394174     /lib/i386-linux-gnu/libgcc_s.so.1
   002f5000-002f6000 rw-p 0001c000 08:01 394174     /lib/i386-linux-gnu/libgcc_s.so.1
   08048000-08049000 r-xp 00000000 08:01 439349     /home/akaedu/main
   08049000-0804a000 r--p 00000000 08:01 439349     /home/akaedu/main
   0804a000-0804b000 rw-p 00001000 08:01 439349     /home/akaedu/main
   0804b000-0806c000 rw-p 00000000 00:00 0          [heap]
   b7fed000-b7fee000 rw-p 00000000 00:00 0 
   b7ffb000-b8000000 rw-p 00000000 00:00 0 
   bffdf000-c0000000 rw-p 00000000 00:00 0          [stack]

   Program received signal SIGABRT, Aborted.
   0x00132416 in __kernel_vsyscall ()
   (gdb) bt
   #0  0x00132416 in __kernel_vsyscall ()
   #1  0x001611ef in raise () from /lib/i386-linux-gnu/libc.so.6
   #2  0x00164835 in abort () from /lib/i386-linux-gnu/libc.so.6
   #3  0x0019c2fa in ?? () from /lib/i386-linux-gnu/libc.so.6
   #4  0x00232dd5 in __fortify_fail () from /lib/i386-linux-gnu/libc.so.6
   #5  0x00232d8a in __stack_chk_fail () from /lib/i386-linux-gnu/libc.so.6
   #6  0x08048592 in main () at main.c:20

:command:`gdb` 指出，錯誤發生在第20行。可是這一行什麼都沒有啊，只有表示 ``main`` 函數結束的}括號。這可以算是一條規律， **如果某個函數的局部變數發生訪問越界，有可能並不立即產生段錯誤，而是在函數返回時產生段錯誤** 。

想要寫出Bug-free的程序是非常不容易的，即使 ``scanf`` 讀入字元串這麼一個簡單的函數調用都會隱藏着各種各樣的錯誤。有些錯誤現象是我們暫時沒法解釋的，在後續章節中都會解釋清楚。其實現在講 ``scanf`` 這個函數為時過早，讀者還不具備充足的基礎知識，而且這個函數的用法也確實是相當複雜，要用得準確無誤是挺難的，本書將在 :ref:`stdlib.formattedio` 詳細解釋這個函數。現在早早地引入這個函數是為了讓讀者可以早早地開始寫有用的程序，畢竟，一個只能輸出（ ``printf`` ）而不能輸入（ ``scanf`` ）的程序算不上什麼有用的程序。



