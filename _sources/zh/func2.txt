深入理解函數
================

.. _func2.return:

return語句
--------------

之前我們一直在 ``main`` 函數中使用 ``return`` 語句，現在是時候全面深入地學習一下了。在有返回值的函數中， ``return`` 語句的作用是提供整個函數的返回值，並結束當前函數的執行返回到調用它的地方。在沒有返回值的函數中也可以使用 ``return`` 語句，例如當檢查到一個錯誤時提前結束當前函數的執行並返回：

.. code-block:: c
   :linenos:

   #include <math.h>

   void print_logarithm(double x)
   {
           if (x <= 0.0) {
                   printf("Positive number only, please.\n");
                   return;
           }
           printf("The log of x is %f\n", log(x));
   }

這個函數首先檢查參數 ``x`` 是否大於0，如果 ``x`` 不大於0就打印 ``Positive number only, please.`` ，然後提前結束函數的執行並返回到調用者，只有當 ``x`` 大於0時才會計算 ``x`` 的自然對數，在打印了計算結果之後到達函數體末尾，結束函數的執行並返回。注意，使用數學函數 ``log`` 需要包含標頭檔 :file:`math.h` ，由於 ``x`` 是浮點數，應該與同類型的數做比較，所以把0寫成0.0。

在 :ref:`cond.ifelse` 中我們定義了一個檢查奇偶性的函數，如果參數是奇數就打印 ``x is odd`` ，如果參數是偶數就打印 ``x is even`` 。事實上這個函數並不十分好用，我們定義一個檢查奇偶性的函數往往不是為了打印兩個字元串就完了，而是為了根據奇偶性的不同分別執行不同的後續動作。我們可以把它改成一個返回布爾值的函數：

.. code-block:: c
   :linenos:

   int is_even(int x)
   {
           if (x % 2 == 0)
                   return 1;
           else
                   return 0;
   }

有些人喜歡寫成 ``return(1);`` 這種形式也可以，表達式外面套括號表示改變運算符優先順序，在這裡不起任何作用。我們可以這樣調用這個函數：

.. code-block:: c
   :linenos:

   int i = 19;
   if (is_even(i)) {
           /* do something */
   } else {
           /* do some other thing */
   }

.. index:: w謂詞, Predicate

返回布爾值的函數是一類非常有用的函數，在程序中通常充當控製表達式，函數名通常帶有 ``is`` 或 ``if`` 等表示判斷的詞，這類函數也叫做謂詞（Predicate）。

``is_even`` 這個函數寫得有點囉嗦， ``x % 2`` 這個表達式本來就有0值或非0值，可以直接把它看作布爾值：

.. code-block:: c
   :linenos:

   int is_even(int x)
   {
           return !(x % 2);
   }

函數的返回值應該這樣理解： **函數返回一個值相當於定義一個和返回值類型相同的臨時變數，並用return後面的表達式來初始化這個臨時變數。** 例如上面的函數調用相當於這樣的過程：

.. code-block:: c
   :linenos:

   int 臨時變數 = !(x % 2);
   函數退出，局部變數x的存儲空間釋放;
   if (臨時變數) { /* 臨時變數用完就釋放 */
           /* do something */
   } else {
           /* do some other thing */
   }

當 ``if`` 語句對函數的返回值做判斷時，函數已經退出，局部變數 ``x`` 已經釋放，所以不可能在這時候才計算表達式 ``!(x % 2)`` 的值，表達式的值必然是事先計算好了保存在一個沒有名字的臨時變數裡的，然後函數退出，局部變數釋放， ``if`` 語句對這個臨時變數的值做判斷。注意，雖然函數的返回值可以看作是一個臨時變數，但我們只是讀一下它的值，讀完值就釋放它，而不能往它裡面存新的值，換句話說， **函數的返回值不是左值，或者說函數調用表達式不能做左值** ，因此下面的賦值語句是非法的：

.. code-block:: c
   :linenos:

   is_even(20) = 1;

在 :ref:`func.parameter` 中講過，C語言的傳參規則是Call by Value，按值傳遞，現在我們知道返回值也是按值傳遞的，即便返回語句寫成 ``return x;`` ，返回的也是變數 ``x`` 的值，而非變數 ``x`` 本身，因為變數 ``x`` 馬上就要被釋放了。

.. index:: d代碼路徑, Code Path, Dead Code

在寫帶有 ``return`` 語句的函數時要小心檢查所有的代碼路徑（Code Path）。有些代碼路徑在任何條件下都執行不到，這稱為Dead Code，例如把&&和||運算符記混了（據我瞭解初學者犯這個低級錯誤的不在少數），寫出如下代碼：

.. code-block:: c
   :linenos:

   void foo(int x, int y)
   {
           if (x >= 0 || y >= 0) {
                   printf("both x and y are positive\n");
                   return;
           } else if (x < 0 || y < 0) {
                   printf("both x and y are negative\n");
                   return;
           }
           printf("x has a different sign from y\n");
   }

最後一行 ``printf`` 永遠都沒機會被執行到，是一行Dead Code。有Dead Code就一定有Bug，你寫的每一行代碼都是想讓程序在某種情況下去執行的，你不可能故意寫出一行永遠不會被執行的代碼，如果程序在任何情況下都不會去執行它，說明跟你預想的不一樣，要麼是你對所有可能的情況分析得不正確，要麼就是像上例這樣的筆誤，這些屬於邏輯錯誤和語義錯誤。

還有一些時候，對程序中所有可能的情況分析得不夠全面將導致漏掉一些代碼路徑，例如：

.. code-block:: c
   :linenos:

   int absolute_value(int x)
   {
           if (x < 0) {
                   return -x;
           } else if (x > 0) {
                   return x;
           }
   }

這個函數被定義為返回 ``int`` ，就應該在任何情況下都返回 ``int`` ，但是上面這個程序在 ``x==0`` 時安靜地退出函數，什麼也不返回，C標準對於這種情況會返回什麼結果是未定義的，通常返回不確定的值，等學到 :ref:`asmc.funccall` 你就知道為什麼了。另外注意這個例子中把-號當負號用而不是當減號用，事實上+號也可以這麼用。正負號是單目運算符，而加減號是雙目運算符，正負號的優先順序和邏輯非運算符相同，比加減的優先順序要高。

以上兩段代碼都不會產生編譯錯誤，編譯器只做語法檢查和最簡單的語義檢查，而不檢查程序的邏輯 [#]_ 。雖然到現在為止你見到了各種各樣的編譯器錯誤提示，也許你已經十分討厭編譯器報錯了，但很快你就會認識到，如果程序中有錯誤編譯器還不報錯，那一定比報錯更糟糕。比如上面的絶對值函數，在你測試的時候運行得很好，也許是你沒有測到 ``x==0`` 的情況，也許剛好在你的環境中 ``x==0`` 時返回的不確定值就是0，然後你放心地把它整合到一個數萬行的程序之中。然後你把這個程序交給用戶，起初的幾天裡相安無事，之後每過幾個星期就有用戶報告說程序出錯，但每次出錯的現象都不一樣，而且這個錯誤很難復現，你想讓它出現時它就不出現，在你毫無防備時它又突然冒出來了。然後你花了大量的時間在數萬行代碼中排查哪裡錯了，幾天之後終於幸運地找到了這個函數的Bug，這時候你就會想，如果當初編譯器能報個錯多好啊！所以，如果編譯器報錯了，不要責怪編譯器太過于挑剔，它幫你節省了大量的調試時間。另外，在 :file:`math.h` 中有一個 ``fabs`` 函數就是求絶對值的，我們通常不必自己寫絶對值函數。

.. [#] 如果在一個返回值類型不是 ``void`` 的函數中有的代碼路徑沒有返回值， :command:`gcc` 預設不報錯，如果編譯時加 :option:`-Wall` 選項是會報警告的。

.. rubric:: 習題

#. 編寫一個布爾函數 ``int is_leap_year(int year)`` ，判斷參數 ``year`` 是不是閏年。（註：如果某年份能被4整除，但不能被100整除，那麼這一年就是閏年，此外，能被400整除的年份也是閏年）
#. 編寫一個函數 ``double myround(double x)`` ，輸入一個小數，將它四捨五入。例如 ``myround(-3.51)`` 的值是-4.0， ``myround(4.49)`` 的值是4.0。可以調用 :file:`math.h` 中的庫函數 ``ceil`` 和 ``floor`` 實現這個函數（庫函數的用法請查閲Man Page的第3個Section，以後我們寫成“庫函數 :manpage:`ceil(3)` 和 :manpage:`floor(3)` ”），代碼要儘可能簡潔高效。

.. _func2.incremental:

增量式開發
-------------------

.. index:: z增量式, Incremental

到目前為止你看到了很多示例代碼，也在它們的基礎上做了很多改動並在這個過程中鞏固了所學的知識。但是如果從頭開始編寫一個程序解決某個問題，應該按什麼步驟來寫呢？本節提出一種增量式（Incremental）開發的思路，很適合初學者。

現在問題來了：我們要編一個程序求圓的面積，圓的半徑由平面直角坐標系裏兩個端點的坐標(x\ :sub:`1`, y\ :sub:`1`)和(x\ :sub:`2`, y\ :sub:`2`)給出。首先分析和分解問題，把大問題分解成小問題，再對小問題分別求解。這個問題可分為兩步：

#. 由兩個端點坐標求半徑的長度，我們知道平面上兩點間距離的公式是distance=√((x\ :sub:`2`-x\ :sub:`1`)\ :sup:`2`\ +(y\ :sub:`2`-y\ :sub:`1`)\ :sup:`2`)，括號裡的部分都可以用我們學過的C語言表達式來表示，求平方根可以用 :file:`math.h` 中的 ``sqrt`` 函數，因此這個小問題全部都可以用我們學過的知識解決。這個公式可以實現成一個函數，參數是兩點的坐標，返回值是 ``distance`` 。
#. 上一步算出的距離是圓的半徑，已知圓的半徑之後求面積的公式是area=π·radius\ :sup:`2` ，也可以用我們學過的C語言表達式來解決。這個公式也可以實現成一個函數，參數是 ``radius`` ，返回值是 ``area`` 。

首先編寫 ``distance`` 這個函數，我們已經明確了它的參數是兩點的坐標，返回值是兩點間距離，可以先寫一個簡單的函數定義：

.. code-block:: c
   :linenos:

   double distance(double x1, double y1, double x2, double y2)
   {
           return 0.0;
   }

初學者寫到這裡就已經不太自信了：這個函數定義寫得對嗎？雖然我是按我理解的語法規則寫的，但書上沒有和這個一模一樣的例子，萬一不小心遺漏了什麼呢？既然不自信就不要再往下寫了，沒有一個平穩的心態來寫程序很可能會引入Bug。所以在函數定義中插一個 ``return 0.0;`` 立刻結束掉它，然後立刻測試這個函數定義得有沒有錯：

.. code-block:: c
   :linenos:

   int main(void)
   {
           printf("distance is %f\n", distance(1.0, 2.0, 4.0, 6.0));
           return 0;
   }

編譯，運行，一切正常。這時你就會建立起信心了：既然沒問題，就不用管它了，繼續往下寫。在測試時給這個函數的參數是(1.0, 2.0)和(4.0, 6.0)，兩點的x坐標距離是3.0，y坐標距離是4.0，因此兩點間距離應該是5.0，你必須事先知道正確答案是5.0，這樣你才能測試程序計算的結果對不對。當然，現在函數還沒實現，計算結果肯定是不對的。現在我們再往函數裡添一點代碼：

.. code-block:: c
   :linenos:

   double distance(double x1, double y1, double x2, double y2)
   {
           double dx = x2 - x1;
           double dy = y2 - y1;
           printf("dx is %f\ndy is %f\n", dx, dy);

           return 0.0;
   }

.. index:: j腳手架, Scaffold

如果你不確定 ``dx`` 和 ``dy`` 這樣初始化行不行，那麼就此打住，在函數裡插一條打印語句把 ``dx`` 和 ``dy`` 的值打出來看看。把它和上面的 ``main`` 函數一起編譯運行，我們事先知道結果應該是3.0和4.0，因此能夠驗證程序算得對不對。一旦驗證無誤，函數裡的這句打印就可以撤掉了，像這種打印語句，以及我們用來測試的 ``main`` 函數，都起到了類似腳手架（Scaffold）的作用：在蓋房子時很有用，但它不是房子的一部分，房子蓋好之後就可以拆掉了。我們知道房子蓋好之後可能還需要維修、加蓋、翻新，又要重新加上腳手架，這很麻煩，要是當初不用拆就好了，可是不拆不行，不拆多難看啊。寫代碼卻可以有一個更高明的解決辦法：把Scaffolding的代碼註釋掉。

.. code-block:: c
   :linenos:

   double distance(double x1, double y1, double x2, double y2)
   {
           double dx = x2 - x1;
           double dy = y2 - y1;
           /* printf("dx is %f\ndy is %f\n", dx, dy); */
           return 0.0;
   }

這樣如果以後出了新的Bug又需要跟蹤調試時，還可以把這句重新加進代碼中使用。兩點的x坐標距離和y坐標距離都沒問題了，下面求它們的平方和：

.. code-block:: c
   :linenos:

   double distance(double x1, double y1, double x2, double y2)
   {
           double dx = x2 - x1;
           double dy = y2 - y1;
           double dsquared = dx * dx + dy * dy;
           printf("dsquared is %f\n", dsquared);

           return 0.0;
   }

然後再編譯、運行，看看是不是得25.0。這樣的增量式開發非常適合初學者，每寫一行代碼都編譯運行，確保沒問題了再寫下一行，一方面在寫代碼時更有信心，另一方面也方便了調試：總是有一個先前的正確版本做參照，改動之後如果出了問題，几乎可以肯定就是剛纔改的那行代碼出的問題，這樣就避免了必須從很多行代碼中查找分析到底是哪一行出的問題。在這個過程中 ``printf`` 功不可沒，你懷疑哪一行代碼有問題，就插一個 ``printf`` 進去看看中間的計算結果，任何錯誤都可以通過這個辦法找出來。在 :doc:`gdb` 我們會介紹程序調試工具 :command:`gdb` ，它提供了更強大的調試功能幫你分析更隱蔽的錯誤。但即使有了 :command:`gdb` ， ``printf`` 這個最原始的辦法仍然是最直接、最有效的。

最後一步，我們完成這個函數：

.. code-block:: c
   :linenos:

   #include <math.h>
   #include <stdio.h>

   double distance(double x1, double y1, double x2, double y2)
   {
           double dx = x2 - x1;
           double dy = y2 - y1;
           double dsquared = dx * dx + dy * dy;
           double result = sqrt(dsquared);

           return result;
   }

   int main(void)
   {
           printf("distance is %f\n", distance(1.0, 2.0, 4.0, 6.0));
           return 0;
   }

然後編譯運行，看看是不是得5.0。隨着編程經驗越來越豐富，你可能每次寫若干行代碼再一起測試，而不是像現在這樣每寫一行就測試一次，但不管怎麼樣，增量式開發的思路是很有用的，它可以幫你節省大量的調試時間，不管你有多強，都不應該一口氣寫完整個程序再編譯運行，那几乎是一定會有Bug的，到那時候再找Bug就難了。

這個程序中引入了很多臨時變數（ ``dx`` 、 ``dy`` 、 ``dsquared`` 、 ``result`` ），如果你有信心把整個表達式一次性寫好，也可以不用臨時變數：

.. code-block:: c
   :linenos:

   double distance(double x1, double y1, double x2, double y2)
   {
           return sqrt((x2-x1) * (x2-x1) + (y2-y1) * (y2-y1));
   }

這樣寫簡潔得多了。但如果寫錯了呢？只知道是這一長串表達式有錯，根本不知道錯在哪，而且整個函數就一個語句，想插 ``printf`` 看中間結果都沒地方插。所以用臨時變數有它的好處，使程序更清晰，調試更方便，而且有時候可以避免不必要的計算，例如上面這一行表達式要把 ``(x2-x1)`` 計算兩遍，如果算完 ``(x2-x1)`` 把結果存在一個臨時變數 ``dx`` 裡，就不需要再算第二遍了。

接下來編寫 ``area`` 這個函數：

.. code-block:: c
   :linenos:

   double area(double radius)
   {
           return 3.1416 * radius * radius;
   }

給出兩點的坐標求距離，給出半徑求圓的面積，這兩個子問題都解決了，如何把它們組合起來解決整個問題呢？給出半徑的兩端點坐標(1.0, 2.0)和(4.0, 6.0)，先用 ``distance`` 函數求出半徑的長度，再把這個長度傳給 ``area`` 函數求圓的面積：

.. code-block:: c
   :linenos:

   double radius = distance(1.0, 2.0, 4.0, 6.0);
   double result = area(radius);

也可以這樣：

.. code-block:: c
   :linenos:

   double result = area(distance(1.0, 2.0, 4.0, 6.0));

我們一直把“給出半徑的兩端點坐標求圓的面積”這個問題當作整個問題來看，如果它也是一個更大的程序當中的子問題呢？我們可以把先前的兩個函數組合起來做成一個新的函數以便日後使用：

.. code-block:: c
   :linenos:

   double area_point(double x1, double y1, double x2, double y2)
   {
           return area(distance(x1, y1, x2, y2));
   }

還有另一種組合的思路，不是把 ``distance`` 和 ``area`` 兩個函數調用組合起來，而是把那兩個函數中的語句組合到一起：

.. code-block:: c
   :linenos:

   double area_point(double x1, double y1, double x2, double y2)
   {
           double dx = x2 - x1;
           double dy = y2 - y1;
           double radius = sqrt(dx * dx + dy * dy);

           return 3.1416 * radius * radius;
   }

.. index:: f復用, Reuse

這樣組合是不理想的。這樣組合了之後，原來寫的 ``distance`` 和 ``area`` 兩個函數還要不要了呢？如果不要了刪掉，那麼如果有些情況只需要求兩點間的距離，或者只需要給定半徑長度求圓的面積呢？ ``area_point`` 把所有語句都寫在一起，太不靈活了，滿足不了這樣的需要。如果保留 ``distance`` 和 ``area`` 同時也保留這個 ``area_point`` 怎麼樣呢？ ``area_point`` 和 ``distance`` 有重複的代碼，一旦在 ``distance`` 函數中發現了Bug，或者要升級 ``distance`` 這個函數以實現更高的計算精度，那麼不僅要修改 ``distance`` ，還要記着修改 ``area_point`` ，同理，要修改 ``area`` 也要記着修改 ``area_point`` ，維護重複的代碼是非常容易出錯的，在任何時候都要儘量避免。因此， **儘可能復用（Reuse）以前寫的代碼，避免寫重複的代碼** 。封裝就是為了復用，把解決各種小問題的代碼封裝成函數，在解決第一個大問題時可以用這些函數，在解決第二個大問題時可以復用這些函數。

.. index:: f分層, Stratify

解決問題的過程是把大問題分解成小問題，把小問題再分解成更小的問題，這個過程在代碼中體現為函數的分層設計（Stratify）。 ``distance`` 和 ``area`` 是兩個底層函數，解決一些很小的問題，而 ``area_point`` 是一個上層函數，上層函數通過調用底層函數來解決更大的問題，底層和上層函數都可以被更上一層的函數調用，最終所有的函數都直接或間接地被 ``main`` 函數調用，如下圖所示：

.. figure:: ../images/func2.stratify.png

   函數的分層設計

.. _func2.recurse:

遞歸
-----------

.. index:: d遞歸, Recursive

如果定義一個概念需要用到這個概念本身，我們稱它的定義是遞歸的（Recursive）。例如：

frabjuous
    an adjective used to describe something that is frabjuous.

.. index:: Base Case

這只是一個玩笑，如果你在字典上看到這麼一個詞條肯定要怒了。然而數學上確實有很多概念是用它自己來定義的，比如n的階乘（Factorial）是這樣定義的：n的階乘等於n乘以n-1的階乘。如果這樣就算定義完了，恐怕跟上面那個詞條有異曲同工之妙了：n-1的階乘是什麼？是n-1乘以n-2的階乘。那n-2的階乘又是什麼？這樣下去永遠也沒完。因此需要定義一個最關鍵的基礎條件（Base Case）：0的階乘等於1。

::

   0!=1
   n!=n·(n-1)!

因此，3!=3×2!，2!=2×1!，1!=1×0!=1×1=1，正因為有了Base Case，才不會永遠沒完地數下去，知道了1!=1我們再反過來算回去，2!=2×1!=2×1=2，3!=3×2!=3×2=6。下面用程序來完成這一計算過程，我們要寫一個計算階乘的函數 ``factorial`` ，先把Base Case這種最簡單的情況寫進去：

.. code-block:: c
   :linenos:

   int factorial(int n)
   {
           if (n == 0)
                   return 1;
   }

如果參數 ``n`` 不是0應該 ``return`` 什麼呢？根據定義，應該 ``return n*factorial(n-1);`` ，為了下面的分析方便，我們引入幾個臨時變數把這個語句拆分一下：

.. code-block:: c
   :linenos:

   int factorial(int n)
   {
           if (n == 0)
                   return 1;
           else {
                   int recurse = factorial(n-1);
                   int result = n * recurse;
                   return result;
           }
   }

``factorial`` 這個函數居然可以自己調用自己？是的。自己直接或間接調用自己的函數稱為遞歸函數。這裡的 ``factorial`` 是直接調用自己，有些時候函數A調用函數B，函數B又調用函數A，也就是函數A間接調用自己，這也是一種遞歸調用。如果你覺得迷惑，可以把 ``factorial(n-1)`` 這一步看成是在調用另一個函數－－另一個有着相同函數名和相同代碼的函數，調用它就是跳到它的代碼裡執行，然後再返回 ``factorial(n-1)`` 這個調用的下一步繼續執行。我們以 ``factorial(3)`` 為例分析整個調用過程，如下圖所示：

.. _func2.factorial:

.. figure:: ../images/func2.factorial.png

   factorial(3)的調用過程

圖中用實線箭頭表示調用，用虛線箭頭表示返回，右側的框表示在調用和返回過程中各層函數調用的存儲空間變化情況。

#. ``main()`` 有一個局部變數 ``result`` ，用一個框表示。
#. 調用 ``factorial(3)`` 時要分配參數和局部變數的存儲空間，於是在 ``main()`` 的下面又多了一個框表示 ``factorial(3)`` 的參數和局部變數，其中 ``n`` 已初始化為3。
#. ``factorial(3)`` 又調用 ``factorial(2)`` ，又要分配 ``factorial(2)`` 的參數和局部變數，於是在 ``main()`` 和 ``factorial(3)`` 下面又多了一個框。在 :ref:`func.scope` 講過，每次調用函數時分配參數和局部變數的存儲空間，退出函數時釋放它們的存儲空間。 ``factorial(3)`` 和 ``factorial(2)`` 是兩次不同的調用， ``factorial(3)`` 的參數 ``n`` 和 ``factorial(2)`` 的參數 ``n`` 各有各的存儲單元，雖然我們寫代碼時只寫了一次參數 ``n`` ，但運行時卻是兩個不同的參數 ``n`` 。並且由於調用 ``factorial(2)`` 時 ``factorial(3)`` 還沒退出，所以兩個函數調用的參數 ``n`` 同時存在，我們就需要在 ``main()`` 和 ``factorial(3)`` 下面多畫一個框來表示 ``factorial(2)`` 的參數和局部變數。
#. 依此類推，請讀者對照着圖自己分析整個調用過程。讀者會發現這個過程和前面我們用數學公式計算3!的過程是一樣的，都是先一步步展開然後再一步步收回去。

.. index:: d堆棧, z棧, Stack, z棧幀, Stack Frame

我們看上圖右側存儲空間的變化過程，隨着函數調用的層層深入，存儲空間的一端逐漸增長，然後隨着函數調用的層層返回，存儲空間的這一端又逐漸縮短，並且每次訪問參數和局部變數時只能訪問這一端最外層函數調用的存儲單元，而不能訪問內層函數調用的存儲單元，比如當 ``factorial(2)`` 的存儲空間位於末端時，只能訪問它的參數和局部變數，而不能訪問 ``factorial(3)`` 和 ``main()`` 的參數和局部變數。具有這種性質的資料結構稱為堆棧或棧（Stack），隨着函數調用和返回而不斷變化的這一端稱為棧頂，每個函數調用的參數和局部變數的存儲空間（上圖的每個小方框）稱為一個棧幀（Stack Frame）。操作系統為程序的運行預留了一塊棧空間，函數調用時就在這個棧空間裡分配棧幀，函數返回時就釋放棧幀。

在寫一個遞歸函數時，你如何證明它是正確的？像上面那樣跟蹤函數的調用和返回過程算是一種辦法，但只是 ``factorial(3)`` 就已經這麼麻煩了，如果是 ``factorial(100)`` 呢？雖然我們已經證明了 ``factorial(3)`` 是正確的，因為它跟我們用數學公式計算的過程一樣，結果也一樣，但這不能代替 ``factorial(100)`` 的證明，你怎麼辦？別的函數你可以跟蹤它的調用過程去證明它的正確性，因為每個函數隻調用一次就返回了，但是對於遞歸函數，這麼跟下去只會跟得你頭都大了。

事實上並不是每個函數調用都需要鑽進去看的。在上一節中，我們寫了 ``distance`` 和 ``area`` 函數，然後立刻測試證明了這兩個函數是正確的，然後我們寫 ``area_point`` 時調用了這兩個函數：

.. code-block:: c
   :linenos:

   return area(distance(x1, y1, x2, y2));

在寫這一句的時候，我們需要鑽進 ``distance`` 和 ``area`` 函數中去走一趟才知道我們調用得是否正確嗎？不需要，因為我們已經 **相信** 這兩個函數能正確工作了，也就是相信把坐標傳給 ``distance`` 它就能返回正確的距離，把半徑傳給 ``area`` 它就能返回正確的面積，因此調用它們去完成另外一件工作也應該是正確的。

.. index:: Leap of Faith

我們在調用 ``printf`` 時把這種“相信”又往前推進了一步，我們連glibc是怎麼實現 ``printf`` 的都不知道，就直接相信它了，就調用它寫我們自己的代碼了。這種“相信”稱為Leap of Faith。任何程序在計算機上運行起來都是一個無比複雜的過程，如果什麼都不相信－－不相信編譯器，不相信操作系統，不相信我們用的所有函式館－－那麼即使是分析一個Hello World程序的運行過程都會讓我們舉步維艱。即便我們的程序所依賴的運行環境真的有很多很多Bug，我們也只能暫且相信它們能正常工作，然後把注意力先集中在我們自己寫的代碼上。

假設我們在寫 ``factorial(n)`` 的代碼時寫到這個地方：

.. code-block:: c
   :linenos:

   ...
   int recurse = factorial(n-1);
   int result = n * recurse;
   ...

這時，如果我們相信 ``factorial(n-1)`` 是正確的，也就是相信傳給它 ``n-1`` 它就能返回(n-1)!，那麼 ``recurse`` 的值就是(n-1)!，那麼 ``result`` 的值就是n*(n-1)!，也就是n!，這正是我們要返回的 ``factorial(n)`` 的結果。當然這有點奇怪：我們還沒寫完 ``factorial`` 這個函數，憑什麼要相信 ``factorial(n-1)`` 是正確的？這又把Leap of Faith往前推進了一步：不僅相信別人寫的庫函數，連我們自己寫的還沒寫完的函數都要相信！但遞歸函數就是這樣寫出來的： **只要你相信你正在寫的遞歸函數是正確的，並調用它，在此基礎上寫完這個遞歸函數，那麼它就會是正確的，從而值得你相信它正確。**

越說越玄了，我們還是從數學上嚴格證明一下 ``factorial`` 函數的正確性吧：

#. 剛纔說了， ``factorial(n)`` 的正確性依賴于 ``factorial(n-1)`` 的正確性，只要後者正確，在後者的結果上乘個 ``n`` 返回這一步顯然也沒有疑問，那麼我們的函數實現就是正確的。因此要證明 ``factorial(n)`` 的正確性就是要證明 ``factorial(n-1)`` 的正確性，同理，要證明 ``factorial(n-1)`` 的正確性就是要證明 ``factorial(n-2)`` 的正確性，依此類推下去，最後是：要證明 ``factorial(1)`` 的正確性就是要證明 ``factorial(0)`` 的正確性。
#. 而 ``factorial(0)`` 的正確性不依賴于別的函數調用，它就是程序中的一個小的分支 ``return 1;`` ，這個1是我們根據階乘的定義寫的，肯定是正確的。
#. 因此 ``factorial(1)`` 的實現是正確的，因此 ``factorial(2)`` 也正確，依此類推，最後 ``factorial(n)`` 也是正確的。

.. index:: s數學歸納法, Mathematical Induction

其實這就是在中學時學的數學歸納法（Mathematical Induction），用數學歸納法來證明只需要證明兩點：Base Case正確，遞推關係正確。

**寫遞歸函數時一定要記得寫Base Case** ，否則即使遞推關係正確，整個函數也不正確。如果 ``factorial`` 函數漏掉了Base Case：

.. code-block:: c
   :linenos:

   int factorial(int n)
   {
           int recurse = factorial(n-1);
           int result = n * recurse;
           return result;
   }

.. index:: w無窮遞歸, Infinite recursion

那麼這個函數就會永遠調用下去，直到操作系統為程序運行預留的棧空間耗盡程序崩潰（出段錯誤）為止，這稱為無窮遞歸（Infinite recursion）。

到目前為止我們只學習了全部C語法的一個小的子集，但是現在應該告訴你：這個子集是完備的，它本身就可以作為一門編程語言了，以後還要學習很多C語言特性，但以後要學的C語言特性只是為了使代碼寫起來更加簡便，卻不是必不可少的，現在學的這些已經完全覆蓋了 :ref:`intro.program` 講的五種基本操作了。有的讀者會說循環操作還沒講到呢，是的，循環在下一章才講，但有一個重要的結論就是 **遞歸和循環是等價的** ，用循環能做的事用遞歸都能做，反之亦然，事實上有的編程語言（比如某些LISP實現）只有遞歸而沒有循環。

計算機指令能做的所有事情就是數據存取、運算、測試和分支、循環（或遞歸），在計算機上運行高級語言寫的程序最終也要翻譯成指令，指令做不到的事情高級語言寫的程序肯定也做不到，雖然高級語言有豐富的語法特性，但也只是比指令寫起來更方便而已，能做的事情是一樣多的。那麼，為什麼計算機要設計成這樣？在設計計算機時怎麼想到計算機應該具備這幾樣基本操作，而不是更多或更少的操作？這些要歸功于早期的計算機科學家，例如Alan Turing，他們在計算機還沒有誕生的年代就從數學理論上為計算機的設計指明了方向。有興趣的讀者可以參考有關計算理論的教材，例如 [IATLC]_ 。

遞歸絶不只是為解決一些奇技淫巧的數學題 [#]_ 而想出來的招，它是計算機的精髓所在，也是編程語言的精髓所在。我們在學習C的語法時已經看到很多遞歸定義了，例如在 :ref:`func.mathfunc` 講過的語法規則中，“表達式”就是遞歸定義的::

   表達式 → 表達式(參數列表)
   參數列表 → 表達式, 表達式, ...

.. [#] 例如很多編程書都會舉例的漢諾塔問題，本書不打算再重複這個題目了。

再比如在 :ref:`cond.if` 講過的語法規則中，“語句”也是遞歸定義的::

   語句 → if (控製表達式) 語句

可見編譯器在解析我們寫的程序時一定也用了大量的遞歸，有關編譯器的實現原理可以參考 [DragonBook]_ 。

.. rubric:: 習題

#. 我們知道 ``main`` 函數不同於我們寫的其他函數，它是被操作系統調用的。但 ``main`` 函數真的就這麼特殊嗎？操作系統能調用它，我們自己就不能調用嗎？試着在自己寫的代碼中調用 ``main`` 函數，打破它的神話吧！

.. index:: z最大公約數, GCD, Greatest Common Divisor, Euclid算法, Euclidean Algorithm

#. 編寫遞歸函數求兩個正整數a和b的最大公約數（GCD，Greatest Common Divisor），使用Euclid算法（Euclidean Algorithm）：

   *  如果a除以b能整除，則最大公約數是b。
   *  否則，最大公約數等於b和a%b的最大公約數。

   Euclid算法是很容易證明的，請讀者自己證明一下為什麼這麼算就能算出最大公約數。最後，修改你的程序使之適用於所有整數，而不僅僅是正整數。

.. index:: Fibonacci

#. 編寫遞歸函數求Fibonacci數列的第n項，這個數列是這樣定義的::

      fib(0)=1
      fib(1)=1
      fib(n)=fib(n-1)+fib(n-2)

上面兩個看似毫不相干的問題之間卻有一個有意思的聯繫：

.. index:: Lamé's Theorem

Lamé定理（Lamé's Theorem）
    如果Euclid算法需要k步來計算兩個數的GCD，那麼這兩個數之中較小的一個必然大於等於Fibonacci數列的第k項。

感興趣的讀者可以參考 [SICP]_ 第1.2節的簡略證明。
