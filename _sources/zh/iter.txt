.. include:: <isonum.txt>

循環語句
=============

.. _iter.while:

while語句
-------------

.. index:: d迭代, Iteration

在 :ref:`func2.recurse` 中，我們介紹了用遞歸求n!的方法，其實每次遞歸調用都在重複做同一件事，就是把n乘到(n-1)!上然後把結果返回。雖說是重複，但每次做都稍微有一點區別（n的值不一樣），這種每次都有一點區別的重複工作稱為迭代（Iteration）。我們使用計算機的主要目的之一就是讓它做重複迭代的工作，因為把一件工作重複做成千上萬次而不出錯正是計算機最擅長的，也是人最不擅長的。雖然迭代用遞歸來做就夠了，但C語言提供了循環語句使迭代程序寫起來更方便。例如 ``factorial`` 用 ``while`` 語句可以寫成：

.. code-block:: c
   :linenos:

   int factorial(int n)
   {
           int result = 1;
           while (n > 0) {
                   result = result * n;
                   n = n - 1;
           }
           return result;
   }

和 ``if`` 語句類似， ``while`` 語句由一個控製表達式和一個子語句組成，子語句可以是由若干條語句和聲明組成的語句塊::

   語句 → while (控製表達式) 語句

.. index:: x循環, Loop

如果控製表達式的值為真，子語句就被執行，然後再次測試控製表達式的值，如果還是真，就把子語句再執行一遍，再測試控製表達式的值……這種控制流程稱為循環（Loop），子語句稱為循環體。如果某次測試控製表達式的值為假，就跳出循環執行後面的 ``return`` 語句，如果第一次測試控製表達式的值就是假，那麼直接跳到 ``return`` 語句，循環體一次都不執行。

.. index:: l累加器, Accumulator, x循環變數, Loop Variable

變數 ``result`` 在這個循環中的作用是累加器（Accumulator），把每次循環的中間結果累積起來，循環結束後得到的累積值就是最終結果，由於這個例子是用乘法來累積的，所以 ``result`` 的初值是1，如果用加法累積則 ``result`` 的初值應該是0。變數 ``n`` 是循環變數（Loop Variable），對於每次循環，在循環體中都要改變它的值，在控製表達式中都要測試它的值，這兩點合起來起到控制循環次數的作用，在這個例子中 ``n`` 的值是遞減的，也有些循環採用遞增的循環變數。這個例子有一定的典型性，累加器和循環變數這兩種模式在循環中都很常見。

可見，遞歸能解決的問題用循環也能解決，但解決問題的思路不一樣。用遞歸解決這個問題靠的是遞推關係n!=n·(n-1)!，用循環解決這個問題則更像是把這個公式展開了：n!=n·(n-1)·(n-2)·…·3·2·1。把公式展開了理解會更直觀一些，所以有些時候循環程序比遞歸程序更容易理解。但也有一些公式要展開是非常複雜甚至是不可能的，反倒是遞推關係更直觀一些，這種情況下遞歸程序比循環程序更容易理解。

.. index:: h函數式編程, Functional Programming, Imperative Programming

這個例子的遞歸和循環解法還有一點不同：看 :ref:`func2.factorial` ，在整個遞歸調用過程中，雖然分配和釋放了很多變數，但所有變數都只在初始化時賦值，沒有任何變數的值發生過改變，而上面的循環程序則通過對 ``n`` 和 ``result`` 這兩個變數多次賦值來達到同樣的目的。前一種思路稱為函數式編程（Functional Programming），而後一種思路稱為命令式編程（Imperative Programming）。函數式編程的“函數”類似於數學函數的概念，回顧一下 :ref:`func.mathfunc` 所講的，數學函數是沒有Side Effect的，而C語言的函數可以有Side Effect，比如在一個函數中修改某個全局變數的值就是一種Side Effect。在 :ref:`func.scope` 講過全局變數被多次賦值會給調試帶來困難，如果一個函數體很長，控制流程很複雜，那麼局部變數被多次賦值也會有同樣的問題。因此，不要以為“變數可以多次賦值”是天經地義的，有很多編程語言可以完全採用函數式編程的方式，避免Side Effect，例如LISP、Haskell、Erlang等。用C語言編程主要還是採用Imperative的方式，但要記住， **給變數多次賦值時要格外小心，在代碼中多次讀寫同一變數應該以一種一致的方式進行** 。所謂“一致的方式”是說應該有一套統一的規則，規定在一段代碼中哪裡會對某個全局變數賦值、哪裡會讀取它的值，比如在 :ref:`stdlib.errno` 會講到訪問 ``errno`` 的規則。

.. index:: w無限循環, s死循環, Infinite Loop

遞歸函數如果寫得不小心就會變成無窮遞歸，同樣道理，循環如果寫得不小心就會變成無限循環（Infinite Loop）或者叫死循環。如果 ``while`` 語句的控製表達式永遠為真就成了一個死循環，例如 ``while (1) {...}`` 。在寫循環時要小心檢查你寫的控製表達式有沒有可能取值為假，除非你故意寫死循環（有的時候這是必要的）。在上面的例子中，不管 ``n`` 一開始是幾，每次循環都會把 ``n`` 減掉1， ``n`` 越來越小最後必然等於0，所以控製表達式最後必然取值為假，但如果把 ``n = n - 1;`` 這句漏掉就成了死循環。有時候是不是死循環並不是那麼一目瞭然，例如：

.. code-block:: c
   :linenos:

   while (n != 1) {
           if (n % 2 == 0) {
                   n = n / 2;
           } else {
                   n = n * 3 + 1;
           }
   }

如果 ``n`` 為正整數，這個循環能跳出來嗎？循環體所做的事情是：如果 ``n`` 是偶數，就把 ``n`` 除以2，如果 ``n`` 是奇數，就把 ``n`` 乘3加1。一般來說循環變數要麼遞增要麼遞減，可是這個例子中的 ``n`` 一會兒變大一會兒變小，最終會不會變成1呢？可以找個數試試，例如一開始 ``n`` 等於7，每次循環後 ``n`` 的值依次是：7、22、11、34、17、52、26、13、40、20、10、5、16、8、4、2、1－－最後 ``n`` 確實等於1了。讀者可以再試幾個數都是如此，但無論試多少個數也不能代替證明，這個循環有沒有可能對某些正整數 ``n`` 是死循環呢？其實這個例子只是給讀者提提興趣，同時提醒讀者寫循環時要有意識地檢查控製表達式。至于這個循環有沒有可能是死循環，這是著名的3x+1問題，目前世界上還無人能證明。許多世界難題都是這樣的：問題的描述無比簡單，連小學生都能看懂，但證明卻無比困難。

.. rubric:: 習題

#. 用循環解決 :ref:`func2.recurse` 的習題，體會遞歸和循環這兩種不同的思路。

#. 編寫程序數一下1到100的所有整數中出現多少次數字9。在寫程序之前先把這些問題考慮清楚：
   #. 這個問題中的循環變數是什麼？
   #. 這個問題中的累加器是什麼？用加法還是用乘法累積？
   #. 在 :ref:`cond.ifelse` 的習題中寫過取一個整數的個位和十位的表達式，這兩個表達式怎樣用到本程序中？

#. 下面的循環語句執行結果是什麼？

   .. code-block:: c
      :linenos:

      while (1) {
              int i = 0;
              printf("%d\n", i);
              i = i + 1;
      }

do/while語句
-------------------

``do/while`` 語句的語法是::

   語句 → do 語句 while (控製表達式);

``while`` 語句先測試控製表達式的值再執行循環體，而 ``do/while`` 語句先執行循環體再測試控製表達式的值。如果控製表達式的值一開始就是假， ``while`` 語句的循環體一次都不執行，而 ``do/while`` 語句的循環體仍然要執行一次再跳出循環。其實只要有 ``while`` 循環就足夠了， ``do/while`` 循環和後面要講的 ``for`` 循環都可以改寫成 ``while`` 循環，只不過有些情況下用 ``do/while`` 或 ``for`` 循環寫起來更簡便，代碼更易讀。

上一節的 ``factorial`` 函數也可以改用 ``do/while`` 循環來寫：

.. code-block:: c
   :linenos:

   int factorial(int n)
   {
           int result = 1;
           int i = 1;
           do {
                   result = result * i;
                   i = i + 1;
           } while (i <= n);

           return result;
   }

寫循環一定要注意循環即將結束時控製表達式的臨界條件是否準確，上面的循環控制條件如果寫成 ``i < n`` 就錯了，當 ``i == n`` 時跳出循環，最後的結果中就少乘了一個 ``n`` 。雖然變數名應該儘可能起得有意義一些，不過用 ``i`` 、 ``j`` 、 ``k`` 給循環變數起名倒是很常見的。

for語句
--------------

前兩節我們在 ``while`` 和 ``do/while`` 循環中使用循環變數，其實使用循環變數最常見的是 ``for`` 循環這種形式。 ``for`` 語句的語法是::

   語句 → for (控製表達式1; 控製表達式2; 控製表達式3) 語句

如果不考慮循環體中包含 ``continue`` 語句的情況（稍後介紹 ``continue`` 語句），這個 ``for`` 循環等價于下面的 ``while`` 循環::

   控製表達式1;
   while (控製表達式2) {
           語句
           控製表達式3;
   }

從這種等價形式來看，控製表達式1和3都可以為空，但控製表達式2是必不可少的，例如 ``for (;1;) {...}`` 等價于 ``while (1) {...}`` 死循環。C語言規定，如果控製表達式2為空，則認為控製表達式2的值為真，因此死循環也可以寫成 ``for (;;) {...}`` 。

上一節 ``do/while`` 循環的例子可以改寫成 ``for`` 循環：

.. code-block:: c
   :linenos:

   int factorial(int n)
   {
           int result = 1;
           int i;
           for(i = 1; i <= n; ++i)
                   result = result * i;
           return result;
   }

.. index:: q首碼自增運算符, Prefix Increment Operator, q首碼自減運算符, Prefix Decrement Operator

其中 ``++i`` 這個表達式相當於 ``i = i + 1`` [#]_ ，++稱為首碼自增運算符（Prefix Increment Operator）。類似地，--稱為首碼自減運算符（Prefix Decrement Operator） [#]_ ， ``--i`` 相當於 ``i = i - 1`` 。如果把 ``++i`` 這個表達式看作一個函數調用，除了傳入一個參數 ``i`` 返回一個值（返回值等於參數值加1）之外，還產生一個Side Effect，就是把變數 ``i`` 的值增加了1。

.. [#] 這兩種寫法在語義上稍有區別，詳見 :ref:`op.compoundassign` 。

.. [#] increment和decrement這兩個詞很有意思，大多數字典都說它們是名詞，但經常被當成動詞用，在計算機術語中，它們當動詞用應該理解為increase by one和decrease by one。現代英語中很多原本是名詞的都被當成動詞用，字典都跟不上時代了，再比如transition也是如此。

.. index:: h尾碼自增運算符, Postfix Increment Operator, h尾碼自減運算符, Postfix Decrement Operator

++和 |hyphen|\ |hyphen| 運算符也可以用在變數後面，例如 ``i++`` 和 ``i--`` ，為了和首碼運算符區別，這兩個運算符稱為尾碼自增運算符（Postfix Increment Operator）和尾碼自減運算符（Postfix Decrement Operator）。如果把 ``i++`` 這個表達式看作一個函數調用，傳入一個參數 ``i`` 返回一個值，返回值就等於參數值（而不是參數值加1），此外也產生一個Side Effect，就是把變數 ``i`` 的值增加了1，它和 ``++i`` 的區別就在於返回值不同。同理， ``--i`` 返回 ``i`` 減1之後的值，而 ``i--`` 返回 ``i`` 減1之前的值，但這兩個表達式都產生同樣的Side Effect，就是把變數 ``i`` 的值減了1。

使用++和 |hyphen|\ |hyphen| 運算符會使程序更加簡潔，但也會影響程序的可讀性， [K&R]_ 中的示例代碼大量運用++、 |hyphen|\ |hyphen| 和其他表達式的組合使得代碼非常簡潔。為了讓初學者循序漸進，在接下來的幾章中++、 |hyphen|\ |hyphen| 運算符總是單獨組成一個表達式而不跟其他表達式組合，從 :doc:`sortsearch` 開始將採用 [K&R]_ 的簡潔風格。

我們看一個有意思的問題： ``a+++++b`` 這個表達式如何理解？應該理解成 ``a++ ++ +b`` 還是 ``a++ + ++b`` ，還是 ``a + ++ ++b`` 呢？應該按第一種方式理解。編譯的過程分為詞法解析、語法解析、語義檢查三個階段，我們分別來分析：

#. 在詞法解析階段，編譯器總是從前到後找最長的合法Token。把這個表達式從前到後解析，變數名 ``a`` 是一個Token， ``a`` 後面有兩個以上的+號，在C語言中一個+號是合法的Token（可以是加法運算符或正號），兩個+號也是合法的Token（可以是自增運算符），根據最長匹配原則，編譯器絶不會止步于一個+號，而一定會把兩個+號當作一個Token。
#. 再往後解析仍然有兩個以上的+號，所以又是一個++運算符。
#. 再往後解析只剩一個+號了，是加法運算符。
#. 再往後解析是變數名 ``b`` 。
#. 詞法解析之後進入下一階段語法解析， ``a`` 是一個表達式， ``表達式++`` 還是表達式， 再 ``表達式++`` 還是表達式，再 ``表達式+b`` 還是表達式，語法上沒有問題。
#. 最後編譯器會做一些基本的語義檢查，這時就有問題了：++運算符要求操作數能做左值， ``a`` 能做左值所以 ``a++`` 沒問題，但表達式 ``a++`` 的值只能做右值，不能再++了，所以最終編譯器會報錯。

C99規定了一種新的 ``for`` 循環語法（其實是從C++借鑒的），在“控製表達式1”的位置可以有變數定義。例如上例的循環變數 ``i`` 可以只在 ``for`` 循環中定義：

.. code-block:: c
   :linenos:

   int factorial(int n)
   {
           int result = 1;
           for(int i = 1; i <= n; i++)
                   result = result * i;
           return result;
   }

如果這樣定義，那麼變數 ``i`` 只是 ``for`` 循環中的局部變數而不是整個函數的局部變數，相當於 :ref:`cond.if` 講過的語句塊中的局部變數，在循環結束後就不能再使用 ``i`` 這個變數了，注意這個程序用 :command:`gcc` 編譯時必須加上選項 :option:`-std=c99` [#]_ 。

.. [#] 本書介紹的C99新特性有很多是不需要在編譯時加 :option:`-std=c99` 選項的，例如在 :ref:`expr.helloworld` 講過的C++風格的 ``//`` 註釋，還有在 :ref:`func.deffunction` 講過的“在函數體內語句和聲明可以按任意順序排列”，使用這些特性的代碼在編譯時都不需要加 :option:`-std=c99` 選項，這是為什麼呢？因為C標準更新得太慢，有些新特性在C99標準還沒出來之前 :command:`gcc` 就已經實現了，有些已經存在了好多年了，所以在 :command:`gcc` 看來這不算什麼新特性，沒什麼好大驚小怪的。

break和continue語句
------------------------

.. index:: s素數, Prime

在 :ref:`cond.switch` 中我們見到了 ``break`` 語句的一種用法，用來跳出 ``switch`` 語句塊，這個語句也可以用來跳出循環體。 ``continue`` 語句也會終止當前循環，和 ``break`` 語句不同的是， ``continue`` 語句終止當前循環後又回到循環體的開頭準備執行下一次循環。對於 ``while`` 循環和 ``do/while`` 循環，執行 ``continue`` 語句之後測試控製表達式，如果值為真則繼續執行下一次循環；對於 ``for`` 循環，執行 ``continue`` 語句之後首先計算“控製表達式3”，然後測試“控製表達式2”，如果值為真則繼續執行下一次循環。例如下面的代碼打印1到100之間的素數（Prime）：

.. code-block:: c
   :linenos:

   #include <stdio.h>

   int is_prime(int n)
   {
           int i;
           for (i = 2; i < n; i++)
                   if (n % i == 0)
                           break;
           if (i == n)
                   return 1;
           else
                   return 0;
   }

   int main(void)
   {
           int i;
           for (i = 1; i <= 100; i++) {
                   if (!is_prime(i))
                           continue;
                   printf("%d\n", i);
           }
           return 0;
   }

``is_prime`` 函數從2到 ``n - 1`` 依次檢查有沒有能被 ``n`` 整除的數，如果有就說明 ``n`` 不是素數，立刻跳出循環而不執行 ``i++`` 。因此，如果 ``n`` 不是素數，則循環結束後 ``i`` 一定小於 ``n`` ，如果 ``n`` 是素數，則循環結束後 ``i`` 一定等於 ``n`` 。注意檢查臨界條件：2應該是素數，如果 ``n`` 是2，則循環體一次也不執行，但 ``i`` 的初值就是2，也等於 ``n`` ，在程序中也判定為素數。其實沒有必要從2一直檢查到n-1，只要從2檢查到⌊sqrt(n)⌋，如果全都不能整除就足以證明n是素數了，請讀者想一想為什麼。

在主程序中，從1到100依次檢查每個數是不是素數，如果不是素數，並不直接跳出循環，而是 ``i++`` 後繼續執行下一次循環，因此用 ``continue`` 語句。注意主程序的局部變數 ``i`` 和 ``is_prime`` 中的局部變數 ``i`` 是不同的兩個變數，其實在調用 ``is_prime`` 函數時主程序的局部變數 ``i`` 和 ``is_prime`` 函數的參數 ``n`` 的值相等。

.. rubric:: 習題

#. 求素數這個程序只是為了說明 ``break`` 和 ``continue`` 的用法才這麼寫的，其實完全可以不用 ``break`` 和 ``continue`` ，請讀者修改一下控制流程，去掉 ``break`` 和 ``continue`` 而保持功能不變。
#. 上一節講過怎樣把 ``for`` 循環改寫成等價的 ``while`` 循環，但也提到如果循環體中有 ``continue`` 語句這兩種形式就不等價了，想一想為什麼不等價了？

嵌套循環
--------------

上一節求素數的例子在循環中調用一個函數，而那個函數裡面又有一個循環，這其實是一種嵌套循環。如果把那個函數的代碼拿出來寫就更清楚了：

.. code-block:: c
   :linenos:

   #include <stdio.h>

   int main(void)
   {
           int i, j;
           for (i = 1; i <= 100; i++) {
                   for (j = 2; j < i; j++)
                           if (i % j == 0)
                                   break;
                   if (j == i)
                           printf("%d\n", i);
           }
           return 0;
   }

現在內循環的循環變數就不能再用 ``i`` 了，而是改用 ``j`` ，原來程序中 ``is_prime`` 函數的參數 ``n`` 現在直接用 ``i`` 代替。在有多層循環或 ``switch`` 嵌套的情況下， ``break`` 只能跳出最內層的循環或 ``switch`` ， ``continue`` 也只能終止最內層循環並回到該層循環的開頭。

用循環也可以打印表格式的數據，比如打印小九九乘法表：

.. code-block:: c
   :linenos:

   #include <stdio.h>

   int main(void)
   {
           int i, j;
           for (i=1; i<=9; i++) {
                   for (j=1; j<=9; j++)
                           printf("%d  ", i*j);
                   printf("\n");
           }
           return 0;
   }


內循環每次打印一個數，數與數之間用兩個空格隔開，外循環每次打印一行。結果如下::

   1  2  3  4  5  6  7  8  9  
   2  4  6  8  10  12  14  16  18  
   3  6  9  12  15  18  21  24  27  
   4  8  12  16  20  24  28  32  36  
   5  10  15  20  25  30  35  40  45  
   6  12  18  24  30  36  42  48  54  
   7  14  21  28  35  42  49  56  63  
   8  16  24  32  40  48  56  64  72  
   9  18  27  36  45  54  63  72  81

由於乘法結果有一位數的也有兩位數的，這個表格很不整齊，如果把打印語句改為 ``printf("%d\t", i*j);`` 就整齊了，Tab字元（製表符）就是這樣得名的。

.. rubric:: 習題

#. 本節打印小九九的例子打印出來的結果有一半數據是重複的，比如8×9跟9×8的結果一樣。請修改程序打印這樣的小九九::

      1
      2       4
      3       6       9
      4       8       12      16
      5       10      15      20      25
      6       12      18      24      30      36
      7       14      21      28      35      42      49
      8       16      24      32      40      48      56      64
      9       18      27      36      45      54      63      72      81

#. 編寫函數 ``diamond`` 打印一個菱形。如果調用 ``diamond(3, '*')`` 則打印::

              *
      *       *       *
              *

   如果調用 ``diamond(5, '+')`` 則打印::

                      +
              +       +       +
      +       +       +       +       +
              +       +       +
                      +

   如果用偶數做參數則打印錯誤提示。

goto語句和標號
-------------------------

分支、循環都講完了，還剩下最後一種影響控制流程的語句沒講，就是 ``goto`` 語句，實現無條件跳轉。我們知道 ``break`` 只能跳出最內層的循環，如果在一個嵌套循環中遇到某個錯誤條件需要立即跳出最外層循環做出錯處理，就可以用 ``goto`` 語句，例如：

.. code-block:: c
   :linenos:

   for (...)
           for (...) {
                   ...
                   if (出現錯誤條件)
                           goto error;
           }
   error:
           出錯處理;

.. index:: b標號, Label

這裡的 ``error:`` 叫做標號（Label），任何語句前面都可以加若干個標號，標號的命名也要遵循標識符的命名規則。

``goto`` 語句過于強大了，從程序中的任何地方都可以無條件跳轉到任何其他地方，只要在那個地方定義一個標號就行，唯一的限制是 ``goto`` 只能跳轉到同一個函數中的某個標號處，而不能跳到別的函數中 [#]_ 。 **濫用 ``goto`` 語句會使程序的控制流程非常複雜，可讀性很差。** 著名的計算機科學家Edsger W. Dijkstra最早指出編程語言中 ``goto`` 語句的危害，提倡取消 ``goto`` 語句。 ``goto`` 語句不是必須存在的，顯然可以用別的辦法替代，比如上面的代碼段可以改寫為：

.. [#] C標準庫函數 ``setjmp`` 和 ``longjmp`` 配合起來可以實現函數間的跳轉，但只能從被調用的函數跳回到它的直接或間接調用者（同時從棧空間彈出一個或多個棧幀），而不能從一個函數跳轉到另一個和它毫不相干的函數中。 ``setjmp/longjmp`` 函數主要也是用於出錯處理，比如函數A調用函數B，函數B調用函數C，如果在C中出現某個錯誤條件，使得函數B和C繼續執行下去都沒有意義了，可以利用 ``setjmp/longjmp`` 機制快速返回到函數A做出錯處理，本書不詳細介紹這種機制，有興趣的讀者可參考 [APUE2e]_ 的7.10節和10.15節。

.. code-block:: c
   :linenos:

   int cond = 0; /* bool variable indicating error condition */
   for (...) {
           for (...) {
                   ...
                   if (出現錯誤條件) {
                           cond = 1;
                           break;
                   }
           }
           if (cond)
                   break;
   }
   if (cond)
           出錯處理;

通常 ``goto`` 語句只用於這種場合，一個函數中任何地方出現了錯誤條件都可以立即跳轉到函數末尾做出錯處理（例如釋放先前分配的資源、恢復先前改動過的全局變數等），處理完之後函數返回。比較用 ``goto`` 和不用 ``goto`` 的兩種寫法，用 ``goto`` 語句還是方便很多。但是除此之外，在任何其他場合都不要輕易考慮使用 ``goto`` 語句。有些編程語言（如C++）中有異常（Exception）處理的語法，可以代替 ``goto`` 和 ``setjmp/longjmp`` 的這種用法。

.. index:: :號, Colon

回想一下我們在 :ref:`cond.switch` 學過的語法， ``case`` 和 ``default`` 後面也要跟:號（Colon），事實上它們是兩種特殊的標號。和標號有關的語法規則如下::

   語句 → 標識符: 語句
   語句 → case 整型常量表達式: 語句
   語句 → default: 語句

反覆應用這些語法規則進行組合，可以在一條語句前面添加多個標號，例如在 :ref:`cond.switch2` 的代碼中，有些語句前面有多個 ``case`` 標號。現在我們再看 ``switch`` 語句的格式::

   switch (控製表達式) {
   case 整型常量表達式： 零或多條語句
   case 整型常量表達式： 零或多條語句
   ...
   default： 零或多條語句
   }

{}裡面是一組語句列表，其中每個分支的第一條語句帶有 ``case`` 或 ``default`` 標號，從語法上來說， ``switch`` 的語句塊和其他分支、循環結構的語句塊沒有本質區別，因此前面的語法規則可以改寫為::

   語句 → switch (控製表達式) 語句
   語句 → { 語句列表 }

我們知道{}中的語句列表不僅可以包含語句，還可以包含聲明，而先前的語法規則並沒有體現出這一點，因此改寫後的語法規則更為準確。但要注意，只有語句前面才能帶標號，聲明前面不能帶標號，例如這樣寫是錯的：

.. code-block:: c
   :linenos:

   case 1: int i = 10;

但這樣寫是對的：

.. code-block:: c
   :linenos:

   case 1: { int i = 10; }

這樣寫也是對的：

.. code-block:: c
   :linenos:

   case 1: ; int i = 10;

再比如這樣的 ``switch`` 語句：

.. code-block:: c
   :linenos:

   switch (n) {
           int i = 10;
   case 1:
           printf("%d\n", i * 1);
           break;
   case 2:
           printf("%d\n", i * 2);
           break;
   }

這段代碼從語法上看是對的，從語義上看卻有一個陷阱。變數 ``i`` 在 ``switch`` 語句塊中定義，但並不會初始化成10，因為不管 ``n`` 的值是幾，進入 ``switch`` 語句塊都會跳過給 ``i`` 做初始化的指令，從某一個 ``case`` 標號開始執行。

.. rubric:: 習題

#. 以下代碼編譯沒有問題，但運行結果卻和預期不符（不能打印出 ``other number`` ），請分析原因。（提示：注意關鍵字的拼寫）

   .. code-block:: c
      :linenos:

      int n = 3;
      switch (n) {
      case 1:
              printf("1\n");
              break;
      case 2:
              printf("2\n");
              break;
      defau1t:
              printf("other number\n");
      }

#. 請在網上查找有關Duff's Device的資料，Duff's Device是一段很有意思的代碼，正是利用“ ``switch`` 的語句塊和循環結構的語句塊沒有本質區別”這一點實現了一個巧妙的代碼優化。
