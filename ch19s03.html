<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>3. 變數的存儲佈局</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch19.html" title="第 19 章 彙編與C之間的關係" /><link rel="prev" href="ch19s02.html" title="2. main函數和啟動常式" /><link rel="next" href="ch19s04.html" title="4. 結構體和聯合體" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. 變數的存儲佈局</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch19s02.html">上一頁</a> </td><th width="60%" align="center">第 19 章 彙編與C之間的關係</th><td width="20%" align="right"> <a accesskey="n" href="ch19s04.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2777491"></a>3. 變數的存儲佈局</h2></div></div></div><p>首先看下面的例子：</p><div class="example"><a id="id2777482"></a><p class="title"><b>例 19.2. 研究變數的存儲佈局</b></p><div class="example-contents"><pre class="programlisting">#include &lt;stdio.h&gt;

const int A = 10;
int a = 20;
static int b = 30;
int c;

int main(void)
{
	static int a = 40;
	char b[] = "Hello world";
	register int c = 50;

	printf("Hello world %d\n", c);

	return 0;
}</pre></div></div><br class="example-break" /><p>我們在全局作用域和<code class="literal">main</code>函數的局部作用域各定義了一些變數，並且引入一些新的關鍵字<code class="literal">const</code>、<code class="literal">static</code>、<code class="literal">register</code>來修飾變數，那麼這些變數的存儲空間是怎麼分配的呢？我們編譯之後用<code class="literal">readelf</code>命令看它的符號表，瞭解各變數的地址分佈。注意在下面的清單中我把符號表按地址從低到高的順序重新排列了，並且只截取我們關心的那幾行。</p><pre class="screen">$ gcc main.c -g
$ readelf -a a.out
...
    68: 08048540     4 OBJECT  GLOBAL DEFAULT   15 A
    69: 0804a018     4 OBJECT  GLOBAL DEFAULT   23 a
    52: 0804a01c     4 OBJECT  LOCAL  DEFAULT   23 b
    53: 0804a020     4 OBJECT  LOCAL  DEFAULT   23 a.1589
    81: 0804a02c     4 OBJECT  GLOBAL DEFAULT   24 c
...</pre><p>變數A用<code class="literal">const</code>修飾，表示A是隻讀的，不可修改，它被分配的地址是0x8048540，從<code class="literal">readelf</code>的輸出可以看到這個地址位於<code class="literal">.rodata</code>段：</p><pre class="screen">Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
...
  [13] .text             PROGBITS        08048360 000360 0001bc 00  AX  0   0 16
...
  [15] .rodata           PROGBITS        08048538 000538 00001c 00   A  0   0  4
...
  [23] .data             PROGBITS        0804a010 001010 000014 00  WA  0   0  4
  [24] .bss              NOBITS          0804a024 001024 00000c 00  WA  0   0  4
...</pre><p>它在檔案中的地址是0x538~0x554，我們用<code class="literal">hexdump</code>命令看看這個段的內容：</p><pre class="screen">$ hexdump -C a.out
...
00000530  5c fe ff ff 59 5b c9 c3  03 00 00 00 01 00 02 00  |\...Y[..........|
00000540  0a 00 00 00 48 65 6c 6c  6f 20 77 6f 72 6c 64 20  |....Hello world |
00000550  25 64 0a 00 00 00 00 00  00 00 00 00 00 00 00 00  |%d..............|
...</pre><p>其中0x540地址處的<code class="literal">0a 00 00 00</code>就是變數A。我們還看到程序中的字元串字面值<code class="literal">"Hello world %d\n"</code>分配在<code class="literal">.rodata</code>段的末尾，在<a class="xref" href="ch08s04.html#array.string">第 4 節 “字元串”</a>說過字元串字面值是隻讀的，相當於在全局作用域定義了一個<code class="literal">const</code>數組：</p><pre class="programlisting">const char helloworld[] = {'H', 'e', 'l', 'l', 'o', ' ',
		 	'w', 'o', 'r', 'l', 'd', ' ', '%', 'd', '\n', '\0'};</pre><p>程序加載運行時，<code class="literal">.rodata</code>段和<code class="literal">.text</code>段通常合併到一個Segment中，操作系統將這個Segment的頁面只讀保護起來，防止意外的改寫。這一點從<code class="literal">readelf</code>的輸出也可以看出來：</p><pre class="screen"> Section to Segment mapping:
  Segment Sections...
   00     
   01     .interp 
   02     .interp .note.ABI-tag .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame 
   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss 
   04     .dynamic 
   05     .note.ABI-tag 
   06     
   07     .ctors .dtors .jcr .dynamic .got </pre><p>注意，像<code class="literal">A</code>這種<code class="literal">const</code>變數在定義時必須初始化。因為只有初始化時才有機會給它一個值，一旦定義之後就不能再改寫了，也就是不能再賦值了。</p><p>從上面<code class="literal">readelf</code>的輸出可以看到<code class="literal">.data</code>段從地址0x804a010開始，長度是0x14，也就是到地址0x804a024結束。在<code class="literal">.data</code>段中有三個變數，<code class="literal">a</code>，<code class="literal">b</code>和<code class="literal">a.1589</code>。</p><p><code class="literal">a</code>是一個<code class="literal">GLOBAL</code>的符號，而<code class="literal">b</code>被<code class="literal">static</code>關鍵字修飾了，導致它成為一個<code class="literal">LOCAL</code>的符號，所以<code class="literal">static</code>在這裡的作用是聲明<code class="literal">b</code>這個符號為<code class="literal">LOCAL</code>的，不被連結器處理，在下一章我們會看到，如果把多個目標檔案連結在一起，<code class="literal">LOCAL</code>的符號只能在某一個目標檔案中定義和使用，而不能定義在一個目標檔案中卻在另一個目標檔案中使用。一個函數定義前面也可以用<code class="literal">static</code>修飾，表示這個函數名符號是<code class="literal">LOCAL</code>的。</p><p>還有一個<code class="literal">a.1589</code>是什麼呢？它就是<code class="literal">main</code>函數中的<code class="literal">static int a</code>。函數中的<code class="literal">static</code>變數不同於以前我們講的局部變數，它並不是在調用函數時分配，在函數返回時釋放，而是像全局變數一樣靜態分配，所以用“<span class="quote">static</span>”（靜態）這個詞。另一方面，函數中的<code class="literal">static</code>變數的作用域和以前講的局部變數一樣，只在函數中起作用，比如<code class="literal">main</code>函數中的<code class="literal">a</code>這個變數名只在<code class="literal">main</code>函數中起作用，在別的函數中說變數<code class="literal">a</code>就不是指它了，所以編譯器給它的符號名加了一個尾碼，變成<code class="literal">a.1589</code>，以便和全局變數<code class="literal">a</code>以及其它函數的變數<code class="literal">a</code>區分開。</p><p><code class="literal">.bss</code>段從地址0x804a024開始（緊挨着<code class="literal">.data</code>段），長度為0xc，也就是到地址0x804a030結束。變數<code class="literal">c</code>位於這個段。從上面的<code class="literal">readelf</code>輸出可以看到，<code class="literal">.data</code>和<code class="literal">.bss</code>在加載時合併到一個Segment中，這個Segment是可讀可寫的。<code class="literal">.bss</code>段和<code class="literal">.data</code>段的不同之處在於，<code class="literal">.bss</code>段在檔案中不占存儲空間，在加載時這個段用0填充。所以我們在<a class="xref" href="ch03s04.html#func.localvar">第 4 節 “全局變數、局部變數和作用域”</a>講過，全局變數如果不初始化則初值為0，同理可以推斷，<code class="literal">static</code>變數（不管是函數里的還是函數外的）如果不初始化則初值也是0，也分配在<code class="literal">.bss</code>段。</p><p>現在還剩下函數中的<code class="literal">b</code>和<code class="literal">c</code>這兩個變數沒有分析。上一節我們講過函數的參數和局部變數是分配在棧上的，<code class="literal">b</code>是數組也一樣，也是分配在棧上的，我們看<code class="literal">main</code>函數的反彙編代碼：</p><pre class="screen">$ objdump -dS a.out
...
        char b[]="Hello world";
 8048430:       c7 45 ec 48 65 6c 6c    movl   $0x6c6c6548,-0x14(%ebp)
 8048437:       c7 45 f0 6f 20 77 6f    movl   $0x6f77206f,-0x10(%ebp)
 804843e:       c7 45 f4 72 6c 64 00    movl   $0x646c72,-0xc(%ebp)
        register int c = 50;
 8048445:       b8 32 00 00 00          mov    $0x32,%eax

        printf("Hello world %d\n", c);
 804844a:       89 44 24 04             mov    %eax,0x4(%esp)
 804844e:       c7 04 24 44 85 04 08    movl   $0x8048544,(%esp)
 8048455:       e8 e6 fe ff ff          call   8048340 &lt;printf@plt&gt;
...</pre><p>可見，給<code class="literal">b</code>初始化用的這個字元串<code class="literal">"Hello world"</code>並沒有分配在<code class="literal">.rodata</code>段，而是直接寫在指令裡了，通過三條<code class="literal">movl</code>指令把12個位元組寫到棧上，這就是<code class="literal">b</code>的存儲空間，如下圖所示。</p><div class="figure"><a id="id2778223"></a><p class="title"><b>圖 19.4. 數組的存儲佈局</b></p><div class="figure-contents"><div><img src="images/asmc.array.png" alt="數組的存儲佈局" /></div></div></div><br class="figure-break" /><p>注意，雖然棧是從高地址向低地址增長的，但數組總是從低地址向高地址排列的，按從低地址到高地址的順序依次是<code class="literal">b[0]</code>、<code class="literal">b[1]</code>、<code class="literal">b[2]</code>……這樣，</p><div class="literallayout"><p>數組元素<code class="literal">b[n]</code>的地址 = 數組的基地址（<code class="literal">b</code>做右值就表示這個基地址） + n × 每個元素的位元組數</p></div><p>當n=0時，元素<code class="literal">b[0]</code>的地址就是數組的基地址，因此數組下標要從0開始而不是從1開始。</p><p>變數<code class="literal">c</code>並沒有在棧上分配存儲空間，而是直接存在<code class="literal">eax</code>寄存器裡，後面調用<code class="literal">printf</code>也是直接從<code class="literal">eax</code>寄存器裡取出<code class="literal">c</code>的值當參數壓棧，這就是<code class="literal">register</code>關鍵字的作用，指示編譯器儘可能分配一個寄存器來存儲這個變數。我們還看到調用<code class="literal">printf</code>時對於<code class="literal">"Hello world %d\n"</code>這個參數壓棧的是它在<code class="literal">.rodata</code>段中的首地址，而不是把整個字元串壓棧，所以在<a class="xref" href="ch08s04.html#array.string">第 4 節 “字元串”</a>中說過，字元串在使用時可以看作數組名，如果做右值則表示數組首元素的地址（或者說指向數組首元素的指針），我們以後講指針還要繼續討論這個問題。</p><p>以前我們用“<span class="quote">全局變數</span>”和“<span class="quote">局部變數</span>”這兩個概念，主要是從作用域上區分的，現在看來用這兩個概唸給變數分類太籠統了，需要進一步細分。我們總結一下相關的C語法。</p><p>作用域（Scope）<a id="id2778383" class="indexterm"></a>這個概念適用於所有標識符，而不僅僅是變數，C語言的作用域分為以下幾類：</p><div class="itemizedlist"><ul type="disc"><li><p>函數作用域（Function Scope）<a id="id2778399" class="indexterm"></a>，標識符在整個函數中都有效。只有語句標號屬於函數作用域。標號在函數中不需要先聲明後使用，在前面用一個<code class="literal">goto</code>語句也可以跳轉到後面的某個標號，但僅限于同一個函數之中。</p></li><li><p>檔案作用域（File Scope）<a id="id2778421" class="indexterm"></a>，標識符從它聲明的位置開始直到這個程序檔案<sup>[<a id="id2778429" href="#ftn.id2778429" class="footnote">30</a>]</sup>的末尾都有效。例如上例中<code class="literal">main</code>函數外面的<code class="literal">A</code>、<code class="literal">a</code>、<code class="literal">b</code>、<code class="literal">c</code>，還有<code class="literal">main</code>也算，<code class="literal">printf</code>其實是在<code class="literal">stdio.h</code>中聲明的，被包含到這個程序檔案中了，所以也算檔案作用域的。</p></li><li><p>塊作用域（Block Scope）<a id="id2778553" class="indexterm"></a>，標識符位於一對{}括號中（函數體或語句塊），從它聲明的位置開始到右}括號之間有效。例如上例中<code class="literal">main</code>函數里的<code class="literal">a</code>、<code class="literal">b</code>、<code class="literal">c</code>。此外，函數定義中的形參也算塊作用域的，從聲明的位置開始到函數末尾之間有效。</p></li><li><p>函數原型作用域（Function Prototype Scope）<a id="id2778593" class="indexterm"></a>，標識符出現在函數原型中，這個函數原型只是一個聲明而不是定義（沒有函數體），那麼標識符從聲明的位置開始到在這個原型末尾之間有效。例如<code class="literal">int foo(int a, int b);</code>中的<code class="literal">a</code>和<code class="literal">b</code>。</p></li></ul></div><p>對屬於同一命名空間（Name Space）<a id="id2778626" class="indexterm"></a>的重名標識符，內層作用域的標識符將覆蓋外層作用域的標識符，例如局部變數名在它的函數中將覆蓋重名的全局變數。命名空間可分為以下幾類：</p><div class="itemizedlist"><ul type="disc"><li><p>語句標號單獨屬於一個命名空間。例如在函數中局部變數和語句標號可以重名，互不影響。由於使用標號的語法和使用其它標識符的語法都不一樣，編譯器不會把它和別的標識符弄混。</p></li><li><p><code class="literal">struct</code>，<code class="literal">enum</code>和<code class="literal">union</code>（下一節介紹<code class="literal">union</code>）的類型Tag屬於一個命名空間。由於Tag前面總是帶<code class="literal">struct</code>，<code class="literal">enum</code>或<code class="literal">union</code>關鍵字，所以編譯器不會把它和別的標識符弄混。</p></li><li><p><code class="literal">struct</code>和<code class="literal">union</code>的成員名屬於一個命名空間。由於成員名總是通過<code class="literal">.</code>或<code class="literal">-&gt;</code>運算符來訪問而不會單獨使用，所以編譯器不會把它和別的標識符弄混。</p></li><li><p>所有其它標識符，例如變數名、函數名、宏定義、<code class="literal">typedef</code>的類型名、<code class="literal">enum</code>成員等等都屬於同一個命名空間。如果有重名的話，宏定義覆蓋所有其它標識符，因為它在預處理階段而不是編譯階段處理，除了宏定義之外其它幾類標識符按上面所說的規則處理，內層作用域覆蓋外層作用域。</p></li></ul></div><p>標識符的連結屬性（Linkage）<a id="id2778755" class="indexterm"></a>有三種：</p><div class="itemizedlist"><ul type="disc"><li><p>外部連結（External Linkage）<a id="id2778771" class="indexterm"></a>，如果最終的執行檔由多個程序檔案連結而成，一個標識符在任意程序檔案中即使聲明多次也都代表同一個變數或函數，則這個標識符具有External Linkage。具有External Linkage的標識符編譯後在符號表中是<code class="literal">GLOBAL</code>的符號。例如上例中<code class="literal">main</code>函數外面的<code class="literal">a</code>和<code class="literal">c</code>，<code class="literal">main</code>和<code class="literal">printf</code>也算。</p></li><li><p>內部連結（Internal Linkage）<a id="id2778824" class="indexterm"></a>，如果一個標識符在某個程序檔案中即使聲明多次也都代表同一個變數或函數，則這個標識符具有Internal Linkage。例如上例中<code class="literal">main</code>函數外面的<code class="literal">b</code>。如果有另一個<code class="literal">foo.c</code>程序和<code class="literal">main.c</code>連結在一起，在<code class="literal">foo.c</code>中也聲明一個<code class="literal">static int b;</code>，則那個<code class="literal">b</code>和這個<code class="literal">b</code>不代表同一個變數。具有Internal Linkage的標識符編譯後在符號表中是<code class="literal">LOCAL</code>的符號，但<code class="literal">main</code>函數里面那個<code class="literal">a</code>不能算Internal Linkage的，因為即使在同一個程序檔案中，在不同的函數中聲明多次，也不代表同一個變數。</p></li><li><p>無連結（No Linkage）<a id="id2778908" class="indexterm"></a>。除以上情況之外的標識符都屬於No Linkage的，例如函數的局部變數，以及不表示變數和函數的其它標識符。</p></li></ul></div><p>存儲類修飾符（Storage Class Specifier）<a id="id2778922" class="indexterm"></a>有以下幾種關鍵字，可以修飾變數或函數聲明：</p><div class="itemizedlist"><ul type="disc"><li><p><code class="literal">static</code>，用它修飾的變數的存儲空間是靜態分配的，用它修飾的檔案作用域的變數或函數具有Internal Linkage。</p></li><li><p><code class="literal">auto</code>，用它修飾的變數在函數調用時自動在棧上分配存儲空間，函數返回時自動釋放，例如上例中<code class="literal">main</code>函數里的<code class="literal">b</code>其實就是用<code class="literal">auto</code>修飾的，只不過<code class="literal">auto</code>可以省略不寫，<code class="literal">auto</code>不能修飾檔案作用域的變數。</p></li><li><p><code class="literal">register</code>，編譯器對於用<code class="literal">register</code>修飾的變數會儘可能分配一個專門的寄存器來存儲，但如果實在分配不開寄存器，編譯器就把它當<code class="literal">auto</code>變數處理了，<code class="literal">register</code>不能修飾檔案作用域的變數。現在一般編譯器的優化都做得很好了，它自己會想辦法有效地利用CPU的寄存器，所以現在<code class="literal">register</code>關鍵字也用得比較少了。</p></li><li><p><code class="literal">extern</code>，上面講過，連結屬性是根據一個標識符多次聲明時是不是代表同一個變數或函數來分類的，<code class="literal">extern</code>關鍵字就用於多次聲明同一個標識符，下一章再詳細介紹它的用法。</p></li><li><p><code class="literal">typedef</code>，在<a class="xref" href="ch16s02.html#op.sizeoftypedef">第 2.4 節 “sizeof運算符與typedef類型聲明”</a>講過這個關鍵字，它並不是用來修飾變數的，而是定義一個類型名。在那一節也講過，看<code class="literal">typedef</code>聲明怎麼看呢，首先去掉<code class="literal">typedef</code>把它看成變數聲明，看這個變數是什麼類型的，那麼<code class="literal">typedef</code>就定義了一個什麼類型，也就是說，<code class="literal">typedef</code>在語法結構中出現的位置和前面幾個關鍵字一樣，也是修飾變數聲明的，所以從語法（而不是語義）的角度把它和前面幾個關鍵字歸類到一起。</p></li></ul></div><p>注意，上面介紹的<code class="literal">const</code>關鍵字不是一個Storage Class Specifier，雖然看起來它也修飾一個變數聲明，但是在以後介紹的更複雜的聲明中<code class="literal">const</code>在語法結構中允許出現的位置和Storage Class Specifier是不完全相同的。<code class="literal">const</code>和以後要介紹的<code class="literal">restrict</code>和<code class="literal">volatile</code>關鍵字屬於同一類語法元素，稱為類型限定符（Type Qualifier）<a id="id2779137" class="indexterm"></a>。</p><p>變數的生存期（Storage Duration，或者Lifetime）<a id="id2779152" class="indexterm"></a>分為以下幾類：</p><div class="itemizedlist"><ul type="disc"><li><p>靜態生存期（Static Storage Duration）<a id="id2779166" class="indexterm"></a>，具有外部或內部連結屬性，或者被<code class="literal">static</code>修飾的變數，在程序開始執行時分配和初始化一次，此後便一直存在直到程序結束。這種變數通常位於<code class="literal">.rodata</code>，<code class="literal">.data</code>或<code class="literal">.bss</code>段，例如上例中<code class="literal">main</code>函數外的<code class="literal">A</code>，<code class="literal">a</code>，<code class="literal">b</code>，<code class="literal">c</code>，以及<code class="literal">main</code>函數里的<code class="literal">a</code>。</p></li><li><p>自動生存期（Automatic Storage Duration）<a id="id2779247" class="indexterm"></a>，連結屬性為無連結並且沒有被<code class="literal">static</code>修飾的變數，這種變數在進入塊作用域時在棧上或寄存器中分配，在退出塊作用域時釋放。例如上例中<code class="literal">main</code>函數里的<code class="literal">b</code>和<code class="literal">c</code>。</p></li><li><p>動態分配生存期（Allocated Storage Duration）<a id="id2779286" class="indexterm"></a>，以後會講到調用<code class="literal">malloc</code>函數在進程的堆空間中分配內存，調用<code class="literal">free</code>函數可以釋放這種存儲空間。</p></li></ul></div><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id2778429" href="#id2778429" class="para">30</a>] </sup>為了容易閲讀，這裡我用了“<span class="quote">程序檔案</span>”這個不嚴格的叫法。如果有檔案<code class="literal">a.c</code>包含了<code class="literal">b.h</code>和<code class="literal">c.h</code>，那麼我所說的“<span class="quote">程序檔案</span>”指的是經過預處理把<code class="literal">b.h</code>和<code class="literal">c.h</code>在<code class="literal">a.c</code>中展開之後生成的代碼，在C標準中稱為編譯單元（Translation Unit）<a id="id2778477" class="indexterm"></a>。每個編譯單元可以分別編譯成一個<code class="literal">.o</code>目標檔案，最後這些目標檔案用連結器連結到一起，成為一個執行檔。C標準中大量使用一些非常不通俗的名詞，除了編譯單元之外，還有編譯器叫Translator，變數叫Object，本書不會採用這些名詞，因為我不是在寫C標準。</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch19s02.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch19.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch19s04.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">2. <code class="literal">main</code>函數和啟動常式 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 4. 結構體和聯合體</td></tr></table></div></body></html>
