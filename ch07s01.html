<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>1. 復合類型與結構體</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch07.html" title="第 7 章 結構體" /><link rel="prev" href="ch07.html" title="第 7 章 結構體" /><link rel="next" href="ch07s02.html" title="2. 數據抽象" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">1. 復合類型與結構體</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch07.html">上一頁</a> </td><th width="60%" align="center">第 7 章 結構體</th><td width="20%" align="right"> <a accesskey="n" href="ch07s02.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2730146"></a>1. 復合類型與結構體</h2></div></div></div><p>在編程語言中，最基本的、不可再分的數據類型稱為基本類型（Primitive Type）<a id="id2729520" class="indexterm"></a>，例如整型、浮點型；根據語法規則由基本類型組合而成的類型稱為復合類型（Compound Type）<a id="id2729529" class="indexterm"></a>，例如字元串是由很多字元組成的。有些場合下要把復合類型當作一個整體來用，而另外一些場合下需要分解組成這個復合類型的各種基本類型，復合類型的這種兩面性為數據抽象（Data Abstraction）<a id="id2729540" class="indexterm"></a>奠定了基礎。<a class="xref" href="bi01.html#bibli.sicp" title="Structure and Interpretation of Computer Programs">[<abbr class="abbrev">SICP</abbr>]</a>指出，在學習一門編程語言時要特別注意以下三個方面：</p><div class="orderedlist"><ol type="1"><li><p>這門語言提供了哪些Primitive，比如基本類型，比如基本運算符、表達式和語句。</p></li><li><p>這門語言提供了哪些組合規則，比如基本類型如何組成復合類型，比如簡單的表達式和語句如何組成複雜的表達式和語句。</p></li><li><p>這門語言提供了哪些抽象機制，包括數據抽象和過程抽象（Procedure Abstraction）<a id="id2730187" class="indexterm"></a>。</p></li></ol></div><p>本章以結構體為例講解數據類型的組合和數據抽象。至于過程抽象，我們在<a class="xref" href="ch04s02.html#cond.ifelse">第 2 節 “if/else語句”</a>已經見過最簡單的形式，就是把一組語句用一個函數名封裝起來，當作一個整體使用，本章將介紹更複雜的過程抽象。</p><p>現在我們用C語言表示一個複數。從直角座標系來看，複數由實部和虛部組成，從極座標系來看，複數由模和輻角組成，兩種座標系可以相互轉換，如下圖所示：</p><div class="figure"><a id="id2730217"></a><p class="title"><b>圖 7.1. 複數</b></p><div class="figure-contents"><div><img src="images/struct.complex.png" alt="複數" /></div></div></div><br class="figure-break" /><p>如果用實部和虛部表示一個複數，我們可以寫成由兩個<code class="literal">double</code>型組成的結構體：</p><pre class="programlisting">struct complex_struct {
	double x, y;
};</pre><p>這一句定義了標識符<code class="literal">complex_struct</code>（同樣遵循標識符的命名規則），這種標識符在C語言中稱為Tag<a id="id2730254" class="indexterm"></a>，<code class="literal">struct complex_struct { double x, y; }</code>整個可以看作一個類型名<sup>[<a id="id2730268" href="#ftn.id2730268" class="footnote">12</a>]</sup>，就像<code class="literal">int</code>或<code class="literal">double</code>一樣，只不過它是一個復合類型，如果用這個類型名來定義變數，可以這樣寫：</p><pre class="programlisting">struct complex_struct {
	double x, y;
} z1, z2;</pre><p>這樣<code class="literal">z1</code>和<code class="literal">z2</code>就是兩個變數名，變數定義後面帶個;號是我們早就習慣的。但即使像先前的例子那樣只定義了<code class="literal">complex_struct</code>這個Tag而不定義變數，}後面的;號也不能少。這點一定要注意，類型定義也是一種聲明，聲明都要以;號結尾，結構體類型定義的}後面少;號是初學者常犯的錯誤。不管是用上面兩種形式的哪一種定義了<code class="literal">complex_struct</code>這個Tag，以後都可以直接用<code class="literal">struct complex_struct</code>來代替類型名了。例如可以這樣定義另外兩個複數變數：</p><pre class="programlisting">struct complex_struct z3, z4;</pre><p>如果在定義結構體類型的同時定義了變數，也可以不必寫Tag，例如：</p><pre class="programlisting">struct {
	double x, y;
} z1, z2;</pre><p>但這樣就沒辦法再次引用這個結構體類型了，因為它沒有名字。每個複數變數都有兩個成員（Member）<a id="id2730396" class="indexterm"></a>x和y，可以用.運算符（.號，Period）<a id="id2730404" class="indexterm"></a>來訪問，這兩個成員的存儲空間是相鄰的<sup>[<a id="id2730413" href="#ftn.id2730413" class="footnote">13</a>]</sup>，合在一起組成複數變數的存儲空間。看下面的例子：</p><div class="example"><a id="id2730428"></a><p class="title"><b>例 7.1. 定義和訪問結構體</b></p><div class="example-contents"><pre class="programlisting">#include &lt;stdio.h&gt;

int main(void)
{
	struct complex_struct { double x, y; } z;
	double x = 3.0;	
	z.x = x;
	z.y = 4.0;
	if (z.y &lt; 0)
		printf("z=%f%fi\n", z.x, z.y);
	else
		printf("z=%f+%fi\n", z.x, z.y);

	return 0;
}</pre></div></div><br class="example-break" /><p>注意上例中變數<code class="literal">x</code>和變數<code class="literal">z</code>的成員<code class="literal">x</code>的名字並不衝突，因為變數<code class="literal">z</code>的成員<code class="literal">x</code>只能通過表達式<code class="literal">z.x</code>來訪問，編譯器可以從語法上區分哪個<code class="literal">x</code>是變數<code class="literal">x</code>，哪個<code class="literal">x</code>是變數<code class="literal">z</code>的成員<code class="literal">x</code>，<a class="xref" href="ch19s03.html#asmc.layout">第 3 節 “變數的存儲佈局”</a>會講到這兩個標識符<code class="literal">x</code>屬於不同的命名空間。結構體Tag也可以定義在全局作用域中，這樣定義的Tag在其定義之後的各函數中都可以使用。例如：</p><pre class="programlisting">struct complex_struct { double x, y; };

int main(void)
{
	struct complex_struct z;
	...
}</pre><p>結構體變數也可以在定義時初始化，例如：</p><pre class="programlisting">struct complex_struct z = { 3.0, 4.0 };</pre><p>Initializer中的數據依次賦給結構體的各成員。如果Initializer中的數據比結構體的成員多，編譯器會報錯，但如果只是末尾多個逗號則不算錯。如果Initializer中的數據比結構體的成員少，未指定的成員將用0來初始化，就像未初始化的全局變數一樣。例如以下幾種形式的初始化都是合法的：</p><pre class="programlisting">double x = 3.0;
struct complex_struct z1 = { x, 4.0, }; /* z1.x=3.0, z1.y=4.0 */
struct complex_struct z2 = { 3.0, }; /* z2.x=3.0, z2.y=0.0 */
struct complex_struct z3 = { 0 }; /* z3.x=0.0, z3.y=0.0 */</pre><p>注意，<code class="literal">z1</code>必須是局部變數才能用另一個變數<code class="literal">x</code>的值來初始化它的成員，如果是全局變數就只能用常量表達式來初始化。這也是C99的新特性，C89隻允許在{}中使用常量表達式來初始化，無論是初始化全局變數還是局部變數。</p><p>{}這種語法不能用於結構體的賦值，例如這樣是錯誤的：</p><pre class="programlisting">struct complex_struct z1;
z1 = { 3.0, 4.0 };</pre><p>以前我們初始化基本類型的變數所使用的Initializer都是表達式，表達式當然也可以用來賦值，但現在這種由{}括起來的Initializer並不是表達式，所以不能用來賦值<sup>[<a id="id2730593" href="#ftn.id2730593" class="footnote">14</a>]</sup>。Initializer的語法總結如下：</p><div class="literallayout"><p>Initializer → 表達式<br />
Initializer → { 初始化列表 } <br />
初始化列表 → Designated-Initializer, Designated-Initializer, ...<br />
（最後一個Designated-Initializer末尾可以有一個多餘的,號）<br />
Designated-Initializer → Initializer<br />
Designated-Initializer → .標識符 = Initializer<br />
Designated-Initializer → [常量表達式] = Initializer</p></div><p>Designated Initializer<a id="id2730636" class="indexterm"></a>是C99引入的新特性，用於初始化稀疏（Sparse）<a id="id2730644" class="indexterm"></a>結構體和稀疏數組很方便。有些時候結構體或數組中只有某一個或某幾個成員需要初始化，其它成員都用0初始化即可，用Designated Initializer語法可以針對每個成員做初始化（Memberwise Initialization）<a id="id2730654" class="indexterm"></a>，很方便。例如：</p><pre class="programlisting">struct complex_struct z1 = { .y = 4.0 }; /* z1.x=0.0, z1.y=4.0 */</pre><p>數組的Memberwise Initialization語法將在下一章介紹。</p><p>結構體類型用在表達式中有很多限制，不像基本類型那麼自由，比如+ - * /等算術運算符和&amp;&amp; || !等邏輯運算符都不能作用於結構體類型，<code class="literal">if</code>語句、<code class="literal">while</code>語句中的控製表達式的值也不能是結構體類型。嚴格來說，可以做算術運算的類型稱為算術類型（Arithmetic Type）<a id="id2730692" class="indexterm"></a>，算術類型包括整型和浮點型。可以表示零和非零，可以參與邏輯與、或、非運算或者做控製表達式的類型稱為標量類型（Scalar Type）<a id="id2730702" class="indexterm"></a>，標量類型包括算術類型和以後要講的指針類型，詳見<a class="xref" href="ch23s09.html#pointer.typesummary">圖 23.5 “C語言類型總結”</a>。</p><p>結構體變數之間使用賦值運算符是允許的，用一個結構體變數初始化另一個結構體變數也是允許的，例如：</p><pre class="programlisting">struct complex_struct z1 = { 3.0, 4.0 };
struct complex_struct z2 = z1;
z1 = z2;</pre><p>同樣地，<code class="literal">z2</code>必須是局部變數才能用變數<code class="literal">z1</code>的值來初始化。既然結構體變數之間可以相互賦值和初始化，也就可以當作函數的參數和返回值來傳遞：</p><pre class="programlisting">struct complex_struct add_complex(struct complex_struct z1, struct complex_struct z2)
{
	z1.x = z1.x + z2.x;
	z1.y = z1.y + z2.y;
	return z1;
}</pre><p>這個函數實現了兩個複數相加，如果在<code class="literal">main</code>函數中這樣調用：</p><pre class="programlisting">struct complex_struct z = { 3.0, 4.0 };
z = add_complex(z, z);</pre><p>那麼調用傳參的過程如下圖所示：</p><div class="figure"><a id="id2730772"></a><p class="title"><b>圖 7.2. 結構體傳參</b></p><div class="figure-contents"><div><img src="images/struct.parameter.png" alt="結構體傳參" /></div></div></div><br class="figure-break" /><p>變數<code class="literal">z</code>在<code class="literal">main</code>函數的棧幀上，參數<code class="literal">z1</code>和<code class="literal">z2</code>在<code class="literal">add_complex</code>函數的棧幀上，<code class="literal">z</code>的值分別賦給<code class="literal">z1</code>和<code class="literal">z2</code>。在這個函數里，<code class="literal">z2</code>的實部和虛部被累加到<code class="literal">z1</code>中，然後<code class="literal">return z1;</code>可以看成是：</p><div class="orderedlist"><ol type="1"><li><p>用<code class="literal">z1</code>初始化一個臨時變數。</p></li><li><p>函數返回並釋放棧幀。</p></li><li><p>把臨時變數的值賦給變數<code class="literal">z</code>，釋放臨時變數。</p></li></ol></div><p>由.運算符組成的表達式能不能做左值取決於.運算符左邊的表達式能不能做左值。在上面的例子中，<code class="literal">z</code>是一個變數，可以做左值，因此表達式<code class="literal">z.x</code>也可以做左值，但表達式<code class="literal">add_complex(z, z).x</code>只能做右值而不能做左值，因為表達式<code class="literal">add_complex(z, z)</code>不能做左值。</p><div class="footnotes"><br /><hr width="100" align="left" /><div class="footnote"><p><sup>[<a id="ftn.id2730268" href="#id2730268" class="para">12</a>] </sup>其實C99已經定義了複數類型<code class="literal">_Complex</code>。如果包含C標準庫的標頭檔<code class="literal">complex.h</code>，也可以用<code class="literal">complex</code>做類型名。當然，只要不包含標頭檔<code class="literal">complex.h</code>就可以自己定義標識符<code class="literal">complex</code>，但為了儘量減少混淆，本章的示例代碼都用<code class="literal">complex_struct</code>做標識符而不用<code class="literal">complex</code>。</p></div><div class="footnote"><p><sup>[<a id="ftn.id2730413" href="#id2730413" class="para">13</a>] </sup>我們在<a class="xref" href="ch19s04.html#asmc.structunion">第 4 節 “結構體和聯合體”</a>會看到，結構體成員之間也可能有若干個填充位元組。</p></div><div class="footnote"><p><sup>[<a id="ftn.id2730593" href="#id2730593" class="para">14</a>] </sup>C99引入一種新的表達式語法Compound Literal<a id="id2730598" class="indexterm"></a>可以用來賦值，例如<code class="literal">z1 = (struct complex_struct){ 3.0, 4.0 };</code>，本書不使用這種新語法。</p></div></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch07.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch07.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch07s02.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">第 7 章 結構體 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 2. 數據抽象</td></tr></table></div></body></html>
