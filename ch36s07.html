<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>7. TCP協議</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch36.html" title="第 36 章 TCP/IP協議基礎" /><link rel="prev" href="ch36s06.html" title="6. UDP段格式" /><link rel="next" href="ch37.html" title="第 37 章 socket編程" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">7. TCP協議</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch36s06.html">上一頁</a> </td><th width="60%" align="center">第 36 章 TCP/IP協議基礎</th><td width="20%" align="right"> <a accesskey="n" href="ch37.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2900861"></a>7. TCP協議</h2></div></div></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2900865"></a>7.1. 段格式</h3></div></div></div><p>TCP的段格式如下圖所示（該圖出自<a class="xref" href="bi01.html#bibli.tcpip" title="TCP/IP Illustrated, Volume 1: The Protocols">[<abbr class="abbrev">TCPIP</abbr>]</a>）。</p><div class="figure"><a id="id2900880"></a><p class="title"><b>圖 36.12. TCP段格式</b></p><div class="figure-contents"><div><img src="images/tcpip.tcpformat.png" alt="TCP段格式" /></div></div></div><br class="figure-break" /><p>和UDP協議一樣也有源連接埠號和目的連接埠號，通訊的雙方由IP地址和連接埠號標識。32位序號、32位確認序號、窗口大小稍後詳細解釋。4位首部長度和IP協議頭類似，表示TCP協議頭的長度，以4位元組為單位，因此TCP協議頭最長可以是4x15=60位元組，如果沒有選項欄位，TCP協議頭最短20位元組。URG、ACK、PSH、RST、SYN、FIN是六個控制位，本節稍後將解釋SYN、ACK、FIN、RST四個位，其它位的解釋從略。16位檢驗和將TCP協議頭和數據都計算在內。緊急指針和各種選項的解釋從略。</p></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2900917"></a>7.2. 通訊時序</h3></div></div></div><p>下圖是一次TCP通訊的時序圖。</p><div class="figure"><a id="id2900926"></a><p class="title"><b>圖 36.13. TCP連接建立斷開</b></p><div class="figure-contents"><div><img src="images/tcpip.tcpconnection.png" alt="TCP連接建立斷開" /></div></div></div><br class="figure-break" /><p>在這個例子中，首先客戶端主動發起連接、發送請求，然後伺服器端響應請求，然後客戶端主動關閉連接。兩條豎綫表示通訊的兩端，從上到下表示時間的先後順序，注意，數據從一端傳到網絡的另一端也需要時間，所以圖中的箭頭都是斜的。雙方發送的段按時間順序編號為1-10，各段中的主要信息在箭頭上標出，例如段2的箭頭上標着SYN, 8000(0), ACK 1001, &lt;mss 1024&gt;，表示該段中的SYN位置1，32位序號是8000，該段不攜帶有效載荷（數據位元組數為0），ACK位置1，32位確認序號是1001，帶有一個mss選項值為1024。</p><p>建立連接的過程：</p><div class="orderedlist"><ol type="1"><li><p>客戶端發出段1，SYN位表示連接請求。序號是1000，這個序號在網絡通訊中用作臨時的地址，每發一個數據位元組，這個序號要加1，這樣在接收端可以根據序號排出數據包的正確順序，也可以發現丟包的情況，另外，規定SYN位和FIN位也要占一個序號，這次雖然沒發數據，但是由於發了SYN位，因此下次再發送應該用序號1001。mss表示最大段尺寸，如果一個段太大，封裝成幀後超過了鏈路層的最大幀長度，就必須在IP層分片，為了避免這種情況，客戶端聲明自己的最大段尺寸，建議伺服器端發來的段不要超過這個長度。</p></li><li><p>伺服器發出段2，也帶有SYN位，同時置ACK位表示確認，確認序號是1001，表示“我接收到序號1000及其以前所有的段，請你下次發送序號為1001的段”，也就是應答了客戶端的連接請求，同時也給客戶端發出一個連接請求，同時聲明最大尺寸為1024。</p></li><li><p>客戶端發出段3，對伺服器的連接請求進行應答，確認序號是8001。</p></li></ol></div><p>在這個過程中，客戶端和伺服器分別給對方發了連接請求，也應答了對方的連接請求，其中伺服器的請求和應答在一個段中發出，因此一共有三個段用於建立連接，稱為'''三方握手（three-way-handshake）'''。在建立連接的同時，雙方協商了一些信息，例如雙方發送序號的初始值、最大段尺寸等。</p><p>在TCP通訊中，如果一方收到另一方發來的段，讀出其中的目的連接埠號，發現本機並沒有任何進程使用這個連接埠，就會應答一個包含RST位的段給另一方。例如，伺服器並沒有任何進程使用8080連接埠，我們卻用telnet客戶端去連接它，伺服器收到客戶端發來的SYN段就會應答一個RST段，客戶端的telnet程序收到RST段後報告錯誤Connection refused：</p><pre class="screen">$ telnet 192.168.0.200 8080
Trying 192.168.0.200...
telnet: Unable to connect to remote host: Connection refused</pre><p>數據傳輸的過程：</p><div class="orderedlist"><ol type="1"><li><p>客戶端發出段4，包含從序號1001開始的20個位元組數據。</p></li><li><p>伺服器發出段5，確認序號為1021，對序號為1001-1020的數據表示確認收到，同時請求發送序號1021開始的數據，伺服器在應答的同時也向客戶端發送從序號8001開始的10個位元組數據，這稱為piggyback。</p></li><li><p>客戶端發出段6，對伺服器發來的序號為8001-8010的數據表示確認收到，請求發送序號8011開始的數據。</p></li></ol></div><p>在數據傳輸過程中，ACK和確認序號是非常重要的，應用程序交給TCP協議發送的數據會暫存在TCP層的發送緩衝區中，發出數據包給對方之後，只有收到對方應答的ACK段才知道該數據包確實發到了對方，可以從發送緩衝區中釋放掉了，如果因為網絡故障丟失了數據包或者丟失了對方發回的ACK段，經過等待超時後TCP協議自動將發送緩衝區中的數據包重發。</p><p>這個例子只描述了最簡單的一問一答的情景，實際的TCP數據傳輸過程可以收發很多數據段，雖然典型的情景是客戶端主動請求伺服器被動應答，但也不是必須如此，事實上TCP協議為應用層提供了全雙工（full-duplex）的服務，雙方都可以<span class="emphasis"><em>主動甚至同時</em></span>給對方發送數據。</p><p>如果通訊過程只能採用一問一答的方式，收和發兩個方向不能同時傳輸，在同一時間只允許一個方向的數據傳輸，則稱為'''半雙工（half-duplex）'''，假設某種面向連接的協議是半雙工的，則只需要一套序號就夠了，不需要通訊雙方各自維護一套序號，想一想為什麼。</p><p>關閉連接的過程：</p><div class="orderedlist"><ol type="1"><li><p>客戶端發出段7，FIN位表示關閉連接的請求。</p></li><li><p>伺服器發出段8，應答客戶端的關閉連接請求。</p></li><li><p>伺服器發出段9，其中也包含FIN位，向客戶端發送關閉連接請求。</p></li><li><p>客戶端發出段10，應答伺服器的關閉連接請求。</p></li></ol></div><p>建立連接的過程是三方握手，而關閉連接通常需要4個段，伺服器的應答和關閉連接請求通常不合併在一個段中，因為有連接半關閉的情況，這種情況下客戶端關閉連接之後就不能再發送數據給伺服器了，但是伺服器還可以發送數據給客戶端，直到伺服器也關閉連接為止，稍後會看到這樣的例子。</p></div><div class="sect2" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2901189"></a>7.3. 流量控制</h3></div></div></div><p>介紹UDP時我們描述了這樣的問題：如果發送端發送的速度較快，接收端接收到數據後處理的速度較慢，而接收緩衝區的大小是固定的，就會丟失數據。TCP協議通過'''滑動窗口（Sliding Window）'''機制解決這一問題。看下圖的通訊過程。</p><div class="figure"><a id="id2901207"></a><p class="title"><b>圖 36.14. 滑動窗口</b></p><div class="figure-contents"><div><img src="images/tcpip.slidingwindow.png" alt="滑動窗口" /></div></div></div><br class="figure-break" /><div class="orderedlist"><ol type="1"><li><p>發送端發起連接，聲明最大段尺寸是1460，初始序號是0，窗口大小是4K，表示“我的接收緩衝區還有4K位元組空閒，你發的數據不要超過4K”。接收端應答連接請求，聲明最大段尺寸是1024，初始序號是8000，窗口大小是6K。發送端應答，三方握手結束。</p></li><li><p>發送端發出段4-9，每個段帶1K的數據，發送端根據窗口大小知道接收端的緩衝區滿了，因此停止發送數據。</p></li><li><p>接收端的應用程序提走2K數據，接收緩衝區又有了2K空閒，接收端發出段10，在應答已收到6K數據的同時聲明窗口大小為2K。</p></li><li><p>接收端的應用程序又提走2K數據，接收緩衝區有4K空閒，接收端發出段11，重新聲明窗口大小為4K。</p></li><li><p>發送端發出段12-13，每個段帶2K數據，段13同時還包含FIN位。</p></li><li><p>接收端應答接收到的2K數據（6145-8192），再加上FIN位占一個序號8193，因此應答序號是8194，連接處于半關閉狀態，接收端同時聲明窗口大小為2K。</p></li><li><p>接收端的應用程序提走2K數據，接收端重新聲明窗口大小為4K。</p></li><li><p>接收端的應用程序提走剩下的2K數據，接收緩衝區全空，接收端重新聲明窗口大小為6K。</p></li><li><p>接收端的應用程序在提走全部數據後，決定關閉連接，發出段17包含FIN位，發送端應答，連接完全關閉。</p></li></ol></div><p>上圖在接收端用小方塊表示1K數據，實心的小方塊表示已接收到的數據，虛線框表示接收緩衝區，因此套在虛線框中的空心小方塊表示窗口大小，從圖中可以看出，隨着應用程序提走數據，虛線框是向右滑動的，因此稱為滑動窗口。</p><p>從這個例子還可以看出，發送端是一K一K地發送數據，而接收端的應用程序可以兩K兩K地提走數據，當然也有可能一次提走3K或6K數據，或者一次只提走幾個位元組的數據，也就是說，應用程序所看到的數據是一個整體，或說是一個流（stream），在底層通訊中這些數據可能被拆成很多數據包來發送，但是一個數據包有多少位元組對應用程序是不可見的，因此TCP協議是面向流的協議。而UDP是面向消息的協議，每個UDP段都是一條消息，應用程序必須以消息為單位提取數據，不能一次提取任意位元組的數據，這一點和TCP是很不同的。</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch36s06.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch36.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch37.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">6. UDP段格式 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 第 37 章 socket編程</td></tr></table></div></body></html>
