<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>6. 指向指針的指針與指針數組</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch23.html" title="第 23 章 指針" /><link rel="prev" href="ch23s05.html" title="5. 指針與結構體" /><link rel="next" href="ch23s07.html" title="7. 指向數組的指針與多維數組" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">6. 指向指針的指針與指針數組</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch23s05.html">上一頁</a> </td><th width="60%" align="center">第 23 章 指針</th><td width="20%" align="right"> <a accesskey="n" href="ch23s07.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2812522"></a>6. 指向指針的指針與指針數組</h2></div></div></div><p>指針可以指向基本類型，也可以指向復合類型，因此也可以指向另外一個指針變數，稱為指向指針的指針。</p><pre class="programlisting">int i;
int *pi = &amp;i;
int **ppi = &amp;pi;</pre><p>這樣定義之後，表達式<code class="literal">*ppi</code>取<code class="literal">pi</code>的值，表達式<code class="literal">**ppi</code>取<code class="literal">i</code>的值。請讀者自己畫圖理解<code class="literal">i</code>、<code class="literal">pi</code>、<code class="literal">ppi</code>這三個變數之間的關係。</p><p>很自然地，也可以定義指向“<span class="quote">指向指針的指針</span>”的指針，但是很少用到：</p><pre class="programlisting">int ***p;</pre><p>數組中的每個元素可以是基本類型，也可以復合類型，因此也可以是指針類型。例如定義一個數組<code class="literal">a</code>由10個元素組成，每個元素都是<code class="literal">int *</code>指針：</p><pre class="programlisting">int *a[10];</pre><p>這稱為指針數組。<code class="literal">int *a[10];</code>和<code class="literal">int **pa;</code>之間的關係類似於<code class="literal">int a[10];</code>和<code class="literal">int *pa;</code>之間的關係：<code class="literal">a</code>是由一種元素組成的數組，<code class="literal">pa</code>則是指向這種元素的指針。所以，如果<code class="literal">pa</code>指向<code class="literal">a</code>的首元素：</p><pre class="programlisting">int *a[10];
int **pa = &amp;a[0];</pre><p>則<code class="literal">pa[0]</code>和<code class="literal">a[0]</code>取的是同一個元素，唯一比原來複雜的地方在於這個元素是一個<code class="literal">int *</code>指針，而不是基本類型。</p><p>我們知道main函數的標準原型應該是<code class="literal">int main(int argc, char *argv[]);</code>。<code class="literal">argc</code>是命令行參數的個數。而<code class="literal">argv</code>是一個指向指針的指針，為什麼不是指針數組呢？因為前面講過，函數原型中的<code class="literal">[]</code>表示指針而不表示數組，等價于<code class="literal">char **argv</code>。那為什麼要寫成<code class="literal">char *argv[]</code>而不寫成<code class="literal">char **argv</code>呢？這樣寫給讀代碼的人提供了有用信息，<code class="literal">argv</code>不是指向單個指針，而是指向一個指針數組的首元素。數組中每個元素都是<code class="literal">char *</code>指針，指向一個命令行參數字元串。</p><div class="example"><a id="id2812763"></a><p class="title"><b>例 23.2. 打印命令行參數</b></p><div class="example-contents"><pre class="programlisting">#include &lt;stdio.h&gt;

int main(int argc, char *argv[])
{
	int i;
	for(i = 0; i &lt; argc; i++)
		printf("argv[%d]=%s\n", i, argv[i]);
	return 0;
}</pre></div></div><br class="example-break" /><p>編譯執行：</p><pre class="programlisting">$ gcc main.c
$ ./a.out a b c
argv[0]=./a.out
argv[1]=a
argv[2]=b
argv[3]=c
$ ln -s a.out printargv
$ ./printargv d e 
argv[0]=./printargv
argv[1]=d
argv[2]=e</pre><p>注意程序名也算一個命令行參數，所以執行<code class="literal">./a.out a b c</code>這個命令時，<code class="literal">argc</code>是4，<code class="literal">argv</code>如下圖所示：</p><div class="figure"><a id="id2812809"></a><p class="title"><b>圖 23.4. <code class="literal">argv</code>指針數組</b></p><div class="figure-contents"><div><img src="images/pointer.argv.png" alt="argv指針數組" /></div></div></div><br class="figure-break" /><p>由於<code class="literal">argv[4]</code>是<code class="literal">NULL</code>，我們也可以這樣循環遍歷<code class="literal">argv</code>：</p><pre class="programlisting">for(i=0; argv[i] != NULL; i++)</pre><p><code class="literal">NULL</code>標識着<code class="literal">argv</code>的結尾，這個循環碰到<code class="literal">NULL</code>就結束，因而不會訪問越界，這種用法很形象地稱為Sentinel<a id="id2812874" class="indexterm"></a>，<code class="literal">NULL</code>就像一個哨兵守衛着數組的邊界。</p><p>在這個例子中我們還看到，如果給程序建立符號連結，然後通過符號連結運行這個程序，就可以得到不同的<code class="literal">argv[0]</code>。通常，程序會根據不同的命令行參數做不同的事情，例如<code class="literal">ls -l</code>和<code class="literal">ls -R</code>打印不同的檔案列表，而有些程序會根據不同的<code class="literal">argv[0]</code>做不同的事情，例如專門針對嵌入式系統的開源項目Busybox，將各種Linux命令裁剪後集於一身，編譯成一個執行檔<code class="literal">busybox</code>，安裝時將<code class="literal">busybox</code>程序拷到嵌入式系統的<code class="literal">/bin</code>目錄下，同時在<code class="literal">/bin</code>、<code class="literal">/sbin</code>、<code class="literal">/usr/bin</code>、<code class="literal">/usr/sbin</code>等目錄下創建很多指向<code class="literal">/bin/busybox</code>的符號連結，命名為<code class="literal">cp</code>、<code class="literal">ls</code>、<code class="literal">mv</code>、<code class="literal">ifconfig</code>等等，不管執行哪個命令其實最終都是在執行<code class="literal">/bin/busybox</code>，它會根據<code class="literal">argv[0]</code>來區分不同的命令。</p><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2813010"></a>習題</h3></div></div></div><p>1、想想以下定義中的<code class="literal">const</code>分別起什麼作用？編寫程序驗證你的猜測。</p><pre class="programlisting">const char **p;
char *const *p;
char **const p;</pre></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch23s05.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch23.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch23s07.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">5. 指針與結構體 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 7. 指向數組的指針與多維數組</td></tr></table></div></body></html>
