<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><title>3. 哈希表</title><link rel="stylesheet" href="styles.css" type="text/css" /><meta name="generator" content="DocBook XSL Stylesheets V1.73.2" /><link rel="start" href="index.html" title="Linux C編程一站式學習" /><link rel="up" href="ch26.html" title="第 26 章 鏈表、二叉樹和哈希表" /><link rel="prev" href="ch26s02.html" title="2. 二叉樹" /><link rel="next" href="ch27.html" title="第 27 章 本階段總結" /></head><body><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">3. 哈希表</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="ch26s02.html">上一頁</a> </td><th width="60%" align="center">第 26 章 鏈表、二叉樹和哈希表</th><td width="20%" align="right"> <a accesskey="n" href="ch27.html">下一頁</a></td></tr></table><hr /></div><div class="sect1" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a id="id2846250"></a>3. 哈希表</h2></div></div></div><p>下圖示意了哈希表（Hash Table）這種資料結構。</p><div class="figure"><a id="id2846258"></a><p class="title"><b>圖 26.12. 哈希表</b></p><div class="figure-contents"><div><img src="images/linkedlist.hashtab.png" alt="哈希表" /></div></div></div><br class="figure-break" /><p>如上圖所示，首先分配一個指針數組，數組的每個元素是一個鏈表的頭指針，每個鏈表稱為一個槽（Slot）<a id="id2846275" class="indexterm"></a>。哪個數據應該放入哪個槽中由哈希函數決定，在這個例子中我們簡單地選取哈希函數h(x) = x % 11，這樣任意數據x都可以映射成0~10之間的一個數，就是槽的編號，將數據放入某個槽的操作就是鏈表的插入操作。</p><p>如果每個槽裡至多只有一個數據，可以想像這種情況下<code class="literal">search</code>、<code class="literal">insert</code>和<code class="literal">delete</code>操作的時間複雜度都是O(1)，但有時會有多個數據被哈希函數映射到同一個槽中，這稱為碰撞（Collision）<a id="id2846311" class="indexterm"></a>，設計一個好的哈希函數可以把數據比較均勻地分佈到各個槽中，儘量避免碰撞。如果能把n個數據比較均勻地分佈到m個槽中，每個糟里約有n/m個數據，則<code class="literal">search</code>、<code class="literal">insert</code>和<code class="literal">delete</code>和操作的時間複雜度都是O(n/m)，如果n和m的比是常數，則時間複雜度仍然是O(1)。一般來說，要處理的數據越多，構造哈希表時分配的槽也應該越多，所以n和m成正比這個假設是成立的。</p><p>請讀者自己編寫程序構造這樣一個哈希表，並實現<code class="literal">search</code>、<code class="literal">insert</code>和<code class="literal">delete</code>操作。</p><p>如果用我們學過的各種資料結構來表示n個數據的集合，下表是<code class="literal">search</code>、<code class="literal">insert</code>和<code class="literal">delete</code>操作在平均情況下的時間複雜度比較。</p><div class="table"><a id="id2846390"></a><p class="title"><b>表 26.1. 各種資料結構的search、insert和delete操作在平均情況下的時間複雜度比較</b></p><div class="table-contents"><table summary="各種資料結構的search、insert和delete操作在平均情況下的時間複雜度比較" border="1"><colgroup><col /><col /><col /><col /></colgroup><thead><tr><th>資料結構</th><th>search</th><th>insert</th><th>delete</th></tr></thead><tbody><tr><td>數組</td><td>O(n)，有序數組折半查找是O(lgn)</td><td>O(n)</td><td>O(n)</td></tr><tr><td>雙向鏈表</td><td>O(n)</td><td>O(1)</td><td>O(1)</td></tr><tr><td>排序二叉樹</td><td>O(lgn)</td><td>O(lgn)</td><td>O(lgn)</td></tr><tr><td>哈希表（n與槽數m成正比）</td><td>O(1)</td><td>O(1)</td><td>O(1)</td></tr></tbody></table></div></div><br class="table-break" /><div class="simplesect" lang="zh-cn" xml:lang="zh-cn"><div class="titlepage"><div><div><h3 class="title"><a id="id2846467"></a>習題</h3></div></div></div><p>1、統計一個文本檔案中每個單詞的出現次數，然後按出現次數排序並打印輸出。單詞由連續的英文字母組成，不區分大小寫。</p><p>2、實現一個函數求兩個數組的交集：<code class="literal">size_t intersect(const int a[], size_t nmema, const int b[], size_t nmemb, int c[], size_t nmemc);</code>。數組元素是32位<code class="literal">int</code>型的。數組<code class="literal">a</code>有<code class="literal">nmema</code>個元素且各不相同，數組<code class="literal">b</code>有<code class="literal">nmemb</code>個元素且各不相同。要求找出數組<code class="literal">a</code>和數組<code class="literal">b</code>的交集保存到數組<code class="literal">c</code>中，<code class="literal">nmemc</code>是數組<code class="literal">c</code>的最大長度，返回值表示交集中實際有多少個元素，如果交集中實際的元素數量超過了<code class="literal">nmemc</code>則返回<code class="literal">nmemc</code>個元素。數組<code class="literal">a</code>和數組<code class="literal">b</code>的元素數量可能會很大（比如上百萬個），需要設計儘可能快的算法。</p></div></div><div class="navfooter"><hr /><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="ch26s02.html">上一頁</a> </td><td width="20%" align="center"><a accesskey="u" href="ch26.html">上一級</a></td><td width="40%" align="right"> <a accesskey="n" href="ch27.html">下一頁</a></td></tr><tr><td width="40%" align="left" valign="top">2. 二叉樹 </td><td width="20%" align="center"><a accesskey="h" href="index.html">起始頁</a></td><td width="40%" align="right" valign="top"> 第 27 章 本階段總結</td></tr></table></div></body></html>
